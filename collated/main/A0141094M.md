# A0141094M
###### \java\seedu\typed\commons\util\StringUtil.java
``` java
    /**
     * Returns true if the {@code sentence} contains the {@code query} or a similar {@code query}.
     * Ignores case, and both full word match or similar word match are allowed. <br>
     * @param sentence cannot be null
     * @param query cannot be null, cannot be empty, must be a single word
     */
    public static boolean isFuzzyKeywordSearchIgnoreCase(String sentence, String query) {
        assert sentence != null : SENTENCE_CANNOT_BE_NULL_MESSAGE;
        assert query != null : QUERY_CANNOT_BE_NULL_MESSAGE;
        String trimmedQuery = trimQuery(query);
        String[] wordsInSentence = sentence.split(WHITESPACE_DELIMITER);
        for (String word : wordsInSentence) {
            if (FindUtil.isFuzzyWordMatchIgnoreCase(word, trimmedQuery)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if the {@code tags} contain the {@code query} or a similar {@code query}.
     * Ignores case, and both exact tag match or similar tag match are allowed.
     * @param tags cannot be null
     * @param query cannot be null, cannot be empty, must be a single word
     */
    public static boolean isFuzzyKeywordSearchIgnoreCase(UniqueTagList tags, String query) {
        assert tags != null : TAGS_CANNOT_BE_NULL;
        assert query != null : QUERY_CANNOT_BE_NULL_MESSAGE;
        String trimmedQuery = trimQuery(query);
        for (Tag tag : tags) {
            String tagWord = tag.getValue();
            if (FindUtil.isFuzzyTagMatchIgnoreCase(tagWord, trimmedQuery)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Trims {@code query} and checks that the trimmed query is non-empty and is a single word.
     */
    private static String trimQuery(String query) {
        String trimmedQuery = query.trim();
        assert !trimmedQuery.isEmpty() : QUERY_CANNOT_BE_EMPTY_MESSAGE;
        assert trimmedQuery.split(WHITESPACE_DELIMITER).length == 1 : QUERY_SHOULD_BE_A_SINGLE_WORD_MESSAGE;
        return trimmedQuery;
    }
```
###### \java\seedu\typed\logic\commands\AddCommand.java
``` java
    public static final String COMMAND_WORD_ADD = "add";
    public static final String COMMAND_WORD_CREATE = "create";
    public static final String COMMAND_WORD_DO = "do";
    public static final String COMMAND_WORD_NEW = "new";
```
###### \java\seedu\typed\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using given values, without recurrence.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String notes, LocalDateTime date, LocalDateTime from,
            LocalDateTime to, Set<String> tags) throws IllegalValueException {
        ScheduleElement se;
        if (date == null && from != null && to != null) {
            se = new ScheduleElement(new DateTime(from), new DateTime(to));
        } else if (date != null && from == null && to == null) {
            se = new ScheduleElement(new DateTime(date));
        } else {
            se = new ScheduleElement();
        }
        this.toAdd = new TaskBuilder()
                         .setName(name)
                         .setNotes(notes)
                         .setSE(se)
                         .setTags(tags)
                         .build();
    }
```
###### \java\seedu\typed\logic\commands\ClearCommand.java
``` java
    public static final String COMMAND_WORD_CLEAR = "clear";
    public static final String COMMAND_WORD_EMPTY = "empty";
```
###### \java\seedu\typed\logic\commands\CompleteCommand.java
``` java
    public static final String COMMAND_WORD_FINISH = "finish";
    public static final String COMMAND_WORD_MARK = "mark";
    public static final String COMMAND_WORD_DONE = "done";
    public static final String COMMAND_WORD_CHECK = "check";
    public static final String COMMAND_WORD_COMPLETE = "complete";
    public static final String COMMAND_WORD_END = "end";
```
###### \java\seedu\typed\logic\commands\DeleteCommand.java
``` java
    public static final String COMMAND_WORD_DELETE = "delete";
    public static final String COMMAND_WORD_DEL = "del";
    public static final String COMMAND_WORD_REMOVE = "remove";
    public static final String COMMAND_WORD_RM = "rm";
```
###### \java\seedu\typed\logic\commands\EditCommand.java
``` java
    public static final String COMMAND_WORD_EDIT = "edit";
    public static final String COMMAND_WORD_UPDATE = "update";
    public static final String COMMAND_WORD_CHANGE = "change";
```
###### \java\seedu\typed\logic\commands\EditCommand.java
``` java
        if (listIndexOutOfBounds(lastShownList)) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
```
###### \java\seedu\typed\logic\commands\EditCommand.java
``` java
    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     * @throws IllegalValueException
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor)
            throws IllegalValueException {
        assert taskToEdit != null;
        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Notes updatedNotes = editTaskDescriptor.getNotes().orElseGet(taskToEdit::getNotes);
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);
        ScheduleElement updatedSe;

        //current implementation only supports changing deadlines and adding deadlines to floating
        if (hasOnlyDeadlineField(editTaskDescriptor)) {
            updatedSe = new ScheduleElement(editTaskDescriptor.getDate().get(),
                    taskToEdit.getSE().getStartDate(), taskToEdit.getSE().getEndDate());
        } else if (hasOnlyFromAndToFields(editTaskDescriptor)
                || hasNoDeadlineAndNoFromToFields(editTaskDescriptor)) {
            updatedSe = taskToEdit.getSE();
        } else {
            throw new IllegalValueException(MESSAGE_EDIT_TASK_FAILURE);
        }
        return new TaskBuilder()
                .setName(updatedName)
                .setNotes(updatedNotes)
                .setSE(updatedSe)
                .setTags(updatedTags)
                .isCompleted(taskToEdit.getIsCompleted())
                .build();
    }

    private static boolean hasOnlyFromAndToFields(EditTaskDescriptor edt) {
        return !edt.getDate().isPresent()
                && edt.getFrom().isPresent() && edt.getTo().isPresent();
    }

    private static boolean hasOnlyDeadlineField(EditTaskDescriptor edt) {
        return edt.getDate().isPresent()
                && !edt.getFrom().isPresent() && !edt.getTo().isPresent();
    }

    private static boolean hasNoDeadlineAndNoFromToFields(EditTaskDescriptor edt) {
        return !edt.getDate().isPresent()
                && !edt.getFrom().isPresent() && !edt.getTo().isPresent();
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<DateTime> date = Optional.empty();
        private Optional<DateTime> from = Optional.empty();
        private Optional<DateTime> to = Optional.empty();
        private Optional<Notes> notes = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {
        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.date = toCopy.getDate();
            this.from = toCopy.getFrom();
            this.to = toCopy.getTo();
            this.notes = toCopy.getNotes();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.date, this.from, this.to, this.notes, this.tags);
        }

        public ScheduleElement getSE() {
            DateTime deadline = date.orElse(null);
            DateTime startDateTime = from.orElse(null);
            DateTime endDateTime = to.orElse(null);
            return new ScheduleElement(deadline, startDateTime, endDateTime);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }
        public Optional<Name> getName() {
            return name;
        }

        public void setDate(Optional<DateTime> date) {
            assert date != null;
            this.date = date;
        }
        public Optional<DateTime> getDate() {
            return date;
        }

        public void setFrom(Optional<DateTime> from) {
            assert from != null;
            this.from = from;
        }
        public Optional<DateTime> getFrom() {
            return from;
        }

        public void setTo(Optional<DateTime> to) {
            assert to != null;
            this.to = to;
        }
        public Optional<DateTime> getTo() {
            return to;
        }

        public void setNotes(Optional<Notes> notes) {
            assert notes != null;
            this.notes = notes;
        }

        public Optional<Notes> getNotes() {
            return notes;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }
```
###### \java\seedu\typed\logic\commands\ExitCommand.java
``` java
    public static final String COMMAND_WORD_EXIT = "exit";
    public static final String COMMAND_WORD_QUIT = "quit";
    public static final String COMMAND_WORD_LOGOUT = "logout";
    public static final String COMMAND_WORD_BYE = "bye";
```
###### \java\seedu\typed\logic\commands\FindCommand.java
``` java

package seedu.typed.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD_FIND = "find";
    public static final String COMMAND_WORD_SEARCH = "search";
    public static final String COMMAND_WORD_QUERY = "query";

    public static final String MESSAGE_USAGE = COMMAND_WORD_FIND + ": Finds all tasks whose names contain any of "
            + "the specified keywords or tags (not case-sensitive).\n"
            + "Example: " + COMMAND_WORD_FIND + " broccoli #green #healthy";

    private final Set<String> keywords;
    private final Set<String> tagKeywords;

    public FindCommand(Set<String> keywords, Set<String> tagKeywords) {
        assert keywords != null;
        assert tagKeywords != null;
        this.keywords = keywords;
        this.tagKeywords = tagKeywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords, tagKeywords);
        session.updateUndoRedoStacks(COMMAND_WORD_FIND, -1, null);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\typed\logic\commands\HelpCommand.java
``` java
    public static final String COMMAND_WORD_HELP = "help";
    public static final String COMMAND_WORD_MAN = "man";
    public static final String COMMAND_WORD_SOS = "sos";
```
###### \java\seedu\typed\logic\commands\ListCommand.java
``` java
package seedu.typed.logic.commands;

import seedu.typed.commons.exceptions.IllegalValueException;

/**
 * Lists all tasks in the task manager to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD_LIST = "list";
    public static final String COMMAND_WORD_FILTER = "filter";
    public static final String COMMAND_WORD_SHOW = "show";
    public static final String COMMAND_WORD_LS = "ls";
    public static final String COMMAND_WORD_DISPLAY = "display";

    public static final String MESSAGE_USAGE = COMMAND_WORD_LIST + ": Lists all undone and upcoming tasks by default, "
            + "or by the CATEGORY if specified. Valid CATEGORYs are: untimed, deadline, duration, done, undone and all."
            + "Parameters: [CATEGORY] \n"
            + "Example: " + COMMAND_WORD_LIST
            + " deadline ";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";

    private final String type;

    public ListCommand(String type) throws IllegalValueException {
        this.type = type;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(type);
        session.updateUndoRedoStacks(COMMAND_WORD_LIST, -1, null);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\typed\logic\commands\util\Day.java
``` java

/**
 *
 */
package seedu.typed.logic.commands.util;

/**
 * @author Peixuan
 *
 */
public enum Day {
    MON(1),
    TUE(2),
    WED(3),
    THU(4),
    FRI(5),
    SAT(6),
    SUN(7);

    private int day;

    Day(int day) {
        this.day = day;
    }
    public int day() {
        return this.day;
    }
}
```
###### \java\seedu\typed\logic\commands\util\Frequency.java
``` java

/**
 *
 */
package seedu.typed.logic.commands.util;

/**
 * @author Peixuan
 *
 */
public enum Frequency {
    DAY("day"),
    WEEK("week"),
    MONTH("month"),
    YEAR("year");

    private String frequency;

    Frequency(String frequency) {
        this.frequency = frequency;
    }

    public String frequency() {
        return this.frequency;
    }
}
```
###### \java\seedu\typed\logic\commands\util\Type.java
``` java

/**
 *
 */
package seedu.typed.logic.commands.util;

/**
 * @author Peixuan
 *
 */
public enum Type {
    ALL("all"),
    DEADLINE("deadline"),
    DURATION("duration"),
    DONE("done"),
    UNDONE("undone"),
    UNTIMED("untimed");

    private String type;

    Type(String type) {
        this.type = type;
    }

    public String getType() {
        return this.type;
    }
}
```
###### \java\seedu\typed\logic\parser\AddCommandParser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_BY;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_EVERY;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_FROM;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_NOTES;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_ON;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_TAG;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_TO;

import java.time.LocalDateTime;
import java.util.NoSuchElementException;
import java.util.Set;

import seedu.typed.commons.exceptions.IllegalValueException;
import seedu.typed.logic.commands.AddCommand;
import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.IncorrectCommand;
import seedu.typed.logic.parser.ArgumentTokenizer.Prefix;

/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    private static final String STARTDATE_AFTER_ENDDATE_ERROR_MESSAGE = "Did you key the wrong dates? The end date "
            + "for your event is earlier than its start date. ";
    private static final String EMPTY_STRING = "";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     * @param {@code args} user input arguments for an Add command
     * @return Command to add a task specified by {@code args}
     */
    public Command parse(String args) {
        try {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_NOTES, PREFIX_BY, PREFIX_ON,
                    PREFIX_FROM, PREFIX_TO, PREFIX_EVERY, PREFIX_TAG);
            argsTokenizer.tokenize(args);

            String name = argsTokenizer.getPreamble().get();
            String notes = getNotes(argsTokenizer);
            String every = getFieldValue(argsTokenizer, PREFIX_EVERY);
            Set<String> tags = ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG));

            String[] dates = getAllDates(argsTokenizer);
            LocalDateTime[] dateTimes = getAllDateTimes(dates);
            dateTimes = checkDatesWrapper(dates, dateTimes);
            if (dateTimes[1] != null && dateTimes[2] != null && dateTimes[1].isAfter(dateTimes[2])) {
                return new IncorrectCommand(STARTDATE_AFTER_ENDDATE_ERROR_MESSAGE);
            }

            if (hasBothByAndOn(argsTokenizer) || isBothDeadlineAndEvent(argsTokenizer)) {
                return new IncorrectCommand(getIncorrectAddMessage());
            }
            if ((isDeadline(argsTokenizer) || isEvent(argsTokenizer)) && isValidRecurrence(every)) {
                return new AddCommand(name, notes, dateTimes[0], dateTimes[1], dateTimes[2], tags, every);
            }
            return new AddCommand(name, notes, dateTimes[0], dateTimes[1], dateTimes[2], tags);

        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(getIncorrectAddMessage());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    private LocalDateTime[] checkDatesWrapper(String[] dates, LocalDateTime[] dateTimes)
            throws IllegalValueException {
        dateTimes = checkDeadlineWrapper(dates, dateTimes);
        dateTimes = checkEventWrapper(dates, dateTimes);
        return dateTimes;
    }

    private LocalDateTime[] checkEventWrapper(String[] dates, LocalDateTime[] dateTimes)
            throws IllegalValueException {
        String start = dates[1];
        String end = dates[2];
        LocalDateTime startDateTime = dateTimes[1];
        LocalDateTime endDateTime = dateTimes[2];
        if (startDateTime == null || endDateTime == null) {
            return dateTimes;
        }
        if (DateTimeParser.isDateInferred(start) || DateTimeParser.isDateInferred(end)) {
            if (startDateTime.isAfter(endDateTime)) {
                dateTimes[1] = startDateTime.plusWeeks(1);
            }
        }
        if (DateTimeParser.isTimeInferred(start)) {
            dateTimes[1] = startDateTime.withHour(0).withMinute(0).withSecond(0).withNano(0);
        }
        if (DateTimeParser.isTimeInferred(end)) {
            dateTimes[2] = endDateTime.withHour(23).withMinute(59).withSecond(59).withNano(59);
        }
        return dateTimes;
    }

    private LocalDateTime[] checkDeadlineWrapper(String[] dates, LocalDateTime[] dateTimes)
            throws IllegalValueException {
        String deadline = dates[0];
        LocalDateTime deadlineDateTime = dateTimes[0];
        if (deadlineDateTime != null && DateTimeParser.isTimeInferred(deadline)) {
            dateTimes[0] = deadlineDateTime.withHour(23).withMinute(59).withSecond(59)
                    .withNano(59);
        }
        return dateTimes;
    }

    private String[] getAllDates(ArgumentTokenizer argsTokenizer)
            throws IllegalValueException {
        assert argsTokenizer != null;
        String[] dates = new String[3];
        dates[0] = getDeadline(argsTokenizer);
        dates[1] = getFieldValue(argsTokenizer, PREFIX_FROM);
        dates[2] = getFieldValue(argsTokenizer, PREFIX_TO);
        return dates;
    }

    private LocalDateTime[] getAllDateTimes(String[] dates)
            throws IllegalValueException {
        assert dates != null;
        LocalDateTime[] dateTimes = new LocalDateTime[3];
        for (int i = 0; i < dates.length; i++) {
            dateTimes[i] = DateTimeParser.getLocalDateTimeFromString(dates[i]);
        }
        return dateTimes;
    }

    private boolean isValidRecurrence(String every) {
        if (every != null) {
            return every.matches("day|week|month|year");
        }
        return false;
    }

    private String getFieldValue(ArgumentTokenizer argsTokenizer, Prefix prefix) {
        if (isFieldPresent(argsTokenizer, prefix)) {
            return argsTokenizer.getValue(prefix).get();
        }
        return null;
    }

    private String getDeadline(ArgumentTokenizer argsTokenizer) {
        String byValue = getFieldValue(argsTokenizer, PREFIX_BY);
        String onValue = getFieldValue(argsTokenizer, PREFIX_ON);
        if (byValue != null) {
            return byValue;
        } else if (onValue != null) {
            return onValue;
        }
        return null;
    }

    private String getNotes(ArgumentTokenizer argsTokenizer) {
        String notesValue = getFieldValue(argsTokenizer, PREFIX_NOTES);
        if (notesValue == null) {
            return EMPTY_STRING;
        }
        return notesValue;
    }

    private String getIncorrectAddMessage() {
        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
    }

    private boolean isFieldPresent(ArgumentTokenizer argsTokenizer, Prefix prefix) {
        return argsTokenizer.getValue(prefix).isPresent();
    }

    private boolean isDeadline(ArgumentTokenizer argsTokenizer) {
        return isFieldPresent(argsTokenizer, PREFIX_BY)
                || isFieldPresent(argsTokenizer, PREFIX_ON);
    }

    private boolean hasBothByAndOn(ArgumentTokenizer argsTokenizer) {
        return isFieldPresent(argsTokenizer, PREFIX_BY)
                && isFieldPresent(argsTokenizer, PREFIX_ON);
    }

    private boolean isBothDeadlineAndEvent(ArgumentTokenizer argsTokenizer) {
        return isDeadline(argsTokenizer) && isEvent(argsTokenizer);
    }

    private boolean isEvent(ArgumentTokenizer argsTokenizer) {
        return isFieldPresent(argsTokenizer, PREFIX_FROM)
                && isFieldPresent(argsTokenizer, PREFIX_TO);
    }

}
```
###### \java\seedu\typed\logic\parser\CliSyntax.java
``` java
    public static final Prefix PREFIX_NOTES = new Prefix(" + ");
    public static final Prefix PREFIX_BY = new Prefix(" by ");
    public static final Prefix PREFIX_ON = new Prefix(" on ");
    public static final Prefix PREFIX_FROM = new Prefix(" from ");
    public static final Prefix PREFIX_TO = new Prefix(" to ");
    public static final Prefix PREFIX_EVERY = new Prefix(" every ");
    public static final Prefix PREFIX_TAG = new Prefix(" #");
```
###### \java\seedu\typed\logic\parser\DateTimeParser.java
``` java

package seedu.typed.logic.parser;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.typed.commons.exceptions.IllegalValueException;
import seedu.typed.model.task.DateTime;

/**
 * Parses date from a non-null string to LocalDateTime.
 * Currently assumes date contains only one date, not multiple.
 */
public class DateTimeParser {

    private static final String MESSAGE_FOR_INVALID_DATE_FORMAT = "The date you entered is invalid or ambiguous. "
            + "Try again with more specific dates! ";

    private static Parser natty = new Parser();

    /**
     * Returns a {@code date} in its Date equivalent.
     * @param {@code date} String containing a {@code date}, cannot be null
     * @return a Date instance of the {@code date} parsed
     */
    public static Date getDateFromString(String date) throws IllegalValueException {
        assert date != null;
        DateGroup dateGroup = getDateGroupFromString(date);
        return dateGroup.getDates().get(0);
    }

    /**
     * Returns a date in its DateTime equivalent.
     * @param {@code ldt} LocalDateTime representing a valid date and time, may be null
     * @return a DateTime instance of the LocalDateTime parsed
     */
    public static DateTime getDateTimeFromLocalDateTime(LocalDateTime ldt) {
        return new DateTime(ldt);
    }

    /**
     * Returns a {@code date} in its DateTime equivalent.
     * @param {@code date} String containing a {@code date}, may be null
     * @return a DateTime instance of the LocalDateTime parsed
     * @throws IllegalValueException
     */
    public static DateTime getDateTimeFromString(String date) throws IllegalValueException {
        return getDateTimeFromLocalDateTime(getLocalDateTimeFromString(date));
    }

    /**
     * Returns a {@code date} in its LocalDateTime equivalent.
     * @param {@code date} String containing a {@code date}, may be null
     * @return a LocalDateTime instance of the parsed {@code date}
     * @throws IllegalValueException if {@code date} is in an invalid or ambiguous format
     */
    public static LocalDateTime getLocalDateTimeFromString(String date) throws IllegalValueException {
        if (date == null) {
            return null;
        }
        DateGroup dateGroup = getDateGroupFromString(date);
        Instant instant = dateGroup.getDates().get(0).toInstant();
        return LocalDateTime.ofInstant(instant, getSystemDefaultTimeZone());
    }

    /**
     * Checks if natty parser inferred date in given {@code date}.
     * @param {@code date} String containing a date, may be null
     * @return true if date is inferred, false if date is specified in {@code date}
     * @throws IllegalValueException if {@code date} is in an invalid or ambiguous format
     */
    public static boolean isDateInferred(String date) throws IllegalValueException {
        return getDateGroupFromString(date).isDateInferred();
    }

    /**
     * Checks if natty parser inferred time in given {@code date}.
     * @param {@code date} String containing a date, may be null
     * @return true if time is inferred, false if time is specified in {@code date}
     * @throws IllegalValueException if {@code date} is in an invalid or ambiguous format
     */
    public static boolean isTimeInferred(String date) throws IllegalValueException {
        return getDateGroupFromString(date).isTimeInferred();
    }

    /**
     * Parses the {@code date} using natty.
     * @param {@code date} String containing a date, may be null
     * @return DateGroup from the natty-parsed {@code date}
     * @throws IllegalValueException if {@code date} is in an invalid or ambiguous format
     */
    public static DateGroup getDateGroupFromString(String date) throws IllegalValueException {
        List<DateGroup> dateGroup = natty.parse(date);
        if (!isEmptyDateGroup(dateGroup)) {
            return dateGroup.get(0);
        }
        throw new IllegalValueException(MESSAGE_FOR_INVALID_DATE_FORMAT);
    }

    /**
     * Checks if the specified {@code DateGroup} is empty.
     */
    private static boolean isEmptyDateGroup(List<DateGroup> dateGroup) {
        return dateGroup.isEmpty() || dateGroup.get(0).getDates().isEmpty();
    }

    /**
     * Returns the system's default timezone.
     */
    private static ZoneId getSystemDefaultTimeZone() {
        return ZoneId.systemDefault();
    }
}
```
###### \java\seedu\typed\logic\parser\EditCommandParser.java
``` java
            if (argsTokenizer.getValue(PREFIX_BY).isPresent()) {
                editTaskDescriptor.setDate(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_BY)));
            } else if (argsTokenizer.getValue(PREFIX_ON).isPresent()) {
                editTaskDescriptor.setDate(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_ON)));
            }
```
###### \java\seedu\typed\logic\parser\FindCommandParser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.typed.logic.parser.CliSyntax.KEYWORDS_ARGS_FORMAT;

import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.FindCommand;
import seedu.typed.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser {

    private static final char TAG_IDENTIFIER = '#';

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     *
     * @param args takes both keywords and tags
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(getIncorrectFindMessage());
        }
        final String[] keywords = matcher.group("keywords").split("\\s+");
        Set<String> nameKeywords = new HashSet<String>();
        Set<String> tagKeywords = new HashSet<String>();
        addKeywordsByType(keywords, nameKeywords, tagKeywords);
        return new FindCommand(nameKeywords, tagKeywords);
    }

    private void addKeywordsByType(String[] keywords, Set<String> nameKeywords, Set<String> tagKeywords) {
        for (String word : keywords) {
            if (isWordATag(word)) {
                tagKeywords.add(word.substring(1));
            } else {
                nameKeywords.add(word);
            }
        }
    }

    /*
     * Returns the message for an incorrect Find command.
     */
    private String getIncorrectFindMessage() {
        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
    }

    /*
     * Checks if {@code word} is a tag.
     */
    private boolean isWordATag(String word) {
        assert word != null;
        assert !word.isEmpty();
        return (word.charAt(0) == TAG_IDENTIFIER);
    }

}
```
###### \java\seedu\typed\logic\parser\FindUtil.java
``` java
package seedu.typed.logic.parser;

/**
 * Contains utility methods used for parsing strings for the command Find.
 */
public class FindUtil {

    static final String QUERY_CANNOT_BE_EMPTY_MESSAGE = "query cannot be empty";
    static final String QUERY_LEN_SHOULD_BE_ONE_MESSAGE = "query parameter should be a single word";
    static final String QUERY_LEN_SHOULD_BE_LESS_THAN_ONE_MESSAGE = "query parameter should be empty or a single word";
    static final String TAG_LEN_SHOULD_BE_ONE_MESSAGE = "tag parameter should be a single word";
    static final String QUERY_CANNOT_BE_NULL_MESSAGE = "query cannot be null";
    static final String STR_CANNOT_BE_NULL_MESSAGE = "str cannot be null";
    private static final String QUERY_LEN_MUST_BE_POSITIVE_INT_MESSAGE = "length of query must be a positive int";
    private static final String STR_LEN_MUST_BE_POSITIVE_INT_MESSAGE = "length of str must be a positive int";
    private static final String WHITESPACE_DELIMITER = "\\s+";
    private static final int MAX_EDIT_DISTANCE = 2; // lower distance = higher similarity
    private static final int MAX_EDIT_DISTANCE_STRICT = 1;


    /**
     * Checks if {@code query} and {@code str} are an exact match, ignoring case.
     */
    public static boolean isExactWordMatchIgnoreCase(String str, String query) {
        assertCheckStrAndQuery(str, query);
        str = str.toLowerCase();
        query = query.toLowerCase();
        return str.equals(query);
    }

    /**
     * Checks if {@code query} is a substring of {@code str}, ignoring case.
     */
    public static boolean isSubstringWordMatchIgnoreCase(String str, String query) {
        assertCheckStrAndQuery(str, query);
        str = str.toLowerCase();
        query = query.toLowerCase();
        return str.contains(query);
    }

    /**
     * Checks if {@code query} is a fuzzy match to {@code str}, ignoring case.
     * @param str non-null string
     * @param query non-null, non-empty string that contains a single word
     * @return isFuzzyMatch boolean indicating if str and query are a fuzzy match, i.e. similar
     */
    public static boolean isFuzzyWordMatchIgnoreCase(String str, String query) {
        assertCheckStrAndQuery(str, query);
        str = str.toLowerCase();
        query = query.toLowerCase();
        if (str.length() <= 2) {
            return isExactWordMatchIgnoreCase(str, query);
        } else if (str.length() <= 4) {
            return computeMinEditDistance(str, query) <= MAX_EDIT_DISTANCE_STRICT;
        } else {
            return computeMinEditDistance(str, query) <= MAX_EDIT_DISTANCE
                    || isSubstringWordMatchIgnoreCase(str, query);
        }
    }

    /**
     * Checks if specified {@code str} is a similar match to any stored tags, ignoring case.
     * @param tag non-null string that contains a single word
     * @param query non-null string that contains a single word
     *          empty string always returns true
     * @return isFuzzyMatch boolean indicating if str and word are a fuzzy match, i.e. similar
     */
    public static boolean isFuzzyTagMatchIgnoreCase(String tag, String query) {
        assert tag != null : STR_CANNOT_BE_NULL_MESSAGE;
        assert query != null : QUERY_CANNOT_BE_NULL_MESSAGE;
        assert tag.split(WHITESPACE_DELIMITER).length == 1 : TAG_LEN_SHOULD_BE_ONE_MESSAGE;
        assert query.split(WHITESPACE_DELIMITER).length <= 1 : QUERY_LEN_SHOULD_BE_LESS_THAN_ONE_MESSAGE;
        tag = tag.toLowerCase();
        query = query.toLowerCase();
        if (query.length() == 0) {
            return true;
        }
        if (tag.length() <= 4) {
            return isExactWordMatchIgnoreCase(tag, query);
        } else {
            return computeMinEditDistance(tag, query) <= MAX_EDIT_DISTANCE_STRICT
                    || isSubstringWordMatchIgnoreCase(tag, query);
        }
    }

    /**
     * Computes the minimum edit distance between specified strings as a measure of similarity.
     * @param str non-null string
     * @param query non-null, non-empty string that contains a single word
     * @return minimumEditDistance an int representation of how similar str and query are
     */
    public static int computeMinEditDistance(String str, String query) {
        assertCheckStrAndQuery(str, query);
        int lenStr = str.length();
        int lenWord = query.length();
        return computeLevenshtein(initDistance(lenStr, lenWord), str, query);
    }

    /**
     * Initializes the minimum edit distance table by padding the first row and column.
     * @param lenStr length of str where str cannot be null
     * @param lenQuery length of query where query cannot be null, empty, and must contain a single word
     * @return editDistance an int array containing the initialized distances
     */
    private static int[][] initDistance(int lenStr, int lenQuery) {
        assert lenStr >= 0 : STR_LEN_MUST_BE_POSITIVE_INT_MESSAGE;
        assert lenQuery >= 0 : QUERY_LEN_MUST_BE_POSITIVE_INT_MESSAGE;
        int[][] editDistance = new int[lenStr + 1][lenQuery + 1];
        for (int c = 0; c < lenQuery + 1; c++) {
            editDistance[0][c] = c;
        }
        for (int r = 0; r < lenStr + 1; r++) {
            editDistance[r][0] = r;
        }
        return editDistance;
    }

    /**
     * Computes the edit distance of given indices using Levenshtein's operations.
     * @param distance an array containing initialized distances
     * @param str non-null string
     * @param query non-null, non-empty string that contains a single word
     * @return minimumEditDistance an int representation of how similar str and word are
     */
    private static int computeLevenshtein(int[][] distance, String str, String query) {
        assertCheckStrAndQuery(str, query);
        for (int i = 1; i < distance.length; i++) {
            for (int j = 1; j < distance[0].length; j++) {
                int a = distance[i - 1][j] + 1;
                int b = distance[i][j - 1] + 1;
                int c = distance[i - 1][j - 1];
                if (str.charAt(i - 1) != query.charAt(j - 1)) {
                    c += 1;
                }
                distance[i][j] = Math.min(a, Math.min(b, c));
            }
        }
        return distance[distance.length - 1][distance[0].length - 1];
    }

    /**
     * Checks that str is not null, and query is not null, not empty, and is a single word.
     */
    private static void assertCheckStrAndQuery(String str, String query) {
        assert str != null : STR_CANNOT_BE_NULL_MESSAGE;
        assert query != null : QUERY_CANNOT_BE_NULL_MESSAGE;
        assert !query.isEmpty() : QUERY_CANNOT_BE_EMPTY_MESSAGE;
        assert query.split(WHITESPACE_DELIMITER).length == 1 : QUERY_LEN_SHOULD_BE_ONE_MESSAGE;
    }

}
```
###### \java\seedu\typed\logic\parser\ListCommandParser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.NoSuchElementException;

import seedu.typed.commons.exceptions.IllegalValueException;
import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.IncorrectCommand;
import seedu.typed.logic.commands.ListCommand;

/**
 * Parses input arguments and creates a new AddCommand object
 */
public class ListCommandParser {

    private static final String ALL_STRING = "all";
    private static final String DONE_STRING = "done";
    private static final String UNDONE_STRING = "undone";
    private static final String DEADLINE_STRING = "deadline";
    private static final String UNTIMED_STRING = "untimed";
    //private static final String FLOATING_STRING = "floating";

    private static final Object DURATION_STRING = "duration";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * ListCommand and returns a ListCommand object for execution.
     */
    public Command parse(String args) {
        try {
            String type = ALL_STRING; // default is show all
            if (args != null && !args.isEmpty()) {
                String lowered = args.trim().toLowerCase();
                if (lowered.equals(ALL_STRING)
                        || lowered.equals(DONE_STRING)
                        || lowered.equals(DEADLINE_STRING)
                        || lowered.equals(UNDONE_STRING)
                        || lowered.equals(UNTIMED_STRING)
                        || lowered.equals(DURATION_STRING)) {
                    type = lowered;
                }
            }
            return new ListCommand(type);
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\seedu\typed\logic\parser\Parser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_EMPTY_COMMAND;
import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.typed.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.typed.logic.commands.AddCommand;
import seedu.typed.logic.commands.ClearCommand;
import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.CompleteCommand;
import seedu.typed.logic.commands.DeleteCommand;
import seedu.typed.logic.commands.EditCommand;
import seedu.typed.logic.commands.ExitCommand;
import seedu.typed.logic.commands.ExportCommand;
import seedu.typed.logic.commands.FindCommand;
import seedu.typed.logic.commands.HelpCommand;
import seedu.typed.logic.commands.ImportCommand;
import seedu.typed.logic.commands.IncorrectCommand;
import seedu.typed.logic.commands.ListCommand;
import seedu.typed.logic.commands.RedoCommand;
import seedu.typed.logic.commands.SaveCommand;
import seedu.typed.logic.commands.SelectCommand;
import seedu.typed.logic.commands.UndoCommand;

/**
 * Parses user input into a Command if input is valid.
 */
public class Parser {

    /**
     * Used for initial separation of command word and arguments.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<args>.*)");

    /**
     * Parses a raw user input and returns the corresponding Command if input is valid.
     *
     * @param input
     *            full user input string
     * @return the command based on the user input
     *          or IncorrectCommand if input is invalid
     */
    public Command parseInput(String input) {
        assert input != null;
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(input.trim());

        if (isEmptyUserInput(input)) {
            return new IncorrectCommand(getEmptyUserInputMessage());
        }

        if (!isValidUserInput(matcher)) {
            return new IncorrectCommand(getInvalidUserInputMessage());
        }
        final String command = matcher.group("commandWord");
        final String args = matcher.group("args");

        return parseValidUserInput(command, args);
    }

    /**
     * Parses a valid user input into its corresponding Command.
     * @param commandWord
     * @param args
     * @return
     */
    private Command parseValidUserInput(final String commandWord, final String args) {
        assert commandWord != null;

        if (isAddCommandWord(commandWord)) {
            return new AddCommandParser().parse(args);
        }
        if (isCompleteCommandWord(commandWord)) {
            return new CompleteCommandParser().parse(args);
        }
        if (isEditCommandWord(commandWord)) {
            return new EditCommandParser().parse(args);
        }
        if (isHelpCommandWord(commandWord)) {
            return new HelpCommand();
        }
        if (isExitCommandWord(commandWord)) {
            return new ExitCommand();
        }
        if (isListCommandWord(commandWord)) {
            return new ListCommandParser().parse(args);
        }
        if (isFindCommandWord(commandWord)) {
            return new FindCommandParser().parse(args);
        }
        if (isDeleteCommandWord(commandWord)) {
            return new DeleteCommandParser().parse(args);
        }
        if (isClearCommandWord(commandWord)) {
            return new ClearCommand();
        }
        if (isSaveCommand(commandWord)) {
            return new SaveCommandParser().parse(args);
        }
        if (isSelectCommand(commandWord)) {
            return new SelectCommandParser().parse(args);
        }
        if (isUndoCommand(commandWord)) {
            return new UndoCommandParser().parse(args);
        }
        if (isRedoCommand(commandWord)) {
            return new RedoCommandParser().parse(args);
        }
        if (isExportCommand(commandWord)) {
            return new ExportCommandParser().parse(args);
        }
        if (isImportCommand(commandWord)) {
            return new ImportCommandParser().parse(args);
        }
        return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
    }

    private boolean isImportCommand(String commandWord) {
        return commandWord.equals(ImportCommand.COMMAND_WORD_IMPORT) ||
                commandWord.equals(ImportCommand.COMMAND_WORD_LOAD) ||
                commandWord.equals(ImportCommand.COMMAND_WORD_OPEN);
    }

    private boolean isExportCommand(String commandWord) {
        return commandWord.equals(ExportCommand.COMMAND_WORD_EXPORT);
    }

    private boolean isRedoCommand(String commandWord) {
        return commandWord.equals(RedoCommand.COMMAND_WORD_REDO);
    }

    private boolean isUndoCommand(String commandWord) {
        return commandWord.equals(UndoCommand.COMMAND_WORD_UNDO);
    }

    private boolean isSelectCommand(String commandWord) {
        return commandWord.equals(SelectCommand.COMMAND_WORD_SELECT);
    }

    private boolean isSaveCommand(String commandWord) {
        return commandWord.equals(SaveCommand.COMMAND_WORD_SAVE);
    }

    private boolean isClearCommandWord(String commandWord) {
        return commandWord.equals(ClearCommand.COMMAND_WORD_CLEAR) ||
                commandWord.equals(ClearCommand.COMMAND_WORD_EMPTY);
    }

    private boolean isDeleteCommandWord(String commandWord) {
        return commandWord.equals(DeleteCommand.COMMAND_WORD_DELETE) ||
                commandWord.equals(DeleteCommand.COMMAND_WORD_DEL) ||
                commandWord.equals(DeleteCommand.COMMAND_WORD_REMOVE) ||
                commandWord.equals(DeleteCommand.COMMAND_WORD_RM);
    }

    private boolean isFindCommandWord(String commandWord) {
        return commandWord.equals(FindCommand.COMMAND_WORD_FIND) ||
                commandWord.equals(FindCommand.COMMAND_WORD_SEARCH) ||
                commandWord.equals(FindCommand.COMMAND_WORD_QUERY);
    }

    private boolean isListCommandWord(String commandWord) {
        return commandWord.equals(ListCommand.COMMAND_WORD_LIST) ||
                commandWord.equals(ListCommand.COMMAND_WORD_FILTER) ||
                commandWord.equals(ListCommand.COMMAND_WORD_SHOW) ||
                commandWord.equals(ListCommand.COMMAND_WORD_LS) ||
                commandWord.equals(ListCommand.COMMAND_WORD_DISPLAY);
    }

    private boolean isExitCommandWord(String commandWord) {
        return commandWord.equals(ExitCommand.COMMAND_WORD_EXIT) ||
                commandWord.equals(ExitCommand.COMMAND_WORD_QUIT) ||
                commandWord.equals(ExitCommand.COMMAND_WORD_LOGOUT) ||
                commandWord.equals(ExitCommand.COMMAND_WORD_BYE);
    }

    private boolean isHelpCommandWord(String commandWord) {
        return commandWord.equals(HelpCommand.COMMAND_WORD_HELP) ||
                commandWord.equals(HelpCommand.COMMAND_WORD_MAN) ||
                commandWord.equals(HelpCommand.COMMAND_WORD_SOS);
    }

    private boolean isEditCommandWord(String commandWord) {
        return commandWord.equals(EditCommand.COMMAND_WORD_EDIT) ||
                commandWord.equals(EditCommand.COMMAND_WORD_UPDATE) ||
                commandWord.equals(EditCommand.COMMAND_WORD_CHANGE);
    }

    private boolean isCompleteCommandWord(String commandWord) {
        return commandWord.equals(CompleteCommand.COMMAND_WORD_COMPLETE) ||
                commandWord.equals(CompleteCommand.COMMAND_WORD_FINISH) ||
                commandWord.equals(CompleteCommand.COMMAND_WORD_DONE) ||
                commandWord.equals(CompleteCommand.COMMAND_WORD_CHECK) ||
                commandWord.equals(CompleteCommand.COMMAND_WORD_MARK) ||
                commandWord.equals(CompleteCommand.COMMAND_WORD_END);
    }

    private boolean isAddCommandWord(String commandWord) {
        return commandWord.equals(AddCommand.COMMAND_WORD_ADD) ||
                commandWord.equals(AddCommand.COMMAND_WORD_CREATE) ||
                commandWord.equals(AddCommand.COMMAND_WORD_DO) ||
                commandWord.equals(AddCommand.COMMAND_WORD_NEW);
    }

    private String getEmptyUserInputMessage() {
        return MESSAGE_EMPTY_COMMAND;
    }

    private String getInvalidUserInputMessage() {
        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE);
    }

    private boolean isEmptyUserInput(String input) {
        assert input != null;
        return input.isEmpty();
    }

    private boolean isValidUserInput(Matcher matcher) {
        assert matcher != null;
        return matcher.matches();
    }

}
```
###### \java\seedu\typed\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> date} into an {@code Optional<Date>} if
     * {@code date} is present.
     */
    public static Optional<DateTime> parseDate(Optional<String> date) throws IllegalValueException {
        assert date != null;
        return date.isPresent() ? Optional.of(DateTimeParser.getDateTimeFromString(date.get()))
                : Optional.empty();
    }
```
###### \java\seedu\typed\model\Model.java
``` java
    void updateFilteredListToShowDeadline();

    void updateFilteredListToShowDuration();

    void updateFilteredListToShowDone();

    void updateFilteredListToShowUndone();

    void updateFilteredListToShowUntimed();
```
###### \java\seedu\typed\model\Model.java
``` java
    void updateFilteredTaskList(Set<String> keywords, Set<String> tagKeywords);
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Set<String> keywords, Set<String> tagKeywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)),
                new PredicateExpression(new TagQualifier(tagKeywords)));
    }

    private void updateFilteredTaskList(Expression expression, Expression tagExpression) {
        filteredTasks.setPredicate(p -> (expression.satisfies(p) || tagExpression.satisfies(p)));
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java

    @Override
    public void updateFilteredListToShowDeadline() {
        // todo
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredListToShowDuration() {
        // todo
        this.taskManager.printData();
    }

    @Override
    public void updateFilteredListToShowDone() {
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifer()));
    }

    @Override
    public void updateFilteredListToShowUndone() {
        updateFilteredTaskList(new Negation(new CompletedQualifer()));
    }

    @Override
    public void updateFilteredListToShowUntimed() {
        //todo
        //filteredTasks.setPredicate(null);
        //System.out.println("mmm");
        //FXCollections.sort(filteredTasks, DateTimeComparator);
        this.taskManager.sort();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    private class TagQualifier implements Qualifier {
        private Set<String> tagKeyWords;

        TagQualifier(Set<String> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagKeyWords.stream().filter(keyword -> StringUtil
                    .isFuzzyKeywordSearchIgnoreCase(task.getTags(), keyword)).findAny().isPresent();
        }

        @Override
        public String toString() {
            return "tag=" + String.join(", ", tagKeyWords);
        }
    }
```
###### \java\seedu\typed\model\tag\Tag.java
``` java
    /**
     * Returns the text representation of the tag
     */
    public String getValue() {
        return tagName;
    }
```
###### \java\seedu\typed\model\task\DateTime.java
``` java
    private static final String SINGLE_SPACE_DELIMITER = " ";
    private static final String DISPLAY_DATE_TIME_FORMAT = "EEEE, MMM dd, yyyy HH:mm";
```
###### \java\seedu\typed\model\task\DateTime.java
``` java
    @Override
    public String toString() {
        if (localDateTime ==  null) {
            return SINGLE_SPACE_DELIMITER;
        }
        return localDateTime.format(DateTimeFormatter.ofPattern(DISPLAY_DATE_TIME_FORMAT));
    }

    public boolean isAfterNow() {
        return localDateTime.isAfter(LocalDateTime.now());
    }
```
###### \java\seedu\typed\model\task\Name.java
``` java
    /**
     * Validates a given task name.
     * @param {@code name} non-null String
     * @throws IllegalValueException if {@code name} is invalid
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        String trimmed = name.trim();
        if (!isValidName(trimmed)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        value = name;
    }

    /**
    * Checks if {@code test} is a valid task name that does not contain `#` or `+`.
    * @param {@code test} non-null String
    * @return true if {@code test} is a valid task name
    */
    public static boolean isValidName(String test) {
        assert test != null;
        return test.matches(NAME_VALIDATION_REGEX);
    }
```
###### \java\seedu\typed\model\task\Notes.java
``` java

package seedu.typed.model.task;

import seedu.typed.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's notes in the task manager.
 * Guarantees: immutable;
 */

public class Notes {

    private static final String EMPTY_STRING = "";
    private static final String MESSAGE_NOTES_CONSTRAINTS = "Task notes should not contain `#` or `+`";
    private static final String NOTES_VALIDATION_REGEX = "[\\p{Punct}&&[^\\+\\#]]*[\\p{Alnum}]+[\\p{Graph} "
            + "&&[^\\+\\#]]*";

    private String value;

    /**
     * Sets default value of a task's notes to be empty.
     */
    public Notes() {
        value = EMPTY_STRING;
    }

    /**
     * Validates a given task notes.
     * @param {@code notes} possibly null or empty String
     * @throws IllegalValueException if {@code notes} is invalid
     */
    public Notes(String notes) throws IllegalValueException {
        value = EMPTY_STRING;
        if (notes == null || isInvalidNotes(notes.trim())) {
            throw new IllegalValueException(MESSAGE_NOTES_CONSTRAINTS);
        }
        value = notes.trim();
    }

    /**
    * Checks if {@code test} is a valid task notes that does not contain `#` or `+`.
    * @param {@code test} non-null String
    * @return true if {@code test} is a valid task notes
    */
    public static boolean isInvalidNotes(String test) {
        assert test != null;
        return !test.isEmpty() && !test.matches(NOTES_VALIDATION_REGEX);
    }

    public String getValue() {
        return value;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Notes // instanceof handles nulls
                        && this.value.equals(((Notes) other).getValue())); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\typed\model\task\ReadOnlyTask.java
``` java
    default boolean isScheduleElementSame(ScheduleElement otherSE) {
        return this.getSE().toString().equals(otherSE.toString());
    }
```
###### \java\seedu\typed\model\task\Task.java
``` java
    public void setNotes(Notes notes) {
        this.notes = notes;
    }

    @Override
    public Notes getNotes() {
        return notes;
    }
```
###### \java\seedu\typed\model\task\Task.java
``` java
    @Override
    public boolean isOverdue() {
        return se.isOverdue();
    }

    @Override
    public boolean isEvent() {
        return se.isEvent();
    }

    @Override
    public boolean isDeadline() {
        return se.isDeadline();
    }
    @Override
    public boolean isFloating() {
        return se.isFloating();
    }
```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
    public TaskBuilder setNotes(String notes) throws IllegalValueException {
        this.notes = new Notes(notes);
        return this;
    }

    public TaskBuilder setNotes(Notes notes) {
        this.notes = notes;
        return this;
    }
```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
    public TaskBuilder setFloating() {
        this.se = ScheduleElement.makeFloating();
        return this;
    }
```
###### \java\seedu\typed\model\util\SampleDataUtil.java
``` java
    public static Task[] getSampleTasks() {
        try {
            int taskNumber = 6;
            Task[] tasks = new Task[6];
            String[] names = new String[] {"Meet Alex Yeoh", "Meet Bernice Yu", "Meet Charlotte Oliveiro",
                "Meet David Li", "Meet Irfan Ibrahim", "Meet Roy Balakrishnan"};
            DateTime[] dates = new DateTime[] {
                DateTime.getDateTime(2017, Month.JANUARY, 20, 0, 0),
                DateTime.getDateTime(2017, Month.JANUARY, 20, 0, 0),
                DateTime.getDateTime(2017, Month.JANUARY, 20, 0, 0),
                DateTime.getDateTime(2017, Month.JANUARY, 20, 0, 0),
                DateTime.getDateTime(2017, Month.JANUARY, 20, 0, 0),
                DateTime.getDateTime(2017, Month.JANUARY, 20, 0, 0)};
            String[] notes = new String[] {"", "", "", "", "", ""};
            String[] tags = new String[] {"friends", "colleagues", "neighbours", "family",
                "classmates", "colleagues"};
            for (int i = 0; i < taskNumber; i++) {
                tasks[i] = new TaskBuilder()
                        .setName(names[i])
                        .setNotes(notes[i])
                        .setDeadline(dates[i])
                        .addTags(tags[i])
                        .build();
            }
            return tasks;
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }
```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
    /**
     * This is to support the conversion from XML file to ScheduleElement objects
     * Returns a ScheduleElement built according to the {@code dateInput}.
     */
    public ScheduleElement parseDateString(String dateInput, String rule) throws IllegalValueException {
        if (dateInput == null || dateInput.isEmpty()) {
            return makeFloating();
        }
        if (dateInput.contains(BY_DISPLAY_IDENTIFIER)) {
            String[] dateTime = dateInput.trim().split(BY_DISPLAY_IDENTIFIER);
            return makeDeadline(DateTimeParser.getDateTimeFromString(dateTime[1]), rule);
        }
        if (dateInput.contains(FROM_DISPLAY_IDENTIFIER) && dateInput.contains(TO_DISPLAY_IDENTIFIER)) {
            String[] dateTime = dateInput.trim().split(TO_DISPLAY_IDENTIFIER);
            dateTime[0] = dateTime[0].replaceAll(FROM_DISPLAY_IDENTIFIER, "");
            return makeEvent(DateTimeParser.getDateTimeFromString(dateTime[0]),
                    DateTimeParser.getDateTimeFromString(dateTime[1]), rule);
        }
        return makeFloating();
    }
```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
    @Override
    public String toString() {
        StringBuilder display = new StringBuilder();
        if (isEvent()) {
            display.append(" From: " + this.startDate + " To: " + this.endDate);
        } else if (isDeadline()) {
            display.append(" By: " + this.date);
        }
        if (isRecurring()) {
            display.append(" Every: " + this.rule);
        }
        return display.toString();
    }

    public String teToString() {
        return "";
    }
```
###### \java\seedu\typed\storage\XmlAdaptedTask.java
``` java
    @XmlElement(required = true)
    private String notes;
```
