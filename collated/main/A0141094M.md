# A0141094M
###### \java\seedu\typed\commons\lexicon\CommandUtil.java
``` java
package seedu.typed.commons.lexicon;

import java.util.ArrayList;

/**
 * Utility class to maintain the list of commands.
 *
 */
public class CommandUtil {

    static String COMMAND_ADD = "add";
    static String COMMAND_DELETE = "delete";
    static String COMMAND_EDIT = "edit";
    static String COMMAND_EXIT = "exit";
    static String COMMAND_FIND = "find";
    static String COMMAND_FINISH = "finish";
    static String COMMAND_HELP = "help";
    static String COMMAND_HISTORY = "history";
    static String COMMAND_LIST = "list";
    static String COMMAND_LOAD = "load";
    static String COMMAND_REDO = "redo";
    static String COMMAND_SAVE = "save";
    static String COMMAND_UNDO = "undo";


    public static ArrayList<String> getAllCommandWords() {
        ArrayList<String> commandWords = new ArrayList<String>();
        commandWords.add(COMMAND_ADD);
        commandWords.add(COMMAND_EDIT);
        commandWords.add(COMMAND_DELETE);
        commandWords.add(COMMAND_FINISH);
        commandWords.add(COMMAND_UNDO);
        commandWords.add(COMMAND_REDO);
        commandWords.add(COMMAND_HISTORY);
        commandWords.add(COMMAND_HELP);
        commandWords.add(COMMAND_LOAD);
        commandWords.add(COMMAND_SAVE);
        commandWords.add(COMMAND_EXIT);
        commandWords.add(COMMAND_FIND);
        commandWords.add(COMMAND_LIST);
        return commandWords;
    }

    public static boolean isCommandWord(String word) {
        return getAllCommandWords().contains(word);
    }

}
```
###### \java\seedu\typed\commons\lexicon\DateIdentifiersUtil.java
``` java
package seedu.typed.commons.lexicon;

import java.util.ArrayList;

/**
 * Utility class to maintain the list of date identifiers.
 *
 */
public class DateIdentifiersUtil {

    static String DATE_IDENTIFIER_BY = "by";
    static String DATE_IDENTIFIER_ON = "on";
    static String DATE_IDENTIFIER_FROM = "from";
    static String DATE_IDENTIFIER_TO = "to";
    static String DATE_IDENTIFIER_EVERY = "every";


    public static ArrayList<String> getAllDateIdentifiers() {
        ArrayList<String> dateIdentifiers = new ArrayList<String>();
        dateIdentifiers.add(DATE_IDENTIFIER_BY);
        dateIdentifiers.add(DATE_IDENTIFIER_ON);
        dateIdentifiers.add(DATE_IDENTIFIER_FROM);
        dateIdentifiers.add(DATE_IDENTIFIER_TO);
        dateIdentifiers.add(DATE_IDENTIFIER_EVERY);
        return dateIdentifiers;
    }

    public static boolean isDateIdentifier(String word) {
        return getAllDateIdentifiers().contains(word);
    }

}
```
###### \java\seedu\typed\commons\util\StringUtil.java
``` java
    /**
     * Returns true if the {@code sentence} contains the {@code query} or a similar {@code query}.
     * Ignores case, and both full word match or similar word match are allowed. <br>
     * examples:
     *
     * <pre>
     *       containsFuzzyWordIgnoreCase("ABc def", "abc") == true // a full word match
     *       containsFuzzyWordIgnoreCase("ABc def", "DEF") == true // a full word match
     *       containsFuzzyWordIgnoreCase("ABc def", "dfg") == true // a similar match
     *       containsFuzzyWordIgnoreCase("ABc def", "zzz") == false //not a full word match and not a similar match
     * </pre>
     *
     * @param sentence
     *            cannot be null
     * @param query
     *            cannot be null, cannot be empty, must be a single word
     */
    public static boolean isFuzzyKeywordSearchIgnoreCase(String sentence, String query) {
        assert query != null : "Query parameter cannot be null";
        assert sentence != null : "Sentence parameter cannot be null";

        String trimmedQuery = query.trim();
        assert !trimmedQuery.isEmpty() : "Query parameter cannot be empty";
        assert trimmedQuery.split(WHITESPACE_DELIMITER).length == 1 : "Query parameter should be a single word";

        String[] wordsInSentence = sentence.split(WHITESPACE_DELIMITER);

        for (String word : wordsInSentence) {
            if (FindUtil.isFuzzyWordMatchIgnoreCase(word, trimmedQuery)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if the {@code tags} contain the {@code query} or a similar {@code query}.
     * Ignores case, and both exact tag match or similar tag match are allowed.
     * @param tags
     *          cannot be null
     * @param query
     *          cannot be null, cannot be empty, must be a single word
     * @return
     */
    public static boolean isFuzzyKeywordSearchIgnoreCase(UniqueTagList tags, String query) {
        assert tags != null : "Tags parameter cannot be null";
        assert query != null : "Query parameter cannot be null";
        String trimmedQuery = query.trim();
        assert !trimmedQuery.isEmpty() : "Query parameter cannot be empty";
        assert trimmedQuery.split(WHITESPACE_DELIMITER).length == 1 : "Query parameter should be a single word";
        for (Tag tag : tags) {
            String tagWord = tag.getValue();
            if (FindUtil.isFuzzyTagMatchIgnoreCase(query, tagWord)) {
                return true;
            }
        }
        return false;
    }
```
###### \java\seedu\typed\logic\commands\AddCommand.java
``` java
    public static final String ADD_COMMAND_WORD = "add";
    public static final String CREATE_COMMAND_WORD = "create";
    public static final String DO_COMMAND_WORD = "do";
    public static final String NEW_COMMAND_WORD = "new";
```
###### \java\seedu\typed\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String notes, LocalDateTime date, LocalDateTime from,
            LocalDateTime to, Set<String> tags, String every) throws IllegalValueException {
        ScheduleElement se;
        if (date == null && from != null && to != null) {
            se = new ScheduleElement(new DateTime(from), new DateTime(to), every);
        } else if (date != null && from == null && to == null) {
            se = new ScheduleElement(new DateTime(date), every);
        } else if (every != null) {
            se = new ScheduleElement(every);
        } else {
            se = new ScheduleElement();
        }
        this.toAdd = new TaskBuilder()
                .setName(name)
                .setNotes(notes)
                .setSE(se)
                .setTags(tags)
                .build();
    }


    public AddCommand(String name, String notes, LocalDateTime date, LocalDateTime from,
            LocalDateTime to, Set<String> tags) throws IllegalValueException {
        ScheduleElement se;
        if (date == null && from != null && to != null) {
            se = new ScheduleElement(new DateTime(from), new DateTime(to));
        } else if (date != null && from == null && to == null) {
            System.out.println(date.getMinute() + " " + date.getHour());
            se = new ScheduleElement(new DateTime(date));
        } else {
            se = new ScheduleElement();
        }
        this.toAdd = new TaskBuilder()
                .setName(name)
                .setNotes(notes)
                .setSE(se)
                .setTags(tags)
                .build();
    }
```
###### \java\seedu\typed\logic\commands\ClearCommand.java
``` java
    public static final String CLEAR_COMMAND_WORD = "clear";
    public static final String EMPTY_COMMAND_WORD = "empty";
```
###### \java\seedu\typed\logic\commands\CompleteCommand.java
``` java
    public static final String FINISH_COMMAND_WORD = "finish";
    public static final String MARK_COMMAND_WORD = "mark";
    public static final String DONE_COMMAND_WORD = "done";
    public static final String CHECK_COMMAND_WORD = "check";
    public static final String COMPLETE_COMMAND_WORD = "complete";
    public static final String END_COMMAND_WORD = "end";
```
###### \java\seedu\typed\logic\commands\DeleteCommand.java
``` java
    public static final String DELETE_COMMAND_WORD = "delete";
    public static final String DEL_COMMAND_WORD = "del";
    public static final String REMOVE_COMMAND_WORD = "remove";
    public static final String RM_COMMAND_WORD = "rm";
```
###### \java\seedu\typed\logic\commands\EditCommand.java
``` java
    public static final String EDIT_COMMAND_WORD = "edit";
    public static final String UDPATE_COMMAND_WORD = "update";
    public static final String CHANGE_COMMAND_WORD = "change";
```
###### \java\seedu\typed\logic\commands\EditCommand.java
``` java
    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     * @throws IllegalValueException
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor)
            throws IllegalValueException {
        assert taskToEdit != null;
        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Notes updatedNotes = editTaskDescriptor.getNotes().orElseGet(taskToEdit::getNotes);
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);
        ScheduleElement updatedSe;

        if (hasOnlyDeadlineField(editTaskDescriptor)) {
            updatedSe = new ScheduleElement(editTaskDescriptor.getDate().get(),
                    taskToEdit.getSE().getStartDate(), taskToEdit.getSE().getEndDate());
        } else if (hasOnlyFromAndToFields(editTaskDescriptor)) {
            updatedSe = new ScheduleElement(taskToEdit.getSE().getDate(),
                    editTaskDescriptor.getFrom().get(), editTaskDescriptor.getTo().get());
        } else if (hasNoDeadlineAndNoFromToFields(editTaskDescriptor)) {
            updatedSe = taskToEdit.getSE();
        } else {
            throw new IllegalValueException(MESSAGE_EDIT_DATE_FAILURE);
        }
        return new TaskBuilder()
                .setName(updatedName)
                .setNotes(updatedNotes)
                .setSE(updatedSe)
                .setTags(updatedTags)
                .build();
    }

    private static boolean hasOnlyFromAndToFields(EditTaskDescriptor edt) {
        return !edt.getDate().isPresent()
                && edt.getFrom().isPresent() && edt.getTo().isPresent();
    }

    private static boolean hasOnlyDeadlineField(EditTaskDescriptor edt) {
        return edt.getDate().isPresent()
                && !edt.getFrom().isPresent() && !edt.getTo().isPresent();
    }

    private static boolean hasNoDeadlineAndNoFromToFields(EditTaskDescriptor edt) {
        return !edt.getDate().isPresent()
                && !edt.getFrom().isPresent() && !edt.getTo().isPresent();
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<DateTime> date = Optional.empty();
        private Optional<DateTime> from = Optional.empty();
        private Optional<DateTime> to = Optional.empty();
        private Optional<Notes> notes = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {
        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.date = toCopy.getDate();
            this.from = toCopy.getFrom();
            this.to = toCopy.getTo();
            this.notes = toCopy.getNotes();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.date, this.from, this.to, this.notes, this.tags);
        }

        public void setName(Optional<Name> name) {
            assert name != null;

            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setDate(Optional<DateTime> date) {
            assert date != null;

            this.date = date;
        }

        public Optional<DateTime> getDate() {
            return date;
        }

        public void setFrom(Optional<DateTime> from) {
            assert from != null;
            this.from = from;
        }

        public Optional<DateTime> getFrom() {
            return from;
        }

        public void setTo(Optional<DateTime> to) {
            assert to != null;
            this.to = to;
        }

        public Optional<DateTime> getTo() {
            return to;
        }

        public ScheduleElement getSE() {
            DateTime deadline = date.orElse(null);
            DateTime startDateTime = from.orElse(null);
            DateTime endDateTime = to.orElse(null);
            return new ScheduleElement(deadline, startDateTime, endDateTime);
        }

        public void setNotes(Optional<Notes> notes) {
            assert notes != null;
            this.notes = notes;
        }

        public Optional<Notes> getNotes() {
            return notes;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }
```
###### \java\seedu\typed\logic\commands\ExitCommand.java
``` java
    public static final String EXIT_COMMAND_WORD = "exit";
    public static final String QUIT_COMMAND_WORD = "quit";
    public static final String LOGOUT_COMMAND_WORD = "logout";
```
###### \java\seedu\typed\logic\commands\FindCommand.java
``` java

package seedu.typed.logic.commands;

import java.util.Set;

import seedu.typed.logic.commands.util.CommandTypeUtil;

/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String FIND_COMMAND_WORD = "find";
    public static final String SEARCH_COMMAND_WORD = "search";
    public static final String QUERY_COMMAND_WORD = "query";

    public static final String MESSAGE_USAGE = FIND_COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords or tags (not case-sensitive).\n"
            + "Example: " + FIND_COMMAND_WORD + " broccoli #green #healthy";

    private final Set<String> keywords;
    private final Set<String> tagKeywords;

    public FindCommand(Set<String> keywords, Set<String> tagKeywords) {
        assert keywords != null;
        assert tagKeywords != null;
        this.keywords = keywords;
        this.tagKeywords = tagKeywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords, tagKeywords);
        session.updateUndoRedoStacks(CommandTypeUtil.TYPE_FIND_TASK, -1, null);
        session.updateValidCommandsHistory(commandText);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\typed\logic\commands\HelpCommand.java
``` java
    public static final String HELP_COMMAND_WORD = "help";
    public static final String MAN_COMMAND_WORD = "man";
```
###### \java\seedu\typed\logic\commands\HistoryCommand.java
``` java
    public static final String HISTORY_COMMAND_WORD = "history";
    public static final String HIST_COMMAND_WORD = "hist";
    public static final String LOG_COMMAND_WORD = "log";
```
###### \java\seedu\typed\logic\commands\ListCommand.java
``` java
package seedu.typed.logic.commands;

import seedu.typed.commons.exceptions.IllegalValueException;
import seedu.typed.logic.commands.util.CommandTypeUtil;

/**
 * Lists all tasks in the task manager to the user.
 */
public class ListCommand extends Command {

    public static final String LIST_COMMAND_WORD = "list";
    public static final String FILTER_COMMAND_WORD = "filter";
    public static final String SHOW_COMMAND_WORD = "show";
    public static final String LS_COMMAND_WORD = "ls";

    public static final String MESSAGE_USAGE = LIST_COMMAND_WORD + ": Lists all undone and upcoming tasks by default, "
            + "or by the CATEGORY if specified. Valid CATEGORYs are: untimed, deadline, duration, done, undone and all."
            + "Parameters: [CATEGORY] \n"
            + "Example: " + LIST_COMMAND_WORD
            + " deadline ";

    public static final String MESSAGE_SUCCESS = "Listed all tasks";

    private final String type;

    public ListCommand(String type) throws IllegalValueException {
        this.type = type;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(type);
        session.updateUndoRedoStacks(CommandTypeUtil.TYPE_LIST_TASK, -1, null);
        session.updateValidCommandsHistory(commandText);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\typed\logic\commands\util\Day.java
``` java

/**
 *
 */
package seedu.typed.logic.commands.util;

/**
 * @author Peixuan
 *
 */
public enum Day {
    MON(1),
    TUE(2),
    WED(3),
    THU(4),
    FRI(5),
    SAT(6),
    SUN(7);

    private int day;

    Day(int day) {
        this.day = day;
    }
    public int day() {
        return this.day;
    }
}
```
###### \java\seedu\typed\logic\commands\util\Frequency.java
``` java

/**
 *
 */
package seedu.typed.logic.commands.util;

/**
 * @author Peixuan
 *
 */
public enum Frequency {
    DAY("done"),
    WEEK("all"),
    MONTH("tasks"),
    YEAR("events");

    private String frequency;

    Frequency(String frequency) {
        this.frequency = frequency;
    }

    public String frequency() {
        return this.frequency;
    }
}
```
###### \java\seedu\typed\logic\commands\util\Type.java
``` java

/**
 *
 */
package seedu.typed.logic.commands.util;

/**
 * @author Peixuan
 *
 */
public enum Type {
    ALL("all"),
    DEADLINE("deadline"),
    DURATION("duration"),
    DONE("done"),
    UNDONE("undone"),
    UNTIMED("untimed");

    private String type;

    Type(String type) {
        this.type = type;
    }

    public String getType() {
        return this.type;
    }
}
```
###### \java\seedu\typed\logic\parser\AddCommandParser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_DATE;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_EVERY;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_FROM;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_NOTES;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_ON;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_TAG;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_TO;

import java.time.LocalDateTime;
import java.util.NoSuchElementException;
import java.util.Set;

import seedu.typed.commons.exceptions.IllegalValueException;
import seedu.typed.logic.commands.AddCommand;
import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        try {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_NOTES, PREFIX_DATE, PREFIX_ON,
                    PREFIX_FROM, PREFIX_TO, PREFIX_EVERY, PREFIX_TAG);
            argsTokenizer.tokenize(args);

            String name = argsTokenizer.getPreamble().get();
            String notes = getNotes(argsTokenizer);
            String deadline = getDeadline(argsTokenizer);
            String startString = getFrom(argsTokenizer);
            String endString = getTo(argsTokenizer);
            String every = getEvery(argsTokenizer);
            System.out.println(every); // tuesday, stuff
            Set<String> tags = ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG));
            LocalDateTime deadlineDateTime = DateTimeParser.getLocalDateTimeFromString(deadline);
            LocalDateTime startDateTime = DateTimeParser.getLocalDateTimeFromString(startString);
            LocalDateTime endDateTime = DateTimeParser.getLocalDateTimeFromString(endString);

            if (deadline != null && DateTimeParser.isTimeInferred(deadline)) {
                deadlineDateTime = deadlineDateTime.withHour(23).withMinute(59).withSecond(59).withNano(59);
            }
            // if i add a event starting from today and it's alr past 00:00, what will i do?
            if (startString != null && DateTimeParser.isTimeInferred(startString)) {
                startDateTime = startDateTime.withHour(0).withMinute(0).withSecond(0).withNano(0);
            }
            if (endString != null && DateTimeParser.isTimeInferred(endString)) {
                endDateTime = endDateTime.withHour(23).withMinute(59).withSecond(59).withNano(59);
            }


            if (hasBothByAndOnFields(argsTokenizer) || isBothDeadlineTaskAndEventTask(argsTokenizer)) {
                return new IncorrectCommand(getIncorrectAddMessage());
            }
            if (every == null) {
                return new AddCommand(name, notes, deadlineDateTime, startDateTime, endDateTime, tags);
            }
            return new AddCommand(name, notes, deadlineDateTime, startDateTime, endDateTime, tags, every);
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(getIncorrectAddMessage());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    private String getEvery(ArgumentTokenizer argsTokenizer) {
        if (isEveryPresent(argsTokenizer)) {
            return argsTokenizer.getValue(PREFIX_EVERY).get();
        } else {
            return null;
        }
    }

    private String getDeadline(ArgumentTokenizer argsTokenizer) {
        if (isByPresent(argsTokenizer)) {
            return argsTokenizer.getValue(PREFIX_DATE).get();
        } else if (isOnPresent(argsTokenizer)) {
            return argsTokenizer.getValue(PREFIX_ON).get();
        } else {
            return null;
        }
    }

    private String getFrom(ArgumentTokenizer argsTokenizer) {
        if (isFromPresent(argsTokenizer)) {
            return argsTokenizer.getValue(PREFIX_FROM).get();
        } else {
            return null;
        }
    }

    private String getTo(ArgumentTokenizer argsTokenizer) {
        if (isToPresent(argsTokenizer)) {
            return argsTokenizer.getValue(PREFIX_TO).get();
        } else {
            return null;
        }
    }

    private String getNotes(ArgumentTokenizer argsTokenizer) {
        if (isNotesPresent(argsTokenizer)) {
            return argsTokenizer.getValue(PREFIX_NOTES).get();
        } else {
            return "";
        }
    }

    private String getIncorrectAddMessage() {
        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
    }

    private boolean isByPresent(ArgumentTokenizer argsTokenizer) {
        return argsTokenizer.getValue(PREFIX_DATE).isPresent();
    }

    private boolean isEveryPresent(ArgumentTokenizer argsTokenizer) {
        return argsTokenizer.getValue(PREFIX_EVERY).isPresent();
    }

    private boolean isOnPresent(ArgumentTokenizer argsTokenizer) {
        return argsTokenizer.getValue(PREFIX_ON).isPresent();
    }

    private boolean isFromPresent(ArgumentTokenizer argsTokenizer) {
        return argsTokenizer.getValue(PREFIX_FROM).isPresent();
    }

    private boolean isToPresent(ArgumentTokenizer argsTokenizer) {
        return argsTokenizer.getValue(PREFIX_TO).isPresent();
    }

    private boolean isNotesPresent(ArgumentTokenizer argsTokenizer) {
        return argsTokenizer.getValue(PREFIX_NOTES).isPresent();
    }

    private boolean isDeadlineTask(ArgumentTokenizer argsTokenizer) {
        return isByPresent(argsTokenizer) || isOnPresent(argsTokenizer);
    }

    private boolean hasBothByAndOnFields(ArgumentTokenizer argsTokenizer) {
        return isByPresent(argsTokenizer) && isOnPresent(argsTokenizer);
    }

    private boolean isBothDeadlineTaskAndEventTask(ArgumentTokenizer argsTokenizer) {
        return isDeadlineTask(argsTokenizer) && isEventTask(argsTokenizer);
    }

    private boolean isEventTask(ArgumentTokenizer argsTokenizer) {
        return argsTokenizer.getValue(PREFIX_FROM).isPresent() && argsTokenizer.getValue(PREFIX_TO).isPresent();
    }

}
```
###### \java\seedu\typed\logic\parser\ArgumentValidator.java
``` java

package seedu.typed.logic.parser;

import java.util.Optional;

import seedu.typed.commons.exceptions.IllegalValueException;

/**
 * @author Peixuan
 *
 */

public abstract class ArgumentValidator {
    protected String validationRegex;
    protected String messageConstraints;

    protected Optional<String> arg;
    protected String validArg;

    /**
     * Validates the given argument
     * @param arg
     * @throws IllegalValueException if given argument is not of a valid format
     */
    public void validate(Optional<String> arg) throws IllegalValueException {
        if (arg.isPresent()) {
            isValidArg(arg.get().trim());
        }
    }

    /**
     * Returns true if a given argument is in a valid format.
     */
    public void isValidArg(String arg) throws IllegalValueException {
        if (!arg.matches(validationRegex)) {
            throw new IllegalValueException(messageConstraints);
        }
        this.validArg = arg;
    }

    public String getValidArg() {
        return this.validArg;
    }

}

```
###### \java\seedu\typed\logic\parser\CliSyntax.java
``` java
    public static final Prefix PREFIX_NOTES = new Prefix(" + ");
    public static final Prefix PREFIX_DATE = new Prefix(" by ");
    public static final Prefix PREFIX_ON = new Prefix(" on ");
    public static final Prefix PREFIX_FROM = new Prefix(" from ");
    public static final Prefix PREFIX_TO = new Prefix(" to ");
    public static final Prefix PREFIX_EVERY = new Prefix(" every ");
    public static final Prefix PREFIX_TAG = new Prefix(" #");

    public static final Prefix PREFIX_WITH = new Prefix(" with ");
```
###### \java\seedu\typed\logic\parser\DateTimeParser.java
``` java

package seedu.typed.logic.parser;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.typed.commons.exceptions.IllegalValueException;
import seedu.typed.model.task.DateTime;

/**
 * Parses date from a non-null string to LocalDateTime.
 * Currently assumes date contains only one date, not multiple.
 */
public class DateTimeParser {
    private static final String MESSAGE_FOR_INVALID_DATE_FORMAT = "The date you entered is invalid or ambiguous. ";
    private static final String VALID_TIME_REGEX = "[0-2][0-3][0-5][0-9]";


    private static Parser natty = new Parser();

    /**
     * Returns a date in its Date equivalent.
     */
    public static Date getDateFromString(String date) throws IllegalValueException {
        assert date != null;
        DateGroup dateGroup = getDateGroupFromString(date);
        return dateGroup.getDates().get(0);
    }

    /**
     * Returns a date in its DateTime equivalent.
     * @param ldt LocalDateTime
     * @return a DateTime instance of the LocalDateTime parsed
     */
    public static DateTime getDateTimeFromLocalDateTime(LocalDateTime ldt) {
        return new DateTime(ldt);
    }

    /**
     * Returns a date in its DateTime equivalent.
     * @param ldt LocalDateTime
     * @return a DateTime instance of the LocalDateTime parsed
     * @throws IllegalValueException
     */
    public static DateTime getDateTimeFromString(String date) throws IllegalValueException {
        return getDateTimeFromLocalDateTime(getLocalDateTimeFromString(date));
    }

    /**
     * Returns a date in its LocalDateTime equivalent.
     * @param date non-null String containing a date
     * @return a LocalDateTime instance of the parsed date
     * @throws IllegalValueException if date is in an invalid or ambiguous format
     */
    public static LocalDateTime getLocalDateTimeFromString(String date) throws IllegalValueException {
        if (date == null) {
            return null;
        }
        DateGroup dateGroup = getDateGroupFromString(date);
        //System.out.println(dateGroup.isTimeInferred());
        Instant instant = dateGroup.getDates().get(0).toInstant();
        return LocalDateTime.ofInstant(instant, getSystemDefaultTimeZone());
    }

    public static boolean isTimeInferred(String date) throws IllegalValueException {
        System.out.println(getDateGroupFromString(date).isTimeInferred());
        return getDateGroupFromString(date).isTimeInferred();
    }

    /**
     * Parses the specified date using natty.
     * @param date non-null String containing a date
     * @return the natty-parsed date
     * @throws IllegalValueException if date is in an invalid or ambiguous format
     */
    public static DateGroup getDateGroupFromString(String date) throws IllegalValueException {
        //assert date != null;
        List<DateGroup> dateGroup = natty.parse(date);
        if (!isEmptyDateGroup(dateGroup)) {
            return dateGroup.get(0);
        }
        throw new IllegalValueException(MESSAGE_FOR_INVALID_DATE_FORMAT);
    }

    /**
     * Wrapper class pre-natty parsing that checks if the raw date string contains a time.
     * @param date
     * @return
     * @throws IllegalValueException
     */
    private static boolean containsTimeInString(String date) throws IllegalValueException {
        boolean hasTimeInString = false;
        String[] dateArgs = date.split(" ");
        for (String arg : dateArgs) {
            hasTimeInString |= isGroupOfFourDigits(arg);
        }
        return hasTimeInString;
    }

    private static boolean isGroupOfFourDigits(String arg) {
        arg = arg.replaceAll(".", "").replaceAll(":", "");
        return VALID_TIME_REGEX.matches(arg);
    }

    private static boolean isGroupOfThreeDigits(String arg) {
        arg = "0" + arg.replaceAll(".", "").replaceAll(":", "");
        return isGroupOfFourDigits(arg);
    }

    /**
     * Checks if specified DateGroup is empty.
     */
    private static boolean isEmptyDateGroup(List<DateGroup> dateGroup) {
        return dateGroup.isEmpty() || dateGroup.get(0).getDates().isEmpty();
    }

    /**
     * Returns the system's default timezone.
     */
    private static ZoneId getSystemDefaultTimeZone() {
        return ZoneId.systemDefault();
    }
}
```
###### \java\seedu\typed\logic\parser\DateValidator.java
``` java

package seedu.typed.logic.parser;

import java.util.Optional;

/**
 * Validates format of parsed date. Empty dates are considered valid.
 * @author Peixuan
 *
 */

public class DateValidator extends ArgumentValidator {

    public DateValidator(Optional<String> date) {
        this.validationRegex = "\\d{2}\\/\\d{2}\\/\\d{4}";
        this.messageConstraints = "Task date should be in the format DD/MM/YYYY";
        this.arg = date;
    }

}

```
###### \java\seedu\typed\logic\parser\EditCommandParser.java
``` java
            //TODO: iron out editTaskDescriptor.isAnyFieldEdited()
            if (argsTokenizer.getValue(PREFIX_DATE).isPresent()) {
                editTaskDescriptor.setDate(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_DATE)));
            } else {
                if (argsTokenizer.getValue(PREFIX_FROM).isPresent()) {
                    editTaskDescriptor.setFrom(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_FROM)));
                } else if (argsTokenizer.getValue(PREFIX_TO).isPresent()) {
                    editTaskDescriptor.setTo(ParserUtil.parseDate(argsTokenizer.getValue(PREFIX_TO)));
                }
            }
```
###### \java\seedu\typed\logic\parser\FindCommandParser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.typed.logic.parser.CliSyntax.KEYWORDS_ARGS_FORMAT;

import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.FindCommand;
import seedu.typed.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser {

    private static final char TAG_IDENTIFIER = '#';

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     *
     * @param args takes both keywords and tags
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(getIncorrectFindMessage());
        }
        final String[] keywords = matcher.group("keywords").split("\\s+");
        Set<String> nameKeywords = new HashSet<String>();
        Set<String> tagKeywords = new HashSet<String>();
        addKeywordsByType(keywords, nameKeywords, tagKeywords);
        return new FindCommand(nameKeywords, tagKeywords);
    }

    private void addKeywordsByType(String[] keywords, Set<String> nameKeywords, Set<String> tagKeywords) {
        for (String word : keywords) {
            if (isWordATag(word)) {
                tagKeywords.add(word.substring(1));
            } else {
                nameKeywords.add(word);
            }
        }
    }

    private String getIncorrectFindMessage() {
        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE);
    }

    private boolean isWordATag(String word) {
        assert word != null;
        assert !word.isEmpty();
        return (word.charAt(0) == TAG_IDENTIFIER);
    }

}
```
###### \java\seedu\typed\logic\parser\FindUtil.java
``` java
package seedu.typed.logic.parser;

/**
 * Contains utility methods used for parsing strings for the command Find.
 */
public class FindUtil {

    private static final int MAX_EDIT_DISTANCE = 2; // lower distance = higher similarity
    private static final int MAX_EDIT_DISTANCE_STRICT = 1;
    private static final String WHITESPACE_DELIMITER = "\\s+";

    /**
     * Checks if specified strings are an exact match.
     */
    public static boolean isExactWordMatchIgnoreCase(String str, String word) {
        assert str != null : "str cannot be null";
        assert word != null : "word cannot be null";
        assert !word.isEmpty() : "word cannot be empty";
        assert word.split(WHITESPACE_DELIMITER).length == 1 : "word parameter should be a single word";
        str = str.toLowerCase();
        word = word.toLowerCase();
        return str.equals(word);
    }

    /**
     * Checks if specified strings are substring match.
     */
    public static boolean isSubstringWordMatchIgnoreCase(String str, String word) {
        assert str != null : "str cannot be null";
        assert word != null : "word cannot be null";
        assert !word.isEmpty() : "word cannot be empty";
        assert word.split(WHITESPACE_DELIMITER).length == 1 : "word parameter should be a single word";
        str = str.toLowerCase();
        word = word.toLowerCase();
        return str.contains(word);
    }

    /**
     * Checks if specified strings are similar.
     * @param str non-null string
     * @param word non-null, non-empty string that contains a single word
     * @return isFuzzyMatch boolean indicating if str and word are a fuzzy match, i.e. similar
     */
    public static boolean isFuzzyWordMatchIgnoreCase(String str, String word) {
        assert str != null : "str cannot be null";
        assert word != null : "word cannot be null";
        assert !word.isEmpty() : "word cannot be empty";
        assert word.split(WHITESPACE_DELIMITER).length == 1 : "word parameter should be a single word";
        str = str.toLowerCase();
        word = word.toLowerCase();
        if (str.length() <= 2) {
            return isExactWordMatchIgnoreCase(str, word);
        } else if (str.length() <= 4) {
            return computeMinEditDistance(str, word) <= MAX_EDIT_DISTANCE_STRICT;
        } else {
            return computeMinEditDistance(str, word) <= MAX_EDIT_DISTANCE || isSubstringWordMatchIgnoreCase(str, word);
        }
    }

    /**
     * Checks if specified strings are similar.
     * @param str non-null string
     * @param tag non-null, non-empty string that contains a single word
     * @return isFuzzyMatch boolean indicating if str and word are a fuzzy match, i.e. similar
     */
    public static boolean isFuzzyTagMatchIgnoreCase(String str, String tag) {
        assert str != null : "str cannot be null";
        assert tag != null : "tag cannot be null";
        assert !tag.isEmpty() : "tag cannot be empty";
        assert tag.split(WHITESPACE_DELIMITER).length == 1 : "tag parameter should be a single word";
        str = str.toLowerCase();
        tag = tag.toLowerCase();
        if (str.length() == 0) {
            return true;
        } else if (str.length() <= 2) {
            return isExactWordMatchIgnoreCase(str, tag);
        } else if (str.length() <= 4) {
            return computeMinEditDistance(str, tag) <= MAX_EDIT_DISTANCE_STRICT;
        } else {
            return computeMinEditDistance(str, tag) <= MAX_EDIT_DISTANCE || isSubstringWordMatchIgnoreCase(str, tag);
        }
    }

    /**
     * Computes the minimum edit distance between specified strings as a measure of similarity.
     * @param str non-null string
     * @param word non-null, non-empty string that contains a single word
     * @return minimumEditDistance an int representation of how similar str and word are
     */
    private static int computeMinEditDistance(String str, String word) {
        assert str != null : "str cannot be null";
        assert word != null : "word cannot be null";
        assert !word.isEmpty() : "word cannot be empty";
        assert word.split(WHITESPACE_DELIMITER).length == 1 : "word parameter should be a single word";
        int lenStr = str.length();
        int lenWord = word.length();
        return computeLevenshtein(initDistance(lenStr, lenWord), str, word);
    }

    /**
     * Initializes the minimum edit distance table by padding the first row and column.
     * @param lenStr length of str where str cannot be null
     * @param lenWord length of word where word cannot be null, empty, and must contain a single word
     * @return editDistance an int array containing the initialized distances
     */
    private static int[][] initDistance(int lenStr, int lenWord) {
        assert lenStr >= 0 : "length of str must be a positive int";
        assert lenWord >= 0 : "length of word must be a positive int";
        int[][] editDistance = new int[lenStr + 1][lenWord + 1];
        for (int c = 0; c < lenWord + 1; c++) {
            editDistance[0][c] = c;
        }
        for (int r = 0; r < lenStr + 1; r++) {
            editDistance[r][0] = r;
        }
        return editDistance;
    }

    /**
     * Computes the edit distance of given indices using Levenshtein's operations.
     * @param distance an array containing initialized distances
     * @param str non-null string
     * @param word non-null, non-empty string that contains a single word
     * @return minimumEditDistance an int representation of how similar str and word are
     */
    private static int computeLevenshtein(int[][] distance, String str, String word) {
        assert str != null : "str cannot be null";
        assert word != null : "word cannot be null";
        assert !word.isEmpty() : "word cannot be empty";
        assert word.split(WHITESPACE_DELIMITER).length == 1 : "word parameter should be a single word";
        for (int i = 1; i < distance.length; i++) {
            for (int j = 1; j < distance[0].length; j++) {
                int a = distance[i - 1][j] + 1;
                int b = distance[i][j - 1] + 1;
                int c = distance[i - 1][j - 1];
                if (str.charAt(i - 1) != word.charAt(j - 1)) {
                    c += 1;
                }
                distance[i][j] = Math.min(a, Math.min(b, c));
            }
        }
        return distance[distance.length - 1][distance[0].length - 1];
    }

}
```
###### \java\seedu\typed\logic\parser\ListCommandParser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.typed.logic.parser.CliSyntax.PREFIX_WITH;

import java.util.NoSuchElementException;
import java.util.Optional;

import seedu.typed.commons.exceptions.IllegalValueException;
import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.IncorrectCommand;
import seedu.typed.logic.commands.ListCommand;

/**
 * Parses input arguments and creates a new AddCommand object
 */
public class ListCommandParser {

    private static final String ALL_STRING = "all";
    private static final String DONE_STRING = "done";
    private static final String UNDONE_STRING = "undone";
    private static final String DEADLINE_STRING = "deadline";
    //private static final String FLOATING_STRING = "floating";

    private static final Object DURATION_STRING = "duration";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * ListCommand and returns a ListCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_WITH);
        argsTokenizer.tokenize(args);
        try {
            String type = ALL_STRING; // default is show all
            Optional<String> value = argsTokenizer.getValue(PREFIX_WITH);
            if (value.isPresent() && !value.get().isEmpty()) {
                String[] split = value.get().split(" ");
                String lowered = split[0].toLowerCase();
                if (lowered.equals(ALL_STRING)
                        || lowered.equals(DONE_STRING)
                        || lowered.equals(DEADLINE_STRING)
                        || lowered.equals(UNDONE_STRING)
                        || lowered.equals(DURATION_STRING)) {
                    type = lowered;
                }
            }
            System.out.println("passing to ListCommand " + type);
            return new ListCommand(type);
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\seedu\typed\logic\parser\NameValidator.java
``` java

package seedu.typed.logic.parser;

import java.util.Optional;

/**
 * Validates format of parsed name.
 * @author Peixuan
 *
 */

public class NameValidator extends ArgumentValidator {

    public NameValidator(Optional<String> name) {
        this.validationRegex = "\\s*\\S+\\s*";
        //this.validationRegex = "[\\p{Alnum}]+";
        //this.messageConstraints = "A task name should only contain alphanumeric characters.";
        this.messageConstraints = "A task name should not be blank.";
        this.arg = name;
    }

}


```
###### \java\seedu\typed\logic\parser\Parser.java
``` java

package seedu.typed.logic.parser;

import static seedu.typed.commons.core.Messages.MESSAGE_EMPTY_COMMAND;
import static seedu.typed.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.typed.commons.core.Messages.MESSAGE_UNKNOWN_COMMAND;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.typed.logic.commands.AddCommand;
import seedu.typed.logic.commands.ClearCommand;
import seedu.typed.logic.commands.Command;
import seedu.typed.logic.commands.CompleteCommand;
import seedu.typed.logic.commands.DeleteCommand;
import seedu.typed.logic.commands.EditCommand;
import seedu.typed.logic.commands.ExitCommand;
import seedu.typed.logic.commands.ExportCommand;
import seedu.typed.logic.commands.FindCommand;
import seedu.typed.logic.commands.HelpCommand;
import seedu.typed.logic.commands.HistoryCommand;
import seedu.typed.logic.commands.ImportCommand;
import seedu.typed.logic.commands.IncorrectCommand;
import seedu.typed.logic.commands.ListCommand;
import seedu.typed.logic.commands.RedoCommand;
import seedu.typed.logic.commands.SaveCommand;
import seedu.typed.logic.commands.SelectCommand;
import seedu.typed.logic.commands.UndoCommand;

/**
 * Parses user input into a Command if input is valid.
 */
public class Parser {

    /**
     * Used for initial separation of command word and arguments.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<args>.*)");

    /**
     * Parses a raw user input and returns the corresponding Command if input is valid.
     *
     * @param input
     *            full user input string
     * @return the command based on the user input
     *          or IncorrectCommand if input is invalid
     */
    public Command parseInput(String input) {
        assert input != null;
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(input.trim());

        if (isEmptyUserInput(input)) {
            return new IncorrectCommand(getEmptyUserInputMessage());
        }

        if (!isValidUserInput(matcher)) {
            return new IncorrectCommand(getInvalidUserInputMessage());
        }
        final String command = matcher.group("commandWord");
        final String args = matcher.group("args");

        return parseValidUserInput(command, args);
    }

    /**
     * Parses a valid user input into its corresponding Command.
     * @param commandWord
     * @param args
     * @return
     */
    private Command parseValidUserInput(final String commandWord, final String args) {
        assert commandWord != null;

        if (isAddCommandWord(commandWord)) {
            return new AddCommandParser().parse(args);
        }
        if (isCompleteCommandWord(commandWord)) {
            return new CompleteCommandParser().parse(args);
        }
        if (isEditCommandWord(commandWord)) {
            return new EditCommandParser().parse(args);
        }
        if (isHelpCommandWord(commandWord)) {
            return new HelpCommand();
        }
        if (isExitCommandWord(commandWord)) {
            return new ExitCommand();
        }
        if (isListCommandWord(commandWord)) {
            return new ListCommandParser().parse(args);
        }
        if (isFindCommandWord(commandWord)) {
            return new FindCommandParser().parse(args);
        }
        if (isDeleteCommandWord(commandWord)) {
            return new DeleteCommandParser().parse(args);
        }
        if (isClearCommandWord(commandWord)) {
            return new ClearCommand();
        }
        if (isSaveCommand(commandWord)) {
            return new SaveCommandParser().parse(args);
        }
        if (isSelectCommand(commandWord)) {
            return new SelectCommandParser().parse(args);
        }
        if (isUndoCommand(commandWord)) {
            return new UndoCommandParser().parse(args);
        }
        if (isRedoCommand(commandWord)) {
            return new RedoCommandParser().parse(args);
        }
        if (isHistoryCommand(commandWord)) {
            return new HistoryCommand();
        }
        if (isExportCommand(commandWord)) {
            return new ExportCommandParser().parse(args);
        }
        if (isImportCommand(commandWord)) {
            return new ImportCommandParser().parse(args);
        }
        return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
    }

    private boolean isImportCommand(String commandWord) {
        return commandWord.equals(ImportCommand.IMPORT_COMMAND_WORD) ||
                commandWord.equals(ImportCommand.LOAD_COMMAND_WORD) ||
                commandWord.equals(ImportCommand.OPEN_COMMAND_WORD);
    }

    private boolean isExportCommand(String commandWord) {
        return commandWord.equals(ExportCommand.EXPORT_COMMAND_WORD);
    }

    private boolean isHistoryCommand(String commandWord) {
        return commandWord.equals(HistoryCommand.HISTORY_COMMAND_WORD) ||
                commandWord.equals(HistoryCommand.LOG_COMMAND_WORD) ||
                commandWord.equals(HistoryCommand.HIST_COMMAND_WORD);
    }

    private boolean isRedoCommand(String commandWord) {
        return commandWord.equals(RedoCommand.REDO_COMMAND_WORD);
    }

    private boolean isUndoCommand(String commandWord) {
        return commandWord.equals(UndoCommand.UNDO_COMMAND_WORD);
    }

    private boolean isSelectCommand(String commandWord) {
        return commandWord.equals(SelectCommand.SELECT_COMMAND_WORD);
    }

    private boolean isSaveCommand(String commandWord) {
        return commandWord.equals(SaveCommand.SAVE_COMMAND_WORD);
    }

    private boolean isClearCommandWord(String commandWord) {
        return commandWord.equals(ClearCommand.CLEAR_COMMAND_WORD) ||
                commandWord.equals(ClearCommand.EMPTY_COMMAND_WORD);
    }

    private boolean isDeleteCommandWord(String commandWord) {
        return commandWord.equals(DeleteCommand.DELETE_COMMAND_WORD) ||
                commandWord.equals(DeleteCommand.DEL_COMMAND_WORD) ||
                commandWord.equals(DeleteCommand.REMOVE_COMMAND_WORD) ||
                commandWord.equals(DeleteCommand.RM_COMMAND_WORD);
    }

    private boolean isFindCommandWord(String commandWord) {
        return commandWord.equals(FindCommand.FIND_COMMAND_WORD) ||
                commandWord.equals(FindCommand.SEARCH_COMMAND_WORD) ||
                commandWord.equals(FindCommand.QUERY_COMMAND_WORD);
    }

    private boolean isListCommandWord(String commandWord) {
        return commandWord.equals(ListCommand.LIST_COMMAND_WORD) ||
                commandWord.equals(ListCommand.FILTER_COMMAND_WORD) ||
                commandWord.equals(ListCommand.SHOW_COMMAND_WORD) ||
                commandWord.equals(ListCommand.LS_COMMAND_WORD);
    }

    private boolean isExitCommandWord(String commandWord) {
        return commandWord.equals(ExitCommand.EXIT_COMMAND_WORD) ||
                commandWord.equals(ExitCommand.QUIT_COMMAND_WORD) ||
                commandWord.equals(ExitCommand.LOGOUT_COMMAND_WORD);
    }

    private boolean isHelpCommandWord(String commandWord) {
        return commandWord.equals(HelpCommand.HELP_COMMAND_WORD) ||
                commandWord.equals(HelpCommand.MAN_COMMAND_WORD);
    }

    private boolean isEditCommandWord(String commandWord) {
        return commandWord.equals(EditCommand.EDIT_COMMAND_WORD) ||
                commandWord.equals(EditCommand.UDPATE_COMMAND_WORD) ||
                commandWord.equals(EditCommand.CHANGE_COMMAND_WORD);
    }

    private boolean isCompleteCommandWord(String commandWord) {
        return commandWord.equals(CompleteCommand.COMPLETE_COMMAND_WORD) ||
                commandWord.equals(CompleteCommand.FINISH_COMMAND_WORD) ||
                commandWord.equals(CompleteCommand.DONE_COMMAND_WORD) ||
                commandWord.equals(CompleteCommand.CHECK_COMMAND_WORD) ||
                commandWord.equals(CompleteCommand.MARK_COMMAND_WORD) ||
                commandWord.equals(CompleteCommand.END_COMMAND_WORD);
    }

    private boolean isAddCommandWord(String commandWord) {
        return commandWord.equals(AddCommand.ADD_COMMAND_WORD) ||
                commandWord.equals(AddCommand.CREATE_COMMAND_WORD) ||
                commandWord.equals(AddCommand.DO_COMMAND_WORD) ||
                commandWord.equals(AddCommand.NEW_COMMAND_WORD);
    }

    private String getEmptyUserInputMessage() {
        return MESSAGE_EMPTY_COMMAND;
    }

    private String getInvalidUserInputMessage() {
        return String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE);
    }

    private boolean isEmptyUserInput(String input) {
        assert input != null;
        return input.isEmpty();
    }

    private boolean isValidUserInput(Matcher matcher) { //include String input?
        return matcher.matches();
    }

}
```
###### \java\seedu\typed\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> date} into an {@code Optional<Date>} if
     * {@code date} is present.
     */
    public static Optional<DateTime> parseDate(Optional<String> date) throws IllegalValueException {
        assert date != null;
        return date.isPresent() ? Optional.of(DateTimeParser.getDateTimeFromLocalDateTime
                (DateTimeParser.getLocalDateTimeFromString(date.get()))) : Optional.empty();
    }
```
###### \java\seedu\typed\logic\parser\TagValidator.java
``` java

package seedu.typed.logic.parser;

import java.util.Optional;

/**
 * Validates format of parsed tag.
 * @author Peixuan
 *
 */

public class TagValidator extends ArgumentValidator {

    public TagValidator(Optional<String> tag) {
        this.validationRegex = "\\p{Alnum}+";
        this.messageConstraints = "Tag names should be alphanumeric.";
        this.arg = tag;
    }

}


```
###### \java\seedu\typed\model\Model.java
``` java
    void updateFilteredListToShowDeadline();

    void updateFilteredListToShowDuration();

    void updateFilteredListToShowDone();

    void updateFilteredListToShowUndone();

    void updateFilteredListToShowUntimed();
```
###### \java\seedu\typed\model\Model.java
``` java
    void updateFilteredTaskList(Set<String> keywords, Set<String> tagKeywords);
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Set<String> keywords, Set<String> tagKeywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)),
                new PredicateExpression(new TagQualifier(tagKeywords)));
    }

    private void updateFilteredTaskList(Expression expression, Expression tagExpression) {
        filteredTasks.setPredicate(p -> (expression.satisfies(p) || tagExpression.satisfies(p)));
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowDeadline() {
        // todo
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredListToShowDuration() {
        // todo
        this.taskManager.printData();
    }

    @Override
    public void updateFilteredListToShowDone() {
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifer()));
    }

    @Override
    public void updateFilteredListToShowUndone() {
        updateFilteredTaskList(new Negation(new CompletedQualifer()));
    }

    @Override
    public void updateFilteredListToShowUntimed() {
        //todo
        filteredTasks.setPredicate(null);
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    private class TagQualifier implements Qualifier {
        private Set<String> tagKeyWords;

        TagQualifier(Set<String> tagKeyWords) {
            this.tagKeyWords = tagKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagKeyWords.stream().filter(keyword -> StringUtil
                    .isFuzzyKeywordSearchIgnoreCase(task.getTags(), keyword)).findAny().isPresent();
        }

        @Override
        public String toString() {
            return "tag=" + String.join(", ", tagKeyWords);
        }
    }
```
###### \java\seedu\typed\model\tag\Tag.java
``` java
    /**
     * Returns the text representation of the tag
     */
    public String getValue() {
        return tagName;
    }
```
###### \java\seedu\typed\model\task\DateTime.java
``` java
    @Override
    public String toString() {
        if (localDateTime ==  null) {
            return " ";
        } else {
            return localDateTime.format(DateTimeFormatter.ofPattern("MMM dd, yyyy HH:mm"));
        }
    }
```
###### \java\seedu\typed\model\task\Notes.java
``` java

package seedu.typed.model.task;

import seedu.typed.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's notes in the task manager. Guarantees: immutable;
 */
public class Notes {

    public static final String MESSAGE_NOTES_CONSTRAINTS =
            "Task notes should only contain alphanumeric characters and spaces";
    public static final String NOTES_VALIDATION_REGEX = "\\p{Alnum}+";

    public final String value;

    /**
     * Validates given notes.
     * @param notes
     * @throws IllegalValueException
     *             if given notes string is invalid.
     */
    public Notes(String notes) throws IllegalValueException {
        if (notes == null) {
            notes = "";
        }
        String trimmedNotes = notes.trim();
        if (!trimmedNotes.isEmpty() && !isValidNotes(trimmedNotes)) {
            throw new IllegalValueException(MESSAGE_NOTES_CONSTRAINTS);
        }
        this.value = trimmedNotes;
    }

    public Notes() {
        this.value = "";
    }

    /**
     *
     * @param test
     * @return true if a given notes is a valid task notes.
     */
    public static boolean isValidNotes(String test) {
        return test.matches(NOTES_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Notes // instanceof handles nulls
                        && this.value.equals(((Notes) other).getValue())); // state
        // check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

    public String getValue() {
        return this.value;
    }

}
```
###### \java\seedu\typed\model\task\ReadOnlyTask.java
``` java
    default boolean isScheduleElementSame(ScheduleElement otherSE) {
        return this.getSE().toString().equals(otherSE.toString());
    }
```
###### \java\seedu\typed\model\task\Task.java
``` java
    public void setNotes(Notes notes) {
        this.notes = notes;
    }

    @Override
    public Notes getNotes() {
        return notes;
    }
```
###### \java\seedu\typed\model\task\Task.java
``` java
    @Override
    public boolean isEvent() {
        return se.isEvent();
    }

    @Override
    public boolean isDeadline() {
        return se.isDeadline();
    }
    @Override
    public boolean isFloating() {
        return se.isFloating();
    }
```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
    public TaskBuilder setNotes(String notes) throws IllegalValueException {
        this.notes = new Notes(notes);
        return this;
    }

    public TaskBuilder setNotes(Notes notes) {
        this.notes = notes;
        return this;
    }
```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
    public TaskBuilder setFloating() {
        this.se = ScheduleElement.makeFloating();
        return this;
    }
```
###### \java\seedu\typed\model\util\SampleDataUtil.java
``` java
            String[] notes = new String[] {"", "", "", "", "", ""};
```
###### \java\seedu\typed\model\util\SampleDataUtil.java
``` java
                        .setNotes(notes[i])
                        .setDeadline(dates[i])
```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
    private final String BY_DISPLAY_IDENTIFIER = "By:";
    private final String FROM_DISPLAY_IDENTIFIER = "From:";
    private final String TO_DISPLAY_IDENTIFIER = "To:";

    private final String WEEKDAYS = "monday|tuesday|wednesday|thursday|friday|saturday|sunday";
    private final String FREQUENCY = "day|week|month|year";
    private final String MESSAGE_EVERY_CONSTRAINTS = "Recurring Rule is not supported.";

    public ScheduleElement() {
        this.date = null;
        this.startDate = null;
        this.endDate = null;
        this.te = null;
        this.rule = "";
    }

    public ScheduleElement(DateTime date, DateTime startDate,
            DateTime endDate, TimeExpression te, String rule) {
        this.date = date;
        this.startDate = startDate;
        this.endDate = endDate;
        this.te = te;
        this.rule = rule;
    }

    public ScheduleElement(DateTime date, DateTime startDate, DateTime endDate) {
        this.date = date;
        this.startDate = startDate;
        this.endDate = endDate;
        this.te = null;
        this.rule = "";
    }
```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
    /**
     * Returns a ScheduleElement built according to the {@code dateInput}.
     */
    public ScheduleElement parseDateString(String dateInput) throws IllegalValueException {
        if (dateInput == null || dateInput.isEmpty()) {
            return makeFloating();
        }
        if (dateInput.contains(BY_DISPLAY_IDENTIFIER)) {
            String[] dateTime = dateInput.trim().split(BY_DISPLAY_IDENTIFIER);
            LocalDateTime deadline = DateTimeParser.getLocalDateTimeFromString(dateTime[1]);
            return makeDeadline(DateTimeParser.getDateTimeFromLocalDateTime(deadline));
        }
        if (dateInput.contains(FROM_DISPLAY_IDENTIFIER) && dateInput.contains(TO_DISPLAY_IDENTIFIER)) {
            String[] dateTime = dateInput.trim().split(TO_DISPLAY_IDENTIFIER);
            LocalDateTime startDateTime = DateTimeParser.getLocalDateTimeFromString(dateTime[0]
                    .replaceAll(FROM_DISPLAY_IDENTIFIER, ""));
            LocalDateTime endDateTime = DateTimeParser.getLocalDateTimeFromString(dateTime[1]);
            return makeEvent(DateTimeParser.getDateTimeFromLocalDateTime(startDateTime),
                    DateTimeParser.getDateTimeFromLocalDateTime(endDateTime));
        }
        return makeFloating();
    }
```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
    @Override
    public String toString() {
        if (isEvent()) {
            return " From: " + this.startDate + " To: " + this.endDate;
        } else if (isDeadline()) {
            return " By: " + this.date;
        } else {
            return " ";
        }
    }

    public String teToString() {
        return this.rule;
    }
```
###### \java\seedu\typed\storage\XmlAdaptedTask.java
``` java
    @XmlElement(required = true)
    private String notes;
```
