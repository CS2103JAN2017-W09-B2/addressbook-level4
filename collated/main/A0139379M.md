# A0139379M
###### \java\seedu\typed\logic\commands\CompleteCommand.java
``` java
    public static final String MESSAGE_COMPLETED_TASK_SUCCESS = "Completed Task: %1$s";
    public static final String MESSAGE_COMPLETED_TASKS_SUCCESS = "Completed %1$d tasks!";
    public static final String MESSAGE_NOT_COMPLETED = "Task does not exist on Typed!";
    public static final String MESSAGE_ALREADY_COMPLETED = "This task is already completed on Typed.";
    public static final String COMMAND_WORD_UNCOMPLETE = "uncomplete";

    private int startIndex;
    private int endIndex;

    /**
     * @param startIndex
     *            the index of the task in the filtered task list to complete
     */
    public CompleteCommand(int index) {
        assert index > 0;

        // converts filteredTaskListIndex from one-based to zero-based.
        startIndex = index - 1;
        endIndex = startIndex;
    }
    /**
     * Assumes that startIndex <= endIndex
     *
     * @param startIndex the start index as seen on Typed
     * @param endIndex the end index as seen on Typed
     */
    public CompleteCommand(int startIndex, int endIndex) {
        assert startIndex > 0;
        assert endIndex > 0;

        this.startIndex = startIndex - 1;
        this.endIndex = endIndex - 1;
    }
    /**
     * Default constructor assumes complete all tasks in filtered task list
     */
    public CompleteCommand() {
        startIndex = -1;
        endIndex = -1;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (startIndex == -1) {
            startIndex = 0;
            endIndex = model.getFilteredTaskList().size() - 1;
        }

        if (endIndex > lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        CommandResult commandResult = new CommandResult("");
        try {
            TaskManager oldTaskManager = new TaskManager(model.getTaskManager());
            commandResult = commandResultBasedOnIndices(startIndex, endIndex);
            model.completeTasks(startIndex, endIndex);
            session.updateUndoRedoStacks(COMMAND_WORD_COMPLETE, INVALID_INDEX, oldTaskManager);
        } catch (Exception e) {
            throw new CommandException(e.getMessage());
        }
        return commandResult;
    }
```
###### \java\seedu\typed\logic\parser\CompleteCommandParser.java
``` java
    public Command parse(String args) {
        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("all")) {
            return new CompleteCommand();
        }

        IndexRangeUtil range = new IndexRangeUtil(args);
        if (range.isValid()) {
            return new CompleteCommand(range.getStartIndex(),
                                       range.getEndIndex());
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                      CompleteCommand.MESSAGE_USAGE));
        }
    }
```
###### \java\seedu\typed\model\Model.java
``` java
    void completeTasks(int startIndex, int endIndex)
            throws DuplicateTaskException, IllegalValueException;
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void completeTaskAt(int filteredTaskListIndex)
            throws DuplicateTaskException, IllegalValueException {
        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.completeTaskAt(taskManagerIndex);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    private class Negation implements Expression {
        private final Qualifier qualifier;

        Negation(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return !qualifier.run(task);
        }
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    /**
     * Returns true for tasks that are completed
     * @author YIM CHIA HUI
     *
     */
    private class CompletedQualifer implements Qualifier {

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getIsCompleted();
        }
    }
}
```
###### \java\seedu\typed\model\task\DateTime.java
``` java
/**
 * DateTime represents our Date and Time in TaskManager using Java's LocalDateTime
 * It provides other static methods such as getting a new DateTime object one week,
 * one month or one year from now. The time zone and current time is based on User's
 * system default clock.
 * Guarantees: immutable;
 * @author YIM CHIA HUI
 *
 */
public class DateTime {

```
###### \java\seedu\typed\model\task\Event.java
``` java
public class Event implements ReadOnlyEvent {

    private Name name;
    private DateTime startDate;
    private DateTime endDate;
    private UniqueTagList tags;
    private boolean isRecurring;
    private String details;

    public Event(Name name, DateTime startDate, DateTime endDate, boolean isRecurring,
            String details, UniqueTagList tags) {
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.tags = tags;
        this.isRecurring = isRecurring;
        this.details = details;
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public DateTime getStartDate() {
        return startDate;
    }

    @Override
    public DateTime getEndDate() {
        return endDate;
    }

    @Override
    public UniqueTagList getTags() {
        return tags;
    }

    @Override
    public boolean isRecurring() {
        return isRecurring;
    }

    @Override
    public String getDetails() {
        return details;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyEvent// instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyEvent) other));
    }

    @Override
    public String toString() {
        return this.getAsText();
    }

}
```
###### \java\seedu\typed\model\task\EventBuilder.java
``` java
/**
 * EventBuilder faciliates the builder of Event objects
 * By default, tags and description are empty and isRecurring is false
 * name, startDate and endDate are required
 * @param ReadOnlyEvent
 * @return Event
 * @author YIM CHIA HUI
 */
public class EventBuilder {

    private Name name;
    private DateTime startDate;
    private DateTime endDate;
    private boolean isRecurring;
    private String details;
    private UniqueTagList tags;

    public EventBuilder() {
        this.isRecurring = false;
        this.details = "";
        this.tags = new UniqueTagList();
    }

    public EventBuilder(ReadOnlyEvent event) {
        this.name = event.getName();
        this.startDate = event.getStartDate();
        this.endDate = event.getEndDate();
        this.isRecurring = event.isRecurring();
        this.details = event.getDetails();
        this.tags = event.getTags();
    }

    public EventBuilder setName(String name) throws IllegalValueException {
        this.name = new Name(name);
        return this;
    }

    public EventBuilder setName(Name name) {
        this.name = name;
        return this;
    }

    public EventBuilder startDate(DateTime startDate) {
        this.startDate = startDate;
        return this;
    }

    public EventBuilder endDate(DateTime endDate) {
        this.endDate = endDate;
        return this;
    }

    public EventBuilder date(DateTime startDate, DateTime endDate) {
        this.startDate = startDate;
        this.endDate = endDate;
        return this;
    }

    public EventBuilder isRecurring(boolean isRecurring) {
        this.isRecurring = isRecurring;
        return this;
    }

    public EventBuilder setDetails(String details) {
        this.details = details;
        return this;
    }

    public EventBuilder addTags(String tag) throws DuplicateTagException, IllegalValueException {
        this.tags.add(new Tag(tag));
        return this;
    }

    public EventBuilder setTags(UniqueTagList tags) {
        this.tags = tags;
        return this;
    }

    public EventBuilder setTags(Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.tags = new UniqueTagList(tagSet);
        return this;
    }

    public Event build() {
        return new Event(this.name, this.startDate, this.endDate, this.isRecurring,
                this.details, this.tags);
    }

}
```
###### \java\seedu\typed\model\task\ReadOnlyEvent.java
``` java
/**
 * A read-only immutable interface for a Event in the TaskManager.
 * Implementations should guarantee: details are present and not null, field
 * values are validated.
 * @author YIM CHIA HUI
 */
public interface ReadOnlyEvent {


    Name getName();
    DateTime getStartDate();
    DateTime getEndDate();

    boolean isRecurring();

    String getDetails();


    /**
     * The returned TagList is a deep copy of the internal TagList, changes on
     * the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override
     * .equals)
     */
    default boolean isSameStateAs(ReadOnlyEvent other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state
                // checks here
                // onwards
                && other.getStartDate().equals(this.getStartDate())
                && other.getEndDate().equals(this.getEndDate()));
    }

    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" Name: ")
        .append(getName())
        .append(" Start Date: ")
        .append(getStartDate())
        .append(" End Date: ")
        .append(getEndDate()).append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

}
```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
/**
 * TaskBuilder helps to build a Task object by being flexible in
 * what attributes a Task object will initialise with. In particular,
 * only a name is compulsory whereas other attributes are optional.
 * @param ReadOnlyTask An existing task to modify
 * @return Task
 * @author YIM CHIA HUI
 *
 */

public class TaskBuilder {

    private Name name;
    private Notes notes;
    private ScheduleElement se;
    private UniqueTagList tags;
    private boolean isCompleted;

    public TaskBuilder() {
        this.tags = new UniqueTagList();
        this.notes = new Notes();
    }

    public TaskBuilder(ReadOnlyTask task)
            throws IllegalValueException {
        String nameToCopy = task.getName().getValue();
        this.name = new Name(nameToCopy);
        String notesToCopy = task.getNotes().getValue();
        this.notes = new Notes(notesToCopy);
        this.se = task.getSE().getDuplicate();
        this.tags = task.getTags();
        this.isCompleted = task.getIsCompleted();
    }
    public TaskBuilder setName(String name) throws IllegalValueException {
        this.name = new Name(name);
        return this;
    }

    public TaskBuilder setName(Name name) {
        assert name != null;
        this.name = name;
        return this;
    }

```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
    public TaskBuilder setSE(ScheduleElement se) {
        this.se = se;
        return this;
    }
    public TaskBuilder setDeadline(DateTime date) {
        this.se = new ScheduleElement(date);
        return this;
    }

    public TaskBuilder setDeadline(LocalDateTime date) {
        this.se = new ScheduleElement(new DateTime(date));
        return this;
    }

    public TaskBuilder setEvent(DateTime startDate, DateTime endDate) {
        this.se = new ScheduleElement(startDate, endDate);
        return this;
    }

    public TaskBuilder setEvent(LocalDateTime startDate, LocalDateTime endDate) {
        this.se = new ScheduleElement(new DateTime(startDate), new DateTime(endDate));
        return this;
    }

```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
    public TaskBuilder isCompleted(boolean isCompleted) {
        this.isCompleted = isCompleted;
        return this;
    }

    public TaskBuilder addTags(String tag) throws DuplicateTagException, IllegalValueException {
        this.tags.add(new Tag(tag));
        return this;
    }

    public TaskBuilder setTags(UniqueTagList tags) {
        this.tags = tags;
        return this;
    }

    public TaskBuilder setTags(Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.tags = new UniqueTagList(tagSet);
        return this;
    }

    public Task build() {
        return new Task(name, notes, se, tags, isCompleted);
    }

}
```
###### \java\seedu\typed\schedule\DayInMonthTE.java
``` java
/**
 * Represents a particular day in the month
 * Specified by the week and the day.
 * In particular, it is best used for every [weekday|weekend]
 * Example : every first monday would match
 * monday and first week in DayInMonthTE which holds
 * true either on January or December
 *
 **/

public class DayInMonthTE implements TimeExpression {
    private int weekCount;
    private int dayIndex;

    /**
     * Returns true if the same week and same day of the week
     */
    @Override
    public boolean includes(DateTime date) {
        return dayMatches(date) && weekMatches(date);
    }

    /**
     * Week count of a day refers to which week does it belong to:
     * is it the 1st week or 2nd week of the month
     *
     * @param date to check if recurrence matches this date
     * @return true if the week count matches the week count of the date
     */
    private boolean weekMatches(DateTime date) {
        if (weekCount > 0) {
            return weekFromStartMatches(date);
        } else {
            return weekFromEndMatches(date);
        }
    }

    /**
     * Matches the week count from the end of the month
     *
     * @param date to check if recurrence matches this date
     * @return true if the week count matches the week count of the date
     */
    private boolean weekFromEndMatches(DateTime date) {
        int daysFromMonthEnd = daysLeftInMonth(date);
        return weekInMonth(daysFromMonthEnd) == Math.abs(weekCount);
    }

    /**
     * Counts the number of days left in a month for this date which takes in account of
     * the date month and leap years
     *
     * @param date
     * @return number of days left in a month
     */
    private int daysLeftInMonth(DateTime date) {
        LocalDateTime dateTime = date.getLocalDateTime();
        int days = dateTime.getMonth().length(isLeapYear(dateTime.getYear()));
        return days - dateTime.getDayOfMonth();
    }

    /**
     * Matches the week count from the start of the month
     *
     * @param date
     * @return true if it has the same week count
     */
    private boolean weekFromStartMatches(DateTime date) {
        return this.weekInMonth(date.getLocalDateTime().getDayOfMonth()) == weekCount;
    }

    /**
     * Matches the day of the recurrence with the day of the week of date
     *
     * @param date
     * @return true if the day matches i.e Monday matches with Monday
     */
    private boolean dayMatches(DateTime date) {
        return date.getLocalDateTime().getDayOfWeek().getValue() == dayIndex;
    }

    /**
     * Calculates the week count of the month given the day number
     *
     * @param dayNumber in a calendar (ranges from 1 to 31 depending on month)
     * @return the week count which corresponds to whether it is 1st week, 2nd week etc
     */
    private int weekInMonth(int dayNumber) {
        return ((dayNumber - 1) / 7) + 1;
    }

    public static boolean isLeapYear(int year) {
        if (year % 4 != 0) {
            return false;
        } else if (year % 400 == 0) {
            return true;
        } else if (year % 100 == 0) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * For example, DayInMonthTE(1, 3) would refer to every first Wednesday
     *
     * @param weekCount represents which week is it (negative numbers count from the back of the month
     * whereas positive numbers count from the front)
     * @param dayIndex represents which day of the week (Monday = 1 to Sunday = 7)
     */
    public DayInMonthTE(int weekCount, int dayIndex) {
        this.weekCount = weekCount;
        this.dayIndex = dayIndex;
    }

    /*
     * Represent every day in a given weekCount
     *
     * @param weekCount represents which week is it (1st week, 2nd week)
     */
    public static UnionTE week(int weekCount) {
        UnionTE unionTE = new UnionTE();
        for (int dayIndex = 1; dayIndex <= 7; dayIndex++) {
            DayInMonthTE te = new DayInMonthTE(weekCount, dayIndex);
            unionTE.addTE(te);
        }
        return unionTE;
    }

    /*
     * Represent a single day every week
     * Example: it will match every monday
     * @param dayIndex refers to whether it's monday to sunday (1 to 7);
     */
    public static TimeExpression weekly(int dayIndex) {
        UnionTE unionTE = new UnionTE();
        for (int weekCount = 1; weekCount <= 5; weekCount++) {
            TimeExpression week = new DayInMonthTE(weekCount, dayIndex);
            unionTE.addTE(week);
        }
        return unionTE;
    }

    /*
     * Represent a day in a month
     * It will match only a single day in a month
     *
     * @param count refers to which week is it (1st, 2nd)
     * @param dayIndex refers to which day is it(Monday, Tuesday)
     */
    public static TimeExpression monthly(int count, int dayIndex) {
        return new DayInMonthTE(count, dayIndex);
    }

    @Override
    public DateTime nextOccurrence(DateTime date) {
        // As TimeExpression is very much more abstract than simply than
        // adding 7 days for every week, or incrementing the month for every month
        // In particular, it offers support for every first Monday which is definitely
        // not 1 month away
        int dayIndex = date.getDayIndex();
        int weekCount = date.getWeekCount();
        int month = date.getMonth();
        int year = date.getYear();
        int weekDiff = this.weekCount - weekCount;
        int dayDiff = this.dayIndex - dayIndex;
        if (month == 12) {
            year++;
            month = 1;
        } else {
            month++;
        }
        DateTime firstDayOfNextMonth = DateTime.getDateTime(year, month, 1, 0, 0);
        // find the minimum number of days to reach same dayIndex and weekCount
        // assumes this.weekCount is positive first
        if (weekDiff > 0) {
            return nextOccurrenceInNextFewWeeks(date, weekDiff, dayDiff);
        } else if (weekDiff < 0) {
            // it's actually before us so need nex month
            // finish up the month and get the next deadline
            if (includes(firstDayOfNextMonth)) {
                return firstDayOfNextMonth;
            } else {
                return nextOccurrence(firstDayOfNextMonth);
            }
        } else {
            return nextOccurrenceWithinSameWeek(date, firstDayOfNextMonth, dayDiff);
        }
    }

    /**
     * Helper method to find next occurrence from given date where it is in next few weeks
     *
     * @param date nextOccurrence from this date
     * @param weekDiff weekDifference between this current date's week count and the occurrence week
     * @param dayDiff day difference between this current date's day and the occurrence day
     * @return nextOccurrence of the recurring task after date
     */
    private DateTime nextOccurrenceInNextFewWeeks(DateTime date, int weekDiff, int dayDiff) {
        // it's next few weeks...
        if (dayDiff > 0) {
            // next few weeks + few days
            DateTime nextFewWeeks = date.nextWeeks(weekDiff);
            return nextFewWeeks.nextDays(dayDiff);
        } else if (dayDiff < 0) {
            // next few weeks - 1 week + few days
            DateTime nextFewWeeks = date.nextWeeks(weekDiff);
            return nextFewWeeks.nextDays(dayDiff);
        } else {
            // same dayIndex so next occurrence is few weeks later
            return date.nextWeeks(weekDiff);
        }
    }

    /**
     * Helper method to obtain next occurrence if it happens within the same week
     *
     * @param date
     * @param nextMonth the next month of date
     * @param dayDiff
     * @return nextOccurrence of the recurring task after date
     */
    private DateTime nextOccurrenceWithinSameWeek(DateTime date, DateTime nextMonth, int dayDiff) {
        // same week
        // need to check if wednesday is really after monday BECAUSE 1 MARCH IS WEDNESDAY BUT 6 MARCH IS MONDAY :(
        if (dayDiff > 0) {
            // next few days
            DateTime nextFewDays = date.nextDays(dayDiff);
            if (!includes(nextFewDays)) {
                // first wednesday comes before first monday
                // first sunday comes before first monday also
                // so need next month
                return nextOccurrence(nextMonth);
            } else {
                return date.nextDays(dayDiff);
            }
        } else if (dayDiff < 0) {
            // next week - dayDiff
            DateTime nextFewWeeks = date.nextWeek();
            return nextFewWeeks.nextDays(dayDiff);
        } else {
            // same week same day
            // return next week if included in time expression
            DateTime nextWeek = date.nextWeek();
            if (this.includes(nextWeek)) {
                return nextWeek;
            } else {
                return nextOccurrence(nextWeek);
            }
        }

    }

```
###### \java\seedu\typed\schedule\DifferenceTE.java
``` java
/**
 * DifferenceTE represents the logical difference
 * of exactly 2 TimeExpressions.
 * Example:Difference(lastMonday, Holidays) would match dates
 * that are last monday but not holidays(defined to match all the holidays possible)
 * @author YIM CHIA HUI
 */

public class DifferenceTE implements TimeExpression {
    private TimeExpression included;
    private TimeExpression excluded;

    /**
     * Constructor for DifferenceTE
     *
     * @param included refers to the TimeExpression to be included
     * @param excluded refers to the TimeExpression to be excluded
     */
    public DifferenceTE(TimeExpression included, TimeExpression excluded) {
        this.included = included;
        this.excluded = excluded;
    }

    @Override
    public boolean includes(DateTime date) {
        return included.includes(date) && !excluded.includes(date);
    }

    @Override
    public DateTime nextOccurrence(DateTime date) {
        // we will keep looping through the nextOccurrence of included
        // time expression until it fulfils the conditions
        boolean notFound = true;
        DateTime nextOccurrence = included.nextOccurrence(date);
        while (notFound) {
            // if nextOccurrence fulfils time expression and is after given date
            if (includes(nextOccurrence) && nextOccurrence.isAfter(date)) {
                break;
            }
            nextOccurrence = included.nextOccurrence(nextOccurrence);
        }
        return nextOccurrence;
    }
```
###### \java\seedu\typed\schedule\IntersectionTE.java
``` java
/**
 * IntersectionTE returns the logical intersection of
 * two or more TimeExpressions
 * Example: IntersectionTE(lastMonday, Jul) would refer to
 * the last Monday in July
 * @author YIM CHIA HUI
 *
 */

public class IntersectionTE implements TimeExpression {
    private ArrayList<TimeExpression> elements;

    public IntersectionTE() {
        this.elements = new ArrayList<>();
    }

    public IntersectionTE(TimeExpression te1, TimeExpression te2) {
        this.elements = new ArrayList<>();
        this.elements.add(te2);
        this.elements.add(te1);
    }

    public void addTE(TimeExpression te) {
        this.elements.add(te);
    }

    @Override
    public boolean includes(DateTime date) {
        for (TimeExpression te : elements) {
            if (!te.includes(date)) {
                return false;
            }
        }
        return true;
    }

    @Override
    public DateTime nextOccurrence(DateTime dateTime) {
        // we just have to iterate through one of the TimeExpression next occurrence
        // as Intersection have to fulfil all of them
        // Guarantees to terminate as it would just repeat 1 year later
        DateTime current = elements.get(0).nextOccurrence(dateTime);
        while (!includes(current)) {
            current = elements.get(0).nextOccurrence(current);
        }
        return current;
    }
```
###### \java\seedu\typed\schedule\RangeEachYearTE.java
``` java
/**
 * RangeEachYear represents a particular range in a year
 * It could be from March to April or more specifically
 * 17 March to 19 April.
 * includes returns true if a particular date falls
 * within this range
 * For example, 18 March falls in the range of 17 March to 19 April
 *
 * Caveat: startDay or endDay could be 0 implying the whole of the month is allowed
 * @author YIM CHIA HUI
 *
 */
public class RangeEachYearTE implements TimeExpression {

    private int startMonth;
    private int endMonth;
    private int startDay;
    private int endDay;

    /**
     * Constructor to represent range from 1st of startMonth to
     * last day of endMonth
     *
     * @param startMonth Jan = 1 till Dec = 12
     * @param endMonth Jan = 1 till Dec = 12
     */
    public RangeEachYearTE(int startMonth, int endMonth) {
        this.startMonth = startMonth;
        this.endMonth = endMonth;
        this.startDay = 1;
        this.endDay = DateTime.getLastDayOfMonth(endMonth);
    }

    /**
     * Represents a range of a month from first day to last day
     *
     * @param month Jan = 1 till Dec = 12
     */
    public RangeEachYearTE(int month) {
        this.startMonth = month;
        this.endMonth = month;
        this.startDay = 1;
        this.endDay = DateTime.getLastDayOfMonth(endMonth);
    }

    /**
     * Represent a range from startMonth with startDay till endMonth with endDay
     *
     * @param startMonth Jan = 1 till Dec = 12
     * @param endMonth Jan = 1 till Dec = 12
     * @param startDay
     * @param endDay
     */
    public RangeEachYearTE(int startMonth, int endMonth, int startDay, int endDay) {
        this.startMonth = startMonth;
        this.endMonth = endMonth;
        this.startDay = startDay;
        this.endDay = endDay;
    }

    @Override
    public boolean includes(DateTime date) {
        return monthsInclude(date) || // short-circuit if it doesn't include the months already
                startMonthIncludes(date) ||
                endMonthIncludes(date);
    }

    /**
     * Checks if the endMonth includes the date
     *
     * @param date
     * @return true if the endMonth includes the date
     */
    private boolean endMonthIncludes(DateTime date) {
        if (date.getMonth() != endMonth) {
            return false;
        }
        if (endDay == DateTime.getLastDayOfMonth(endMonth)) {
            return true;
        }
        return (date.getDay() <= endDay && date.getDay() >= startDay);
    }

    /**
     * Checks if the startMonth includes the date
     *
     * @param date
     * @return true if the startMonth includes the date
     */
    private boolean startMonthIncludes(DateTime date) {
        int day = date.getDay();
        if (date.getMonth() != startMonth) {
            return false;
        }
        if (startDay == 1) {
            // check if endMonth == startMonth
            if (endMonth > startMonth) {
                return true;
            } else {
                // endMonth == startMonth
                return day <= endDay;
            }
        }
        return (day >= startDay && day <= endDay);
    }

    /**
     * Checks if date is within the range of startMonth and endMonth
     *
     * @param date
     * @return true if it is within the range
     */
    private boolean monthsInclude(DateTime date) {
        int month = date.getMonth();
        return (month > startMonth && month < endMonth);
    }

    /*
     * Represents every day in the year, every year
     */
    public static RangeEachYearTE year() {
        // From Jan 1st to Dec 31st
        return new RangeEachYearTE(1, 12, 1, 31);
    }

    @Override
    public DateTime nextOccurrence(DateTime date) {
        int day = date.getDay();
        int month = date.getMonth();
        int year = date.getYear();

        DateTime dayAfterDate = date.nextDays(1);
        DateTime startDate = DateTime.getDateTime(year, startMonth, startDay, 0, 0);
        DateTime yearAfterStartDate = startDate.nextYear();

        if (month < startMonth || month > endMonth) {
            // next occurrence is startMonth
            if (month < startMonth) {
                // current year
                return startDate;
            } else {
                // next year start Month
                return yearAfterStartDate;
            }
        } else if (month == startMonth) {
            // month is in the start month to end month period
            // if month same as start month, check if it is before start date
            if (day < startDay) {
                return startDate;
            } else if (endMonth > startMonth) {
                // if it's after start date, maybe endMonth is next Month
                return dayAfterDate;
            } else if (day < endDay) {
                // endMonth == startMonth
                // check if day < endDay
                return dayAfterDate;
            } else {
                // day >= endDay means next occurrence is next year
                return yearAfterStartDate;
            }
        } else if (month == endMonth) {
            if (day >= endDay) {
                return yearAfterStartDate;
            } else {
                return dayAfterDate;
            }
        } else {
            // month falls within start month and end month
            return dayAfterDate;
        }
    }
```
###### \java\seedu\typed\schedule\Recurrence.java
``` java
/**
 * A factory that handles recurrence rules and returns the
 * correct TimeExpression that matches the rules.
 *
 * @author YIM CHIA HUI
 *
 */
public class Recurrence {

    /**
     * Fixed recurrence rules for every monday, tuesday etc.
     *
     */
    public static final TimeExpression MONDAY = recurEveryWeek(Day.MON);
    public static final TimeExpression TUESDAY = recurEveryWeek(Day.TUE);
    public static final TimeExpression WEDNESDAY = recurEveryWeek(Day.WED);
    public static final TimeExpression THURSDAY = recurEveryWeek(Day.THU);
    public static final TimeExpression FRIDAY = recurEveryWeek(Day.FRI);
    public static final TimeExpression SATURDAY = recurEveryWeek(Day.SAT);
    public static final TimeExpression SUNDAY = recurEveryWeek(Day.SUN);

    /*
     * TimeExpression representing the recurring deadline/event everyday
     * If event, assume that the duration of event is strictly less than a day
     *
     */
    public static TimeExpression recurEveryDay() {
        return RangeEachYearTE.year();
    }

    /*
     * TimeExpression representing the recurring deadline every week
     * This is for flexible time expressions where recur every monday for example
     *
     * @param day of the week
     */
    private static TimeExpression recurEveryWeek(Day day) {
        return DayInMonthTE.weekly(day.day());
    }

    /*
     * TimeExpression representing the recurring deadline every week
     * This is for flexible time expressions where recur every monday for example
     *
     * @param day of the week
     */
    public static TimeExpression recurEveryWeek(int dayIndex) {
        return DayInMonthTE.weekly(dayIndex);
    }

    /**
     * TimeExpression representing the recurring event every week
     * Assumes that the event is less than a week to recur
     *
     * @param startDayIndex
     * @param endDayIndex
     * @return TimeExpression which recurs the duration of the event every week
     */
    public static TimeExpression recurEveryWeek(int startDayIndex, int endDayIndex) {
        UnionTE unionTE = new UnionTE();
        for (int dayIndex = startDayIndex; dayIndex <= endDayIndex; dayIndex++) {
            unionTE.addTE(DayInMonthTE.weekly(dayIndex));
        }
        return unionTE;
    }

    /**
     * TimeExpression representing the recurring deadline every month
     * where it is exactly the same day but 1 month later each occurrence
     *
     * @param day which day of the month
     * @return TimeExpression that recurs a deadline exactly 1 month later
     */
    public static TimeExpression recurEveryMonth(int day) {
        UnionTE unionTE = new UnionTE();
        for (int month = 1; month <= 12; month++) {
            RangeEachYearTE dayInAMonth = new RangeEachYearTE(month, month, day, day);
            unionTE.addTE(dayInAMonth);
        }
        return unionTE;
    }

    /**
     * TimeExpression representing recurring events every month
     *
     * @param startDay of the event
     * @param endDay of the event
     * @return a TimeExpression that supports event that recurs every month
     */
    public static TimeExpression recurEventEveryMonth(int startDay, int endDay) {
        UnionTE unionTE = new UnionTE();
        for (int month = 1; month <= 12; month++) {
            unionTE.addTE(new RangeEachYearTE(month, month, startDay, endDay));
        }
        return unionTE;
    }

    /**
     * TimeExpression representing the recurring deadline every year
     * recurEveryYear(30, 04) next occurrence will be 30th April 1 year later
     *
     * @param day
     * @param month
     * @return TimeExpression that recurs on this exact day every year
     */
    public static TimeExpression recurEveryYear(int day, int month) {
        RangeEachYearTE dayInAMonth = new RangeEachYearTE(month, month, day, day);
        return dayInAMonth;
    }

    /**
     * TimeExpression that supports recurrence of event every year
     * Assumes start month <= end month and in the event where
     * start month = end month, start day <= end day
     *
     * @param startDay start day of the month
     * @param startMonth starting month
     * @param endDay end day of the month
     * @param endMonth ending month
     * @return TimeExpression that recurs this event duration every year
     */
    public static TimeExpression recurEveryYear(int startDay, int startMonth, int endDay, int endMonth) {
        return new RangeEachYearTE(startMonth, endMonth, startDay, endDay);
    }
}
```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
/**
 * ScheduleElement is a class that handles time and recurrence
 * In particular, it would parse the recurrence rule and base on the
 * initial dates input and determine whether it is recurring every week,
 * or every monday based on the recurring rule.
 *
 * It also help to determine whether a task is an event, deadline or floating task.
 * The dates, timeexpression and rule are final. Guarantees immutable
 *
 * @author YIM CHIA HUI
 */

    private final DateTime date; // deadlines, due dates...
    private final DateTime startDate; // start time of the event
    private final DateTime endDate; // end time of the event
    private final TimeExpression te; // representation of the recurrence

    private final String rule; // string representation of the recurrence rule
    private static final String BY_DISPLAY_IDENTIFIER = "By:";
    private static final String FROM_DISPLAY_IDENTIFIER = "From:";
    private static final String TO_DISPLAY_IDENTIFIER = "To:";

    public static final String WEEKDAYS = "monday|tuesday|wednesday|thursday|friday|saturday|sunday";
    public static final String FREQUENCY = "day|week|month|year";
    public static final String MESSAGE_EVERY_CONSTRAINTS = "Recurring Rule is not supported.";

    // =========== ScheduleElement Constructors ====================
    // =============================================================

    /**
     * Representation of a floating task
     */
    public ScheduleElement() {
        this.date = null;
        this.startDate = null;
        this.endDate = null;
        this.te = null;
        this.rule = "";
    }

    /**
     * Constructor with everything to help in copying the values
     *
     * @param date
     * @param startDate
     * @param endDate
     * @param te
     * @param rule
     */
    public ScheduleElement(DateTime date, DateTime startDate,
            DateTime endDate, TimeExpression te, String rule) {
        this.date = date;
        this.startDate = startDate;
        this.endDate = endDate;
        this.te = te;
        this.rule = rule;
    }

    /**
     * Constructor used for Edit Command
     *
     * @param date
     * @param startDate
     * @param endDate
     */
    public ScheduleElement(DateTime date, DateTime startDate, DateTime endDate) {
        this.date = date;
        this.startDate = startDate;
        this.endDate = endDate;
        this.te = null;
        this.rule = "";
    }

    /**
     * Creates a ScheduleElement that supports recurring events
     *
     * @param startDate
     * @param endDate
     * @param rule
     */
    public ScheduleElement(DateTime startDate, DateTime endDate, String rule) throws IllegalValueException {
        // handle every recurrence
        // create relevant time expression
        this.date = null;
        this.startDate = startDate;
        this.endDate = endDate;
        this.te = parseEventRecurrenceRule(rule);
        this.rule = rule;
    }
    /**
     * Creates a ScheduleElement that supports recurring deadlines
     *
     * @param date
     * @param rule
     */
    public ScheduleElement(DateTime date, String rule) throws IllegalValueException {
        this.date = date;
        this.startDate = null;
        this.endDate = null;
        this.te = parseDeadlineRecurrenceRule(rule);
        this.rule = rule;
    }

    /**
     * Representation of a deadline in our TaskManager
     *
     * @param date
     */
    public ScheduleElement(DateTime date) {
        this.date = date;
        this.startDate = null;
        this.endDate = null;
        this.te = null;
        this.rule = "";
    }
    /**
     * Representation of an event in our TaskManager..
     *
     * @param startDate
     * @param endDate
     */
    public ScheduleElement(DateTime startDate, DateTime endDate) {
        this.startDate = startDate;
        this.endDate = endDate;
        this.date = null;
        this.te = null;
        this.rule = "";
    }

    /**
     * Representation of a deadline when only recurrence is specified
     * but date is not specified
     * Example: Add task every monday
     * This is used in conjunction with makeDeadline
     *
     * @param rule specifies the recurrence rule
     * @throws IllegalValueException if rule is not of the given format
     */
    public ScheduleElement(String rule) throws IllegalValueException {
        this.date = DateTime.getToday();
        this.te = parseDeadlineRecurrenceRule(rule);
        this.rule = rule;
        this.startDate = null;
        this.endDate = null;
    }


    // =========== ScheduleElement Getters =========================
    // =============================================================

    public DateTime getDate() {
        return date;
    }

    public DateTime getStartDate() {
        return startDate;
    }

    public DateTime getEndDate() {
        return endDate;
    }

    public TimeExpression getTe() {
        return te;
    }

    public String getRule() {
        return rule;
    }


    // =========== ScheduleElement Utility =========================
    // =============================================================


    /**
     * A helper method to help do a shallow copy of a schedule element
     *
     * @param date
     * @param startDate
     * @param endDate
     * @param te
     * @param rule
     * @return A copy of the ScheduleElement
     */
    public ScheduleElement seToCopy(DateTime date, DateTime startDate,
            DateTime endDate, TimeExpression te, String rule) {
        return new ScheduleElement(date, startDate, endDate, te, rule);
    }

```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
    public boolean isEvent() {
        return date == null && startDate != null && endDate != null;
    }

    public boolean isDeadline() {
        return date != null && startDate == null && endDate == null;
    }

    public boolean isFloating() {
        return date == null && startDate == null && endDate == null;
    }

    /**
     * Checks whether a certain task is overdue
     *
     * @return true if the current time is way after the end date of the event
     * or the deadline
     */
    public boolean isOverdue() {
        DateTime now = new DateTime(LocalDateTime.now());
        if (isDeadline()) {
            return now.isAfter(date);
        } else if (isEvent()) {
            return now.isAfter(endDate);
        } else {
            return false;
        }
    }

    @Override
    public boolean includes(DateTime date) {
        if (te == null) {
            return false;
        }
        return te.includes(date);
    }

    /*
     * Static Methods to help ease constructing Schedule Elements
     */

    public static ScheduleElement makeEvent(DateTime startDate, DateTime endDate, String rule)
            throws IllegalValueException {
        if ((rule == null) || rule.equals("")) {
            // if there's no recurrence
            return new ScheduleElement(startDate, endDate);
        }
        return new ScheduleElement(startDate, endDate, rule);
    }

    public static ScheduleElement makeDeadline(DateTime date, String rule) throws IllegalValueException {
        if ((rule == null) || rule.equals("")) {
            // if there's no recurrence rule
            return new ScheduleElement(date);
        }
        return new ScheduleElement(date, rule);
    }

    // Constructing schedule elements where date is not specified
    public static ScheduleElement makeDeadline(String rule) throws IllegalValueException {
        return (new ScheduleElement(rule)).updateDate();
    }

    public static ScheduleElement makeFloating() {
        return new ScheduleElement();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ScheduleElement // instanceof handles nulls
                        && date == ((ScheduleElement) other).getDate()
                        && startDate == ((ScheduleElement) other).getStartDate()
                        && endDate == ((ScheduleElement) other).getEndDate()
                        && te == ((ScheduleElement) other).getTe()); // state check
    }

    @Override
    public DateTime nextOccurrence(DateTime dateTime) {
        if (!isRecurring()) {
            return null;
        }
        DateTime nextOccurrence = te.nextOccurrence(dateTime);
        int year = nextOccurrence.getYear();
        int month = nextOccurrence.getMonth();
        int day = nextOccurrence.getDay();
        int hr = nextOccurrence.getHour();
        int min = nextOccurrence.getMin();
        if (date != null && isDeadline()) {
            hr = date.getHour();
            min = date.getMin();
        }
        if (startDate != null && isEvent()) {
            hr = startDate.getHour();
            min = startDate.getMin();
        }
        DateTime correctOccurrence = DateTime.getDateTime(year, month, day, hr, min);
        return correctOccurrence;
    }

    public boolean isRecurring() {
        return rule != "";
    }

    /**
     * Facilitates the update of the recurring tasks' dates
     * Specifically, it will get the next occurrence of the deadline/event
     *
     * @return a scheduleElement with the updated date but with the same occurrence
     */
    public ScheduleElement updateDate() {
        if (isDeadline() && isRecurring()) {
            DateTime updatedDate = nextOccurrence(this.date);
            return new ScheduleElement(updatedDate, this.startDate, this.endDate, this.te, this.rule);
        } else if (isEvent() && isRecurring()) {
            int days = DateTime.duration(startDate, endDate);
            DateTime updatedStartDate = nextOccurrence(this.endDate); // find next occurrence after end date
            DateTime updatedEndDate = updatedStartDate.nextDays(days);
            int year = updatedEndDate.getYear();
            int month = updatedEndDate.getMonth();
            int day = updatedEndDate.getDay();
            int hr = endDate.getHour();
            int min = endDate.getMin();
            // needs to correct the end date with the original end date hour and min
            DateTime correctEndDate = DateTime.getDateTime(year, month, day, hr, min);
            return new ScheduleElement(this.date, updatedStartDate, correctEndDate, this.te, this.rule);
        } else {
            return null;
        }
    }

```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java

    /**
     * Interprets the recurrence rule in the context of events
     *
     * @param rule which specifies the recurrence rule
     * @return TimeExpression fulfiling the Recurrence rule
     * @throws IllegalValueException if the duration of the event exceeds recurrence
     * like an event lasting 1 month can't recur every week.
     */
    private TimeExpression parseEventRecurrenceRule(String rule) throws IllegalValueException {
        if (rule.matches(FREQUENCY)) {
            int duration = DateTime.duration(startDate, endDate);
            int startDayIndex = startDate.getDayIndex();
            int startDay = startDate.getDay();
            int startMonth = startDate.getMonth();
            int endDay = endDate.getDay();
            int endDayIndex = endDate.getDayIndex();
            int endMonth = endDate.getMonth();

            switch (rule.trim()) {
            case "day" :
                if (duration == 0) {
                    return Recurrence.recurEveryDay();
                } else {
                    throw new IllegalValueException(MESSAGE_EVERY_CONSTRAINTS);
                }
            case "week" :
                if (duration >= 0 && duration <= 7) {
                    return Recurrence.recurEveryWeek(startDayIndex, endDayIndex);
                } else {
                    throw new IllegalValueException(MESSAGE_EVERY_CONSTRAINTS);
                }
            case "month" :
                if (duration >= 0 && duration <= 30) {
                    return Recurrence.recurEventEveryMonth(startDay, endDay);
                } else {
                    throw new IllegalValueException(MESSAGE_EVERY_CONSTRAINTS);
                }
            case "year" :
                if (duration >= 0 && duration <= 365) {
                    return Recurrence.recurEveryYear(startDay, startMonth, endDay, endMonth);
                } else {
                    throw new IllegalValueException(MESSAGE_EVERY_CONSTRAINTS);
                }
            default :
                return null;
            }
        } else {
            throw new IllegalValueException(MESSAGE_EVERY_CONSTRAINTS);
        }
    }

    /**
     * Interprets the recurrence rule in the context of deadlines
     * Flexible in parsing every monday, every tuesday etc.
     *
     * @param rule which specifies the recurrence rule
     * @return TimeExpression which supports the recurrence rule
     */
    private TimeExpression parseDeadlineRecurrenceRule(String rule) throws IllegalValueException {
        if (rule.matches(FREQUENCY)) {
            // handle frequency like every day, month, week etc
            int dayIndex = date.getDayIndex();
            int day = date.getDay();
            int month = date.getMonth();
            switch (rule.trim()) {
            case "day" :
                return Recurrence.recurEveryDay();
            case "week" :
                return Recurrence.recurEveryWeek(dayIndex);
            case "month" :
                return Recurrence.recurEveryMonth(day);
            case "year" :
                return Recurrence.recurEveryYear(day, month);
            default:
                return null;
            }
        } else if (rule.matches(WEEKDAYS)) {
            // handle weekdays
            switch (rule.trim()) {
            case "monday" :
                return Recurrence.MONDAY;
            case "tuesday" :
                return Recurrence.TUESDAY;
            case "wednesday" :
                return Recurrence.WEDNESDAY;
            case "thursday" :
                return Recurrence.THURSDAY;
            case "friday" :
                return Recurrence.FRIDAY;
            case "saturday" :
                return Recurrence.SATURDAY;
            case "sunday" :
                return Recurrence.SUNDAY;
            default :
                return null;
            }
        } else {
            // invalid arguments
            throw new IllegalValueException(MESSAGE_EVERY_CONSTRAINTS);
        }
    }

    @Override
    public int compareTo(ScheduleElement other) {
        // floating tasks are lowest
        // otherwise sort deadlines using date and events using startdate
        // either this or other are floating or both are floating
        if (this.isFloating() && other.isFloating()) {
            return 0;
        }
        if (this.isFloating() && !other.isFloating()) {
            return 1;
        }
        if (!this.isFloating() && other.isFloating()) {
            return -1;
        }
        // deadlines or events cases
        DateTime thisDate;
        DateTime otherDate;
        if (this.isDeadline()) {
            thisDate = this.date;
        } else {
            thisDate = this.startDate;
        }
        if (other.isDeadline()) {
            otherDate = other.date;
        } else {
            otherDate = other.startDate;
        }
        if (thisDate.isAfter(otherDate)) {
            // is date is later than the other date => show it later
            // lower priority as we want to show deadlines due soon
            return 1;
        } else if (!thisDate.isAfter(otherDate)) {
            return -1;
        } else {
            return 0;
        }
    }

```
###### \java\seedu\typed\schedule\TimeExpression.java
``` java
/**
 * TimeExpression is an expression that represents
 * a recurrence rule. It is very powerful and is
 * supported with set expressions to come up with more
 * expressive recurrences.
 *
 * @author: YIM CHIA HUI
 **/
public interface TimeExpression {

    /**
     * Checks if date falls within TimeExpression
     * i.e if 12/12/2017 falls within every Monday
     * or second tuesday of every month etc
     *
     * @params date
     * @return True if TimeExpression includes date
     **/
    public boolean includes(DateTime date);

    /**
     * Returns the next DateTime
     * where it falls within the TimeExpression
     *
     * @param date
     * @return the next occurring DateTime object where
     * includes return true
     */
    public DateTime nextOccurrence(DateTime date);
```
###### \java\seedu\typed\schedule\UnionTE.java
``` java
/**
 * UnionTE represents the union of TimeExpressions
 * where includes would return true for either of the
 * TimeExpression.
 * Example UnionTE(LastMonday, LastTuesday) would return true
 * for a either a date which lands on the last Monday or Tuesday
 * @author YIM CHIA HUI
 *
 */
public class UnionTE implements TimeExpression {
    private ArrayList<TimeExpression> elements;

    @Override
    public boolean includes(DateTime date) {
        for (TimeExpression te : elements) {
            if (te.includes(date)) {
                return true;
            }
        }
        return false;
    }

    public UnionTE() {
        this.elements = new ArrayList<>();
    }

    public UnionTE(TimeExpression te1, TimeExpression te2) {
        this.elements = new ArrayList<>();
        this.elements.add(te1);
        this.elements.add(te2);
    }

    public UnionTE(TimeExpression... te) {
        this.elements = new ArrayList<>();
        for (int i = 0; i < te.length; i++) {
            this.elements.add(te[i]);
        }
    }

    public void addTE(TimeExpression te) {
        this.elements.add(te);
    }

    @Override
    public DateTime nextOccurrence(DateTime dateTime) {
        // returns the next occurrence of either of the time expression
        // choose the earliest occurrence
        DateTime earliestSoFar = elements.get(0).nextOccurrence(dateTime);
        DateTime current = earliestSoFar;
        System.out.println(current.toString());
        for (int i = 1; i < elements.size(); i++) {
            current = elements.get(i).nextOccurrence(dateTime);
            if (earliestSoFar.isAfter(current)) {
                // current is not after earliest so far
                earliestSoFar = current;
            }
        }
        return earliestSoFar;
    }

```
