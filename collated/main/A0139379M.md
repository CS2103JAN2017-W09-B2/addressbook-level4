# A0139379M
###### \java\seedu\typed\logic\commands\CompleteCommand.java
``` java
    public static final String MESSAGE_USAGE = FINISH_COMMAND_WORD + ": Marks a Task as completed "
            + "by the index number used in the last task listing.\n"
            + "Example: " + FINISH_COMMAND_WORD + " 1";

    public static final String MESSAGE_COMPLETED_TASK_SUCCESS = "Completed Task: %1$s";
    public static final String MESSAGE_COMPLETED_TASKS_SUCCESS = "Completed %1$d tasks!";
    public static final String MESSAGE_NOT_COMPLETED = "Task does not exist in the task manager";
    public static final String MESSAGE_ALREADY_COMPLETED = "This task is already completed in the task manager.";

    private int startIndex;
    private int endIndex;

    /**
     * @param startIndex
     *            the index of the task in the filtered task list to complete
     */
    public CompleteCommand(int index) {
        assert index > 0;

        // converts filteredTaskListIndex from one-based to zero-based.
        startIndex = index - 1;
        endIndex = startIndex;
    }
    /**
     *
     * @param startIndex
     * @param endIndex
     * Assumes that startIndex <= endIndex
     */
    public CompleteCommand(int startIndex, int endIndex) {
        assert startIndex > 0;
        assert endIndex > 0;

        this.startIndex = startIndex - 1;
        this.endIndex = endIndex - 1;
    }
    /**
     * Default constructor assumes complete all tasks in filtered task list
     */
    public CompleteCommand() {
        this.startIndex = -1;
        this.endIndex = -1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        ArrayList<Integer> listOfIndices = new ArrayList<Integer>();
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (startIndex == -1) {
            startIndex = 0;
            endIndex = model.getFilteredTaskList().size() - 1;
        }

        if (endIndex > lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        try {
            model.completeTasksAndStoreIndices(startIndex, endIndex, listOfIndices);
            session.updateUndoRedoStacks(CommandTypeUtil.TYPE_COMPLETE, -1, listOfIndices);
            session.updateValidCommandsHistory(commandText);
        } catch (Exception e) {
            throw new CommandException(e.getMessage());
        }
        return commandResultBasedOnIndicesList(listOfIndices);
    }
```
###### \java\seedu\typed\logic\parser\CompleteCommandParser.java
``` java
    public Command parse(String args) {
        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("all")) {
            return new CompleteCommand();
        }

        IndexRangeUtil range = new IndexRangeUtil(args);
        if (range.isValid()) {
            return new CompleteCommand(range.getStartIndex(),
                                       range.getEndIndex());
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                      CompleteCommand.MESSAGE_USAGE));
        }
    }
```
###### \java\seedu\typed\model\Model.java
``` java
    void completeTasks(int startIndex, int endIndex) throws DuplicateTaskException;
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void completeTaskAt(int filteredTaskListIndex)
            throws DuplicateTaskException {
        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.completeTaskAt(taskManagerIndex);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void completeTasks(int startIndex, int endIndex)
            throws DuplicateTaskException {
        int num = endIndex - startIndex + 1;
        for (int i = 0; i < num; i++) {
            int taskManagerIndex = filteredTasks.getSourceIndex(startIndex);
            taskManager.completeTaskAt(taskManagerIndex);
            updateFilteredListToShowDefault();
            indicateTaskManagerChanged();
        }
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    /**
     * Returns true for tasks that are completed
     * @author YIM CHIA HUI
     *
     */
    private class CompletedQualifer implements Qualifier {

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getIsCompleted();
        }
    }
```
###### \java\seedu\typed\model\task\DateTime.java
``` java
/**
 * DateTime represents our Date and Time in TaskManager using Java's LocalDateTime
 * It provides other static methods such as getting a new DateTime object one week,
 * one month or one year from now. The time zone and current time is based on User's
 * system default clock.
 * Guarantees: immutable;
 * @author YIM CHIA HUI
 *
 */
public class DateTime {

    private static final long LONG_ONE = (long) 1.0;

    private final LocalDateTime localDateTime;

    public DateTime(LocalDateTime localDateTime) {
        super();
        this.localDateTime = localDateTime;
    }

    public DateTime() {
        this.localDateTime = null;
    }

    public static DateTime parseDateString(String date) {
        // assume in dd/mm/yyyy format
        String[] dates = date.trim().split("-");
        for (int i = 0; i < dates.length; i++) {
            System.out.println(dates[i] + " " + Integer.valueOf(dates[i]));
        }
        System.out.println(dates[0]);
        int year = Integer.valueOf(dates[0]);
        int month = Integer.valueOf(dates[1]);
        int day = Integer.valueOf(dates[2]);
        return DateTime.getDateTime(year, month, day, 0, 0);
    }

    public LocalDateTime getLocalDateTime() {
        return localDateTime;
    }

    public boolean equals(DateTime other) {
        LocalDateTime self = this.localDateTime;
        LocalDateTime others = other.localDateTime;
        return (self.getDayOfMonth() == others.getDayOfMonth())
                && (self.getMonth() == others.getMonth())
                && (self.getYear() == others.getYear())
                && (self.getHour() == others.getHour())
                && (self.getMinute() == others.getMinute())
                && (self.getSecond() == others.getSecond());

    }

    public boolean isAfter(DateTime other) {
        return this.localDateTime.isAfter(other.getLocalDateTime());
    }

    public boolean isToday() {
        LocalDate today = LocalDate.now();
        return this.localDateTime.toLocalDate().equals(today);
    }

    /*
    public static DateTime getTomorrow() {
        LocalDateTime nextDay = LocalDateTime.now(defaultClock).plusDays(LONG_ONE);
        return new DateTime(nextDay);
    }
    public static DateTime getNextWeek() {
        LocalDateTime nextWeek = LocalDateTime.now(defaultClock).plusWeeks(LONG_ONE);
        return new DateTime(nextWeek);
    }

    public static DateTime getNextMonth() {
        LocalDateTime nextMonth = LocalDateTime.now(defaultClock).plusMonths(LONG_ONE);
        return new DateTime(nextMonth);
    }

    public static DateTime getNextYear() {
        LocalDateTime nextYear = LocalDateTime.now(defaultClock).plusYears(LONG_ONE);
        return new DateTime(nextYear);
    }
     */

    public int getDayIndex() {
        return this.localDateTime.getDayOfWeek().getValue();
    }

    public int getDay() {
        return this.localDateTime.getDayOfMonth();
    }

    public int getWeekCount() {
        int daysFromMonthStart = this.localDateTime.getDayOfMonth();
        return weekInMonth(daysFromMonthStart);
    }

    public int getMonth() {
        return this.localDateTime.getMonthValue();
    }

    public int getYear() {
        return this.localDateTime.getYear();
    }

    private int weekInMonth(int dayNumber) {
        return ((dayNumber - 1) / 7) + 1;
    }
    public static boolean isLeapYear(int year) {
        if (year % 4 != 0) {
            return false;
        } else if (year % 400 == 0) {
            return true;
        } else if (year % 100 == 0) {
            return false;
        } else {
            return true;
        }
    }

    public DateTime tomorrow() {
        LocalDateTime nextDay = this.localDateTime.plusDays(LONG_ONE);
        return new DateTime(nextDay);
    }
    public DateTime nextDays(int count) {
        LocalDateTime nextDays = this.localDateTime.plusDays((long) count);
        return new DateTime(nextDays);
    }
    public DateTime nextWeek() {
        LocalDateTime nextWeek = this.localDateTime.plusWeeks(LONG_ONE);
        return new DateTime(nextWeek);
    }

    public DateTime nextWeeks(int count) {
        LocalDateTime nextFewWeeks = this.localDateTime.plusWeeks((long) count);
        return new DateTime(nextFewWeeks);
    }

    public DateTime nextMonth() {
        LocalDateTime nextMonth = this.localDateTime.plusMonths(LONG_ONE);
        return new DateTime(nextMonth);
    }

    public DateTime nextYear() {
        LocalDateTime nextYear = this.localDateTime.plusYears(LONG_ONE);
        return new DateTime(nextYear);
    }

    public static DateTime getToday() {
        return new DateTime(LocalDateTime.now());
    }

    public static DateTime getDateTime(int year, Month month, int day, int hr, int min) {
        return new DateTime(LocalDateTime.of(year, month, day, hr, min));
    }

    public static DateTime getDateTime(int year, int month, int day, int hr, int min) {
        return new DateTime(LocalDateTime.of(year, month, day, hr, min));
    }

    public static int duration(DateTime date, DateTime other) {
        Long duration;
        if (date.isAfter(other)) {
            duration = other.getLocalDateTime().until(date.getLocalDateTime(), ChronoUnit.DAYS);
            return duration.intValue();
        } else {
            duration = date.getLocalDateTime().until(other.getLocalDateTime(), ChronoUnit.DAYS);
            return duration.intValue();
        }
    }

```
###### \java\seedu\typed\model\task\Event.java
``` java
public class Event implements ReadOnlyEvent {

    private Name name;
    private DateTime startDate;
    private DateTime endDate;
    private UniqueTagList tags;
    private boolean isRecurring;
    private String details;

    public Event(Name name, DateTime startDate, DateTime endDate, boolean isRecurring,
            String details, UniqueTagList tags) {
        this.name = name;
        this.startDate = startDate;
        this.endDate = endDate;
        this.tags = tags;
        this.isRecurring = isRecurring;
        this.details = details;
    }

    @Override
    public Name getName() {
        return name;
    }

    @Override
    public DateTime getStartDate() {
        return startDate;
    }

    @Override
    public DateTime getEndDate() {
        return endDate;
    }

    @Override
    public UniqueTagList getTags() {
        return tags;
    }

    @Override
    public boolean isRecurring() {
        return isRecurring;
    }

    @Override
    public String getDetails() {
        return details;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyEvent// instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyEvent) other));
    }

    @Override
    public String toString() {
        return this.getAsText();
    }

}
```
###### \java\seedu\typed\model\task\EventBuilder.java
``` java
/**
 * EventBuilder faciliates the builder of Event objects
 * By default, tags and description are empty and isRecurring is false
 * name, startDate and endDate are required
 * @param ReadOnlyEvent
 * @return Event
 * @author YIM CHIA HUI
 */
public class EventBuilder {

    private Name name;
    private DateTime startDate;
    private DateTime endDate;
    private boolean isRecurring;
    private String details;
    private UniqueTagList tags;

    public EventBuilder() {
        this.isRecurring = false;
        this.details = "";
        this.tags = new UniqueTagList();
    }

    public EventBuilder(ReadOnlyEvent event) {
        this.name = event.getName();
        this.startDate = event.getStartDate();
        this.endDate = event.getEndDate();
        this.isRecurring = event.isRecurring();
        this.details = event.getDetails();
        this.tags = event.getTags();
    }

    public EventBuilder setName(String name) throws IllegalValueException {
        this.name = new Name(name);
        return this;
    }

    public EventBuilder setName(Name name) {
        this.name = name;
        return this;
    }

    public EventBuilder startDate(DateTime startDate) {
        this.startDate = startDate;
        return this;
    }

    public EventBuilder endDate(DateTime endDate) {
        this.endDate = endDate;
        return this;
    }

    public EventBuilder date(DateTime startDate, DateTime endDate) {
        this.startDate = startDate;
        this.endDate = endDate;
        return this;
    }

    public EventBuilder isRecurring(boolean isRecurring) {
        this.isRecurring = isRecurring;
        return this;
    }

    public EventBuilder setDetails(String details) {
        this.details = details;
        return this;
    }

    public EventBuilder addTags(String tag) throws DuplicateTagException, IllegalValueException {
        this.tags.add(new Tag(tag));
        return this;
    }

    public EventBuilder setTags(UniqueTagList tags) {
        this.tags = tags;
        return this;
    }

    public EventBuilder setTags(Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.tags = new UniqueTagList(tagSet);
        return this;
    }

    public Event build() {
        return new Event(this.name, this.startDate, this.endDate, this.isRecurring,
                this.details, this.tags);
    }

}
```
###### \java\seedu\typed\model\task\ReadOnlyEvent.java
``` java
/**
 * A read-only immutable interface for a Event in the TaskManager.
 * Implementations should guarantee: details are present and not null, field
 * values are validated.
 * @author YIM CHIA HUI
 */
public interface ReadOnlyEvent {


    Name getName();
    DateTime getStartDate();
    DateTime getEndDate();

    boolean isRecurring();

    String getDetails();


    /**
     * The returned TagList is a deep copy of the internal TagList, changes on
     * the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override
     * .equals)
     */
    default boolean isSameStateAs(ReadOnlyEvent other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state
                // checks here
                // onwards
                && other.getStartDate().equals(this.getStartDate())
                && other.getEndDate().equals(this.getEndDate()));
    }

    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" Name: ")
        .append(getName())
        .append(" Start Date: ")
        .append(getStartDate())
        .append(" End Date: ")
        .append(getEndDate()).append(" Tags: ");
        getTags().forEach(builder::append);
        return builder.toString();
    }

}
```
###### \java\seedu\typed\model\task\TaskBuilder.java
``` java
/**
 * TaskBuilder helps to build a Task object by being flexible in
 * what attributes a Task object will initialise with. In particular,
 * only a name is compulsory whereas other attributes are optional.
 * @param ReadOnlyTask An existing task to modify
 * @return Task
 * @author YIM CHIA HUI
 *
 */

public class TaskBuilder {

    private Name name;
    private Notes notes;
    private ScheduleElement se;
    private UniqueTagList tags;
    private boolean isCompleted;

    public TaskBuilder() {
        this.tags = new UniqueTagList();
        this.notes = new Notes();
    }

    public TaskBuilder(ReadOnlyTask task) {
        this.name = task.getName();
        this.notes = task.getNotes();
        this.se = task.getSE();
        this.tags = task.getTags();
        this.isCompleted = task.getIsCompleted();
    }
    public TaskBuilder setName(String name) throws IllegalValueException {
        this.name = new Name(name);
        return this;
    }

    public TaskBuilder setName(Name name) {
        assert name != null;
        this.name = name;
        return this;
    }

```
###### \java\seedu\typed\schedule\DayInMonthTE.java
``` java
/**
 * Represents a particular day in the month
 * Specified by the week and the day.
 * In particular, it is best used for every [weekday|weekend]
 * Example : every first monday would match
 * monday and first week in DayInMonthTE which holds
 * true either on January or December
 **/

public class DayInMonthTE implements TimeExpression {
    private int weekCount;
    private int dayIndex;

    /**
     * Returns true if the same week and same day of the week
     */
    @Override
    public boolean includes(DateTime date) {
        return dayMatches(date) && weekMatches(date);
    }
    /**
     * Week count of a day refers to which week does it belong to:
     * is it the 1st week or 2nd week of the month
     * @param date
     * @return true if the week count matches the week count of the date
     */
    private boolean weekMatches(DateTime date) {
        if (weekCount > 0) {
            return weekFromStartMatches(date);
        } else {
            return weekFromEndMatches(date);
        }
    }
    private boolean weekFromEndMatches(DateTime date) {
        int daysFromMonthEnd = daysLeftInMonth(date);
        return weekInMonth(daysFromMonthEnd) == Math.abs(weekCount);
    }
    private int daysLeftInMonth(DateTime date) {
        LocalDateTime dateTime = date.getLocalDateTime();
        int days = dateTime.getMonth().length(isLeapYear(dateTime.getYear()));
        return days - dateTime.getDayOfMonth();
    }
    private boolean weekFromStartMatches(DateTime date) {
        return this.weekInMonth(date.getLocalDateTime().getDayOfMonth()) == weekCount;
    }
    private boolean dayMatches(DateTime date) {
        return date.getLocalDateTime().getDayOfWeek().getValue() == dayIndex;
    }

    private int weekInMonth(int dayNumber) {
        return ((dayNumber - 1) / 7) + 1;
    }
    public static boolean isLeapYear(int year) {
        if (year % 4 != 0) {
            return false;
        } else if (year % 400 == 0) {
            return true;
        } else if (year % 100 == 0) {
            return false;
        } else {
            return true;
        }
    }
    /**
     * For example, DayInMonthTE(1, 3) would refer to every first Wednesday
     * @param weekCount represents which week is it (negative numbers count from the back of the month
     * whereas positive numbers count from the front)
     * @param dayIndex represents which day of the week (Monday = 1 to Sunday = 7)
     */
    public DayInMonthTE(int weekCount, int dayIndex) {
        this.weekCount = weekCount;
        this.dayIndex = dayIndex;
    }

    /*
     * Represent every day in a week
     * @param weekCount represents which week is it (1st week, 2nd week)
     */
    public static UnionTE week(int weekCount) {
        UnionTE unionTE = new UnionTE();
        for (int dayIndex = 1; dayIndex <= 7; dayIndex++) {
            DayInMonthTE te = new DayInMonthTE(weekCount, dayIndex);
            unionTE.addTE(te);
        }
        return unionTE;
    }

    /*
     * Represent every day in a month
     * It will match every single day in a week
     */
    public static TimeExpression month() {
        UnionTE unionTE = new UnionTE();
        for (int weekCount = -1; weekCount <= 4; weekCount++) {
            TimeExpression week = DayInMonthTE.week(weekCount);
            unionTE.addTE(week);
        }
        return unionTE;
    }

    /*
     * Represent a single day every week
     * It will match up to 5 similar days (monday, tuesday ...)
     * in a month
     */
    public static TimeExpression weekly(int dayIndex) {
        UnionTE unionTE = new UnionTE();
        for (int weekCount = 1; weekCount <= 5; weekCount++) {
            TimeExpression week = new DayInMonthTE(weekCount, dayIndex);
            unionTE.addTE(week);
        }
        return unionTE;
    }
    /*
     * Represent a day in a month
     * It will match only a single day in a month
     */
    public static TimeExpression monthly(int count, int dayIndex) {
        return new DayInMonthTE(count, dayIndex);
    }
    @Override
    public DateTime nextDeadlineOccurrence(DateTime date) {
        int dayIndex = date.getDayIndex();
        int weekCount = date.getWeekCount();
        int month = date.getMonth();
        int year = date.getYear();
        int weekDiff = this.weekCount - weekCount;
        int dayDiff = this.dayIndex - dayIndex;
        // find the minimum number of days to reach same dayIndex and weekCount
        // assumes this.weekCount is positive first
        if (weekDiff > 0) {
            // it's next few weeks...
            if (dayDiff > 0) {
                // next few weeks + few days
                DateTime nextFewWeeks = date.nextWeeks(weekDiff);
                return nextFewWeeks.nextDays(dayDiff);
            } else if (dayDiff < 0) {
                // next few weeks - 1 week + few days
                DateTime nextFewWeeks = date.nextWeeks(weekDiff);
                return nextFewWeeks.nextDays(dayDiff);
            } else {
                // same dayIndex so next occurrence is few weeks later
                return date.nextWeeks(weekDiff);
            }
        } else if (weekDiff < 0) {
            // it's actually before us so need nex month
            // finish up the month and get the next deadline
            if (month == 12) {
                year++;
                month = 1;
            } else {
                month++;
            }
            DateTime firstDayOfNextMonth = DateTime.getDateTime(year, month, 1, 0, 0);
            return nextDeadlineOccurrence(firstDayOfNextMonth);
        } else {
            // same week
            if (dayDiff > 0) {
                // next few days
                return date.nextDays(dayDiff);
            } else if (dayDiff < 0) {
                // next week - dayDiff
                DateTime nextFewWeeks = date.nextWeek();
                return nextFewWeeks.nextDays(dayDiff);
            } else {
                // same week same day
                // return next week if included in time expression
                DateTime nextWeek = date.nextWeek();
                if (this.includes(nextWeek)) {
                    return nextWeek;
                } else {
                    return nextDeadlineOccurrence(nextWeek);
                }
            }
        }
    }

}
```
###### \java\seedu\typed\schedule\DifferenceTE.java
``` java
/**
 * DifferenceTE represents the logical difference
 * of exactly 2 TimeExpressions.
 * Example:Difference(lastMonday, Holidays) would match dates
 * that are last monday but not holidays(defined to match all the holidays possible)
 * @author YIM CHIA HUI
 */
public class DifferenceTE implements TimeExpression {
    private TimeExpression included;
    private TimeExpression excluded;

    public DifferenceTE(TimeExpression included, TimeExpression excluded) {
        this.included = included;
        this.excluded = excluded;
    }
    @Override
    public boolean includes(DateTime date) {
        return included.includes(date) && !excluded.includes(date);
    }
    @Override
    public DateTime nextDeadlineOccurrence(DateTime date) {
        boolean notFound = true;
        DateTime nextOccurrence = included.nextDeadlineOccurrence(date);
        while (notFound) {
            // if nextOccurrence fulfils time expression and is after given date
            if (includes(nextOccurrence) && nextOccurrence.isAfter(date)) {
                break;
            }
            nextOccurrence = included.nextDeadlineOccurrence(nextOccurrence);
        }
        return nextOccurrence;
    }
}
```
###### \java\seedu\typed\schedule\IntersectionTE.java
``` java
/**
 * IntersectionTE returns the logical intersection of
 * two or more TimeExpressions
 * Example: IntersectionTE(lastMonday, Jul) would refer to
 * the last Monday in July
 * @author YIM CHIA HUI
 *
 */
public class IntersectionTE implements TimeExpression {
    private ArrayList<TimeExpression> elements;

    public IntersectionTE() {
        this.elements = new ArrayList<>();
    }
    public IntersectionTE(TimeExpression te1, TimeExpression te2) {
        this.elements = new ArrayList<>();
        this.elements.add(te2);
        this.elements.add(te1);
    }

    public IntersectionTE(TimeExpression... te) {
        this.elements = new ArrayList<>();
        for (int i = 0; i < te.length; i++) {
            this.elements.add(te[i]);
        }
    }

    public void addTE(TimeExpression te) {
        this.elements.add(te);
    }
    @Override
    public boolean includes(DateTime date) {
        for (TimeExpression te : elements) {
            if (!te.includes(date)) {
                return false;
            }
        }
        return true;
    }

    /**
     * next deadline occurrence just needs to keep iterating through
     * the next deadline occurrence of one of the time expression
     * as it is the only date it fulfils
     */
    @Override
    public DateTime nextDeadlineOccurrence(DateTime dateTime) {
        DateTime current = elements.get(0).nextDeadlineOccurrence(dateTime);
        while (!includes(current)) {
            current = elements.get(0).nextDeadlineOccurrence(current);
        }
        return current;
    }
}
```
###### \java\seedu\typed\schedule\RangeEachYearTE.java
``` java
/**
 * RangeEachYear represents a particular range in a year
 * It could be from March to April or more specifically
 * 17 March to 19 April.
 * includes returns true if a particular date falls
 * within this range
 * For example, 18 March falls in the range of 17 March to 19 April
 * @author YIM CHIA HUI
 *
 */
public class RangeEachYearTE implements TimeExpression {

    private int startMonth;
    private int endMonth;
    private int startDay;
    private int endDay;

    public RangeEachYearTE(int startMonth, int endMonth) {
        this.startMonth = startMonth;
        this.endMonth = endMonth;
        this.startDay = 0;
        this.endDay = 0;
    }

    public RangeEachYearTE(int month) {
        this.startMonth = month;
        this.endMonth = month;
        this.startDay = 0;
        this.endDay = 0;
    }

    public RangeEachYearTE(int startMonth, int endMonth, int startDay, int endDay) {
        super();
        this.startMonth = startMonth;
        this.endMonth = endMonth;
        this.startDay = startDay;
        this.endDay = endDay;
    }

    @Override
    public boolean includes(DateTime date) {
        return monthsInclude(date) ||
                startMonthIncludes(date) ||
                endMonthIncludes(date);
    }

    private boolean endMonthIncludes(DateTime date) {
        if (date.getLocalDateTime().getMonthValue() != endMonth) {
            return false;
        }
        if (endDay == 0) {
            return true;
        }
        return (date.getLocalDateTime().getDayOfMonth() <= endDay);
    }

    private boolean startMonthIncludes(DateTime date) {
        if (date.getLocalDateTime().getMonthValue() != startMonth) {
            return false;
        }
        if (startDay == 0) {
            return true;
        }
        return (date.getLocalDateTime().getDayOfMonth() >= startDay);
    }

    private boolean monthsInclude(DateTime date) {
        int month = date.getMonth();
        return (month > startMonth && month < endMonth);
    }

    /*
     * Represents every day in the year, every year
     */
    public static RangeEachYearTE year() {
        // From Jan 1st to Dec 31st
        return new RangeEachYearTE(1, 12, 1, 31);
    }

    @Override
    public DateTime nextDeadlineOccurrence(DateTime date) {
        int day = date.getDay();
        int month = date.getMonth();
        int year = date.getYear();

        if (month < startMonth || month > endMonth) {
            // next occurrence is startMonth
            if (month < startMonth) {
                // current year
                return DateTime.getDateTime(year, startMonth, startDay, 0, 0);
            } else {
                // next year start Month
                return DateTime.getDateTime(year + 1, startMonth, startDay, 0, 0);
            }
        } else {
            // month is in the start month to end month period
            if (day < startDay || day > endDay) {
                // start month start date
                return DateTime.getDateTime(year, startMonth, startDay, 0, 0);
            } else {
                // next year
                return DateTime.getDateTime(year + 1, startMonth, startDay, 0, 0);
            }
        }
    }

}
```
###### \java\seedu\typed\schedule\TimeExpression.java
``` java
/**
 * TimeExpression is an expression that specifies
 * a recurring date. All TimeExpression has an individual
 * instance method to work out whether a day lies in the
 * expression.
 * @author: YIM CHIA HUI
 **/
public interface TimeExpression {

    /**
     * Checks if date falls within TimeExpression
     * i.e if 12/12/2017 falls within every Monday
     * or second tuesday of every month etc
     * @params date
     * @return True if TimeExpression includes date
     **/
    public boolean includes(DateTime date);

    /**
     * Returns the next DateTime
     * where it falls within the TimeExpression
     * @param date
     * @return the next occurring DateTime object where
     * includes return true
     */
    public DateTime nextDeadlineOccurrence(DateTime date);

}
```
###### \java\seedu\typed\schedule\UnionTE.java
``` java
/**
 * UnionTE represents the union of TimeExpressions
 * where includes would return true for either of the
 * TimeExpression.
 * Example UnionTE(LastMonday, LastTuesday) would return true
 * for a either a date which lands on the last Monday or Tuesday
 * @author YIM CHIA HUI
 *
 */
public class UnionTE implements TimeExpression {
    private ArrayList<TimeExpression> elements;

    @Override
    public boolean includes(DateTime date) {
        for (TimeExpression te : elements) {
            if (te.includes(date)) {
                return true;
            }
        }
        return false;
    }

    public UnionTE() {
        this.elements = new ArrayList<>();
    }

    public UnionTE(TimeExpression te1, TimeExpression te2) {
        this.elements = new ArrayList<>();
        this.elements.add(te1);
        this.elements.add(te2);
    }

    public UnionTE(TimeExpression... te) {
        this.elements = new ArrayList<>();
        for (int i = 0; i < te.length; i++) {
            this.elements.add(te[i]);
        }
    }

    public void addTE(TimeExpression te) {
        this.elements.add(te);
    }

    @Override
    public DateTime nextDeadlineOccurrence(DateTime dateTime) {
        // returns the next occurrence of either of the time expression
        // choose the earliest occurrence
        DateTime earliestSoFar = elements.get(0).nextDeadlineOccurrence(dateTime);
        DateTime current = earliestSoFar;
        for (int i = 1; i < elements.size(); i++) {
            current = elements.get(i).nextDeadlineOccurrence(dateTime);
            System.out.println(earliestSoFar.toString());
            if (earliestSoFar.isAfter(current)) {
                // current is not after earliest so far
                earliestSoFar = current;
            }
        }
        return earliestSoFar;
    }
}
```
