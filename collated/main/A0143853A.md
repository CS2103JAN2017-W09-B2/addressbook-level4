# A0143853A
###### \java\seedu\typed\commons\util\Pair.java
``` java
/**
 * Stores two items.
 */

public class Pair<F, S> {
    private F first;
    private S second;

    public Pair(F first, S second) {
        this.first = first;
        this.second = second;
    }

    public F getFirst() {
        return first;
    }

    public S getSecond() {
        return second;
    }

    public void setFirst(F first) {
        this.first = first;
    }

    public void setSecond(S second) {
        this.second = second;
    }


    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj instanceof Pair) {
            @SuppressWarnings("unchecked")
            Pair<F, S> pair = (Pair<F, S>) obj;
            return first.equals(pair.getFirst())
                   && second.equals(pair.getSecond());
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\typed\commons\util\Triple.java
``` java
/**
 * Stores three items.
 */

public class Triple<F, S, T> {
    private F first;
    private S second;
    private T third;

    public Triple(F first, S second, T third) {
        this.first = first;
        this.second = second;
        this.third = third;
    }

    public F getFirst() {
        return first;
    }

    public S getSecond() {
        return second;
    }

    public T getThird() {
        return third;
    }

    public void setFirst(F first) {
        this.first = first;
    }

    public void setSecond(S second) {
        this.second = second;
    }

    public void setThird(T third) {
        this.third = third;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj instanceof Triple) {
            @SuppressWarnings("unchecked")
            Triple<F, S, T> triple = (Triple<F, S, T>) obj;
            return first.equals(triple.getFirst())
                   && second.equals(triple.getSecond())
                   && third.equals(triple.getThird());
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\typed\logic\commands\AddCommand.java
``` java
    /**
     * Executes the add command by adding the task to be added
     * and scrolling to the index of the newly added task.
     */
    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        assert session != null;

        try {
            model.addTask(toAdd);

            int taskManagerIndex = model.getIndexOfTask(toAdd);
            session.updateUndoRedoStacks(COMMAND_WORD_ADD, taskManagerIndex, toAdd);

            int filteredListIndex = model.getFilteredTaskList().indexOf(toAdd);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(filteredListIndex));

            String name = toAdd.getName().toString();
            return new CommandResult(String.format(MESSAGE_SUCCESS, name));
        } catch (DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException tnfe) {
            assert false : "Task added must be found!";

            String name = toAdd.getName().toString();
            throw new CommandException(String.format(MESSAGE_SUCCESS, name));
        }
    }
```
###### \java\seedu\typed\logic\commands\ClearCommand.java
``` java
    public static final String COMMAND_WORD_UNCLEAR = "unclear";
    public static final String MESSAGE_USAGE = COMMAND_WORD_CLEAR + ": Clears all tasks on Typed. "
            + "Parameters: NONE\n"
            + "Example: " + COMMAND_WORD_CLEAR;

    public static final String MESSAGE_SUCCESS = "Typed has been cleared!";
    public static final String MESSAGE_FAILURE = "Typed cannot be cleared!";


    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;

        try {
            TaskManager oldTaskManager = new TaskManager(model.getTaskManager());
            model.resetData(new TaskManager());
            session.updateUndoRedoStacks(COMMAND_WORD_CLEAR, -1, oldTaskManager);
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (IllegalValueException ive) {
            throw new CommandException(MESSAGE_FAILURE);
        }

    }
```
###### \java\seedu\typed\logic\commands\CompleteCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD_FINISH + ": Marks task(s) as completed "
            + "by the index number(s) used in the last task listing.\n"
            + "Parameters: INDEX or RANGE\n"
            + "Example: " + COMMAND_WORD_FINISH + " 1 to 3";

    private static final int INVALID_INDEX = -1;
```
###### \java\seedu\typed\logic\commands\CompleteCommand.java
``` java
    /**
     * Returns a CommandResult with a message depending on the number of tasks completed.
     *
     * @param list
     *          used to store indices of tasks completed
     * @return CommandResult
     */
    private CommandResult commandResultBasedOnIndices(int startIndex, int endIndex) {
        int num = endIndex - startIndex + 1;
        if (num == 1) {
            String taskName = model.getFilteredTaskList().get(startIndex)
                                                         .getName().getValue();
            return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, taskName));
        } else {
            return new CommandResult(String.format(MESSAGE_COMPLETED_TASKS_SUCCESS, num));
        }
    }
```
###### \java\seedu\typed\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task identified using its last displayed index from the task
 * manager.
 */
public class DeleteCommand extends Command {
```
###### \java\seedu\typed\logic\commands\EditCommand.java
``` java
            int taskManagerIndex = model.getIndexOfTask(taskToEditCopy);
            model.updateTask(filteredTaskListIndex, editedTask);
            session.updateUndoRedoStacks(COMMAND_WORD_EDIT, taskManagerIndex, taskToEditCopy);
```
###### \java\seedu\typed\logic\commands\RedoCommand.java
``` java
/**
 * Redoes the previous undone command in the task manager.
 * Entering a new mutable command clears the stack of undone commands to redo.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD_REDO = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD_REDO + ": Redoes the previous undone command "
                                               + "in the current session.\n"
                                               + "Parameters: [NUMBER]\n"
                                               + "Example: " + COMMAND_WORD_REDO + " 2";
    public static final String MESSAGE_SUCCESS = "Redone successfully!";
    public static final String MESSAGE_ALL_SUCCESS = "Redone all successfully!";
    public static final String MESSAGE_SINGLE_SUCCESS = "Redone successfully 1 command!";
    public static final String MESSAGE_MULTIPLE_SUCCESS = "Redone successfully %1$s commands!";
    public static final String MESSAGE_PARTIAL_SUCCESS = "Redone successfully %1$s commands only!";
    public static final String MESSAGE_SINGLE_PARTIAL_SUCCESS = "Redone successfully 1 command only!";
    public static final String MESSAGE_NO_COMMAND_TO_REDO = "There is no undo to redo!";
    public static final String MESSAGE_ERROR = "Cannot redo previous undo!";

    private static final int ALL_NUM = -1;
    private static final int INVALID_INDEX = -1;

    private int numberOfCmdsToRedo;
    private String type;

    public RedoCommand() {
        numberOfCmdsToRedo = 1;
        type = "no number";
    }

    public RedoCommand(int num) {
        numberOfCmdsToRedo = num;
        if (num == ALL_NUM) {
            type = "all";
        } else {
            type = "number";
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;

        int maxNumberToRedo = session.getRedoStack().size();

        if (numberOfCmdsToRedo == ALL_NUM) {
            numberOfCmdsToRedo = maxNumberToRedo;
        }

        if (maxNumberToRedo == 0) {
            throw new CommandException(MESSAGE_NO_COMMAND_TO_REDO);
        }

        int actualNumberOfCmdsToRedo = numberOfCmdsToRedo;
        if (numberOfCmdsToRedo > maxNumberToRedo) {
            actualNumberOfCmdsToRedo = maxNumberToRedo;
        }

        for (int count = 0; count < actualNumberOfCmdsToRedo; count++) {
            executeRedoCommand();
        }

        switch (type) {

        case "no number":
            return new CommandResult(MESSAGE_SUCCESS);

        case "all":
            return new CommandResult(MESSAGE_ALL_SUCCESS);

        case "number":
            return commandResultBasedOnNumber(maxNumberToRedo);

        default:
            return new CommandResult(MESSAGE_SUCCESS);

        }
    }

    private CommandResult commandResultBasedOnNumber(int maxNumber) {

        int actualNumber = numberOfCmdsToRedo;
        if (numberOfCmdsToRedo > maxNumber) {
            actualNumber = maxNumber;
        }

        if (numberOfCmdsToRedo == 1) {
            return new CommandResult(MESSAGE_SINGLE_SUCCESS);
        } else if ((actualNumber < numberOfCmdsToRedo)
                   && (actualNumber == 1)) {
            return new CommandResult(MESSAGE_SINGLE_PARTIAL_SUCCESS);
        } else if (actualNumber < numberOfCmdsToRedo) {
            return new CommandResult(String.format(MESSAGE_PARTIAL_SUCCESS,
                                                   actualNumber));
        } else {
            return new CommandResult(String.format(MESSAGE_MULTIPLE_SUCCESS,
                                                   numberOfCmdsToRedo));
        }
    }


    @SuppressWarnings("unchecked")
    private void executeRedoCommand() throws CommandException {
        Optional<Triple<String, Integer, Object>> optionalTriple = session.popRedoStack();

        Triple<String, Integer, Object> toPush = optionalTriple.get();
        String command = toPush.getFirst();
        int index = toPush.getSecond();
        Object change = toPush.getThird();

        try {
            switch(command) {

            case AddCommand.COMMAND_WORD_ADD:
                model.addTask(index, (Task) change);
                toPush.setFirst(DeleteCommand.COMMAND_WORD_DELETE);
                session.updateUndoRedoStacks(COMMAND_WORD_REDO, INVALID_INDEX, toPush);
                break;

            case DeleteCommand.COMMAND_WORD_DELETE:
                TaskManager currTaskManager = new TaskManager(model.getTaskManager());
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setFirst(AddCommand.COMMAND_WORD_ADD);
                toPush.setThird(currTaskManager);
                session.updateUndoRedoStacks(COMMAND_WORD_REDO, INVALID_INDEX, toPush);
                break;

            case EditCommand.COMMAND_WORD_EDIT:
                Task currentTask = new TaskBuilder(model.getTaskAt(index)).build();
                toPush.setThird(currentTask);
                model.updateTaskForUndoRedo(index, (ReadOnlyTask) change);
                session.updateUndoRedoStacks(COMMAND_WORD_REDO, INVALID_INDEX, toPush);
                break;

            case ClearCommand.COMMAND_WORD_CLEAR:
                TaskManager currentTaskManager = new TaskManager(model.getTaskManager());
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setFirst(ClearCommand.COMMAND_WORD_UNCLEAR);
                toPush.setThird(currentTaskManager);
                session.updateUndoRedoStacks(COMMAND_WORD_REDO, INVALID_INDEX, toPush);
                break;

            case CompleteCommand.COMMAND_WORD_COMPLETE:
                TaskManager current = new TaskManager(model.getTaskManager());
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setFirst(CompleteCommand.COMMAND_WORD_UNCOMPLETE);
                toPush.setThird(current);
                session.updateUndoRedoStacks(COMMAND_WORD_REDO, INVALID_INDEX, toPush);
                break;

            default:
                break;

            }
        } catch (Exception e) {
            throw new CommandException(MESSAGE_ERROR);
        }
    }
}
```
###### \java\seedu\typed\logic\commands\UndoCommand.java
``` java
/**
 * Undoes an a mutable command entered in the task manager.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD_UNDO = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD_UNDO + ": Undoes the previous "
                                               + "add/delete/edit/clear command "
                                               + "in the current session.\n"
                                               + "Parameters: [NUMBER]\n"
                                               + "Example: " + COMMAND_WORD_UNDO + " 2";
    public static final String MESSAGE_SUCCESS = "Undone successfully!";
    public static final String MESSAGE_ALL_SUCCESS = "Undone all successfully!";
    public static final String MESSAGE_SINGLE_SUCCESS = "Undone successfully 1 command!";
    public static final String MESSAGE_MULTIPLE_SUCCESS = "Undone successfully %1$s commands!";
    public static final String MESSAGE_PARTIAL_SUCCESS = "Undone successfully %1$s commands only!";
    public static final String MESSAGE_SINGLE_PARTIAL_SUCCESS = "Redone successfully 1 command only!";
    public static final String MESSAGE_NO_PREV_COMMAND = "There is no command to undo!";
    public static final String MESSAGE_ERROR = "Cannot undo previous command!";

    private static final int ALL_NUM = -1;
    private static final int INVALID_INDEX = -1;

    private int numberOfCmdsToUndo;
    private String type;


    public UndoCommand() {
        numberOfCmdsToUndo = 1;
        type = "no number";
    }

    public UndoCommand(int num) {
        numberOfCmdsToUndo = num;
        if (num == ALL_NUM) {
            type = "all";
        } else {
            type = "number";
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;

        int maxNumberToUndo = session.getUndoStack().size();

        if (numberOfCmdsToUndo == ALL_NUM) {
            numberOfCmdsToUndo = maxNumberToUndo;
        }

        if (maxNumberToUndo == 0) {
            throw new CommandException(MESSAGE_NO_PREV_COMMAND);
        }

        int actualNumberOfCmdsToUndo = numberOfCmdsToUndo;
        if (numberOfCmdsToUndo > maxNumberToUndo) {
            actualNumberOfCmdsToUndo = maxNumberToUndo;
        }

        for (int count = 0; count < actualNumberOfCmdsToUndo; count++) {
            executeUndoCommand();
        }

        switch (type) {

        case "no number":
            return new CommandResult(MESSAGE_SUCCESS);

        case "all":
            return new CommandResult(MESSAGE_ALL_SUCCESS);

        case "number":
            return commandResultBasedOnNumber(maxNumberToUndo);

        default:
            return new CommandResult(MESSAGE_SUCCESS);

        }
    }

    private CommandResult commandResultBasedOnNumber(int maxNumber) {

        int actualNumber = numberOfCmdsToUndo;
        if (numberOfCmdsToUndo > maxNumber) {
            actualNumber = maxNumber;
        }

        if (numberOfCmdsToUndo == 1) {
            return new CommandResult(MESSAGE_SINGLE_SUCCESS);
        } else if ((actualNumber < numberOfCmdsToUndo)
                   && (actualNumber == 1)) {
            return new CommandResult(MESSAGE_SINGLE_PARTIAL_SUCCESS);
        } else if (actualNumber < numberOfCmdsToUndo) {
            return new CommandResult(String.format(MESSAGE_PARTIAL_SUCCESS,
                                                   actualNumber));
        } else {
            return new CommandResult(String.format(MESSAGE_MULTIPLE_SUCCESS,
                                                   numberOfCmdsToUndo));
        }
    }

    @SuppressWarnings("unchecked")
    private void executeUndoCommand() throws CommandException {
        Optional<Triple<String, Integer, Object>> optionalTriple = session.popUndoStack();

        Triple<String, Integer, Object> toPush = optionalTriple.get();
        String command = toPush.getFirst();
        int index = toPush.getSecond();
        Object change = toPush.getThird();

        try {
            switch(command) {

            case AddCommand.COMMAND_WORD_ADD:
                TaskManager currentTaskManager = new TaskManager(model.getTaskManager());
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setFirst(DeleteCommand.COMMAND_WORD_DELETE);
                toPush.setThird(currentTaskManager);
                session.updateUndoRedoStacks(COMMAND_WORD_UNDO, INVALID_INDEX, toPush);
                break;

            case DeleteCommand.COMMAND_WORD_DELETE:
                model.deleteTaskAt(index);
                toPush.setFirst(AddCommand.COMMAND_WORD_ADD);
                session.updateUndoRedoStacks(COMMAND_WORD_UNDO, INVALID_INDEX, toPush);
                break;

            case EditCommand.COMMAND_WORD_EDIT:
                Task currentTask = new TaskBuilder(model.getTaskAt(index)).build();
                toPush.setThird(currentTask);
                model.updateTaskForUndoRedo(index, (ReadOnlyTask) change);
                session.updateUndoRedoStacks(COMMAND_WORD_UNDO, INVALID_INDEX, toPush);
                break;

            case ClearCommand.COMMAND_WORD_UNCLEAR:
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setFirst(ClearCommand.COMMAND_WORD_CLEAR);
                toPush.setThird(new TaskManager());
                session.updateUndoRedoStacks(COMMAND_WORD_UNDO, INVALID_INDEX, toPush);
                break;

            case CompleteCommand.COMMAND_WORD_UNCOMPLETE:
                TaskManager currTaskManager = new TaskManager(model.getTaskManager());
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setFirst(CompleteCommand.COMMAND_WORD_COMPLETE);
                toPush.setThird(currTaskManager);
                session.updateUndoRedoStacks(COMMAND_WORD_UNDO, INVALID_INDEX, toPush);
                break;

            default:
                break;

            }
        } catch (Exception e) {
            throw new CommandException(MESSAGE_ERROR);
        }
    }
}


```
###### \java\seedu\typed\logic\commands\util\IndexRangeUtil.java
``` java
public class IndexRangeUtil {

    private static final String RANGE_TO_REGEX = "[1-9]+[0-9]*\\s+[t]{1}[o]{1}\\s+[1-9]+[0-9]*";
    private static final String RANGE_NUMBERS_ONLY_REGEX = "[1-9]+[0-9]*\\s+[1-9]+[0-9]*";
    private static final String RANGE_SINGLE_NUMBER_REGEX = "[1-9]+[0-9]*";
    private static final String RANGE_DASH_REGEX = "[1-9]+[0-9]*\\s+[\\-]\\s+[1-9]+[0-9]*";

    private static final String TO_REGEX = "\\s+[t]{1}[o]{1}\\s+";
    private static final String SPACE_REGEX = "\\s+";
    private static final String DASH_REGEX = "\\s+[\\-]\\s+";

    private int startIndex;
    private int endIndex;
    private boolean isValid;

    public IndexRangeUtil(String range) {
        String trimmedRange = range.trim();
        if (trimmedRange.matches(RANGE_TO_REGEX)) {
            handleToRange(trimmedRange);
        } else if (trimmedRange.matches(RANGE_NUMBERS_ONLY_REGEX)
                   || trimmedRange.matches(RANGE_SINGLE_NUMBER_REGEX)) {
            handleNumbersOnlyRange(trimmedRange);
        } else if (trimmedRange.matches(RANGE_DASH_REGEX)) {
            handleDashRange(trimmedRange);
        } else {
            isValid = false;
            startIndex = -1;
            endIndex = -1;
        }

    }

    public boolean isValid() {
        return isValid;
    }

    public int getStartIndex() {
        return startIndex;
    }

    public int getEndIndex() {
        return endIndex;
    }

    private void handleToRange(String range) {
        String[] indices = range.split(TO_REGEX);
        if (indices.length == 2) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = Integer.parseInt(indices[1]);
        } else {
            startIndex = -1;
            endIndex = -1;
        }

        if ((startIndex <= 0) || (startIndex > endIndex)) {
            isValid = false;
        } else {
            isValid = true;
        }
    }

    private void handleNumbersOnlyRange(String range) {
        String[] indices = range.split(SPACE_REGEX);
        if (indices.length == 2) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = Integer.parseInt(indices[1]);
        } else if (indices.length == 1) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = startIndex;
        } else {
            startIndex = -1;
            endIndex = -1;
        }

        if ((startIndex <= 0) || (startIndex > endIndex)) {
            isValid = false;
        } else {
            isValid = true;
        }
    }

    private void handleDashRange(String range) {
        String[] indices = range.split(DASH_REGEX);
        if (indices.length == 2) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = Integer.parseInt(indices[1]);
        } else {
            startIndex = -1;
            endIndex = -1;
        }

        if ((startIndex <= 0) || (startIndex > endIndex)) {
            isValid = false;
        } else {
            isValid = true;
        }
    }
}
```
###### \java\seedu\typed\logic\commands\util\UndoRedoUtil.java
``` java
/**
 * Helps to manage Undo and Redo stacks in the Session class.
 *
 */
public class UndoRedoUtil {

    public static Optional<Triple<String, Integer, Object>> pop(Stack<Triple<String, Integer, Object>> stack) {
        if (!stack.empty()) {
            return Optional.of(stack.pop());
        } else {
            return Optional.empty();
        }
    }

    public static void clear(Stack<Triple<String, Integer, Object>> stack) {
        stack.clear();
    }

    public static boolean isEmpty(Stack<Triple<String, Integer, Object>> stack) {
        return stack.empty();
    }

    @SuppressWarnings("unchecked")
    public static void update(Stack<Triple<String, Integer, Object>> undoStack,
                              Stack<Triple<String, Integer, Object>> redoStack,
                              String command, Integer index, Object toChange) {

        Triple<String, Integer, Object> toPush = new Triple<String, Integer, Object>(command,
                                                                                     index,
                                                                                     toChange);
        switch(command) {

        case UndoCommand.COMMAND_WORD_UNDO:
            toPush = (Triple<String, Integer, Object>) toChange;
            redoStack.push(toPush);
            break;

        case RedoCommand.COMMAND_WORD_REDO:
            toPush = (Triple<String, Integer, Object>) toChange;
            undoStack.push(toPush);
            break;

        case AddCommand.COMMAND_WORD_ADD:
            redoStack.clear();
            toPush.setFirst(DeleteCommand.COMMAND_WORD_DELETE);
            undoStack.push(toPush);
            break;

        case DeleteCommand.COMMAND_WORD_DELETE:
            redoStack.clear();
            toPush.setFirst(AddCommand.COMMAND_WORD_ADD);
            undoStack.push(toPush);
            break;

        case EditCommand.COMMAND_WORD_EDIT:
            redoStack.clear();
            undoStack.push(toPush);
            break;

        case ClearCommand.COMMAND_WORD_CLEAR:
            redoStack.clear();
            toPush.setFirst(ClearCommand.COMMAND_WORD_UNCLEAR);
            undoStack.push(toPush);
            break;

        case CompleteCommand.COMMAND_WORD_COMPLETE:
            redoStack.clear();
            toPush.setFirst(CompleteCommand.COMMAND_WORD_UNCOMPLETE);
            undoStack.push(toPush);
            break;

        case FindCommand.COMMAND_WORD_FIND:
            break;

        case HelpCommand.COMMAND_WORD_HELP:
            break;

        case ListCommand.COMMAND_WORD_LIST:
            break;

        case ExitCommand.COMMAND_WORD_EXIT:
            break;

        default:
            break;
        }
    }

}
```
###### \java\seedu\typed\logic\parser\DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        /* Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());*/

        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("all")) {
            return new DeleteCommand();
        }

        IndexRangeUtil range = new IndexRangeUtil(args);
        if (range.isValid()) {
            return new DeleteCommand(range.getStartIndex(),
                    range.getEndIndex());
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    DeleteCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\typed\logic\parser\RedoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RedoCommand object
 */
public class RedoCommandParser {

    public static final String POSITIVE_INTEGER_REGEX = "[1-9]+[0-9]*";
    /**
     * Parses the given {@code String} of arguments in the context of the
     * RedoCommand and returns an RedoCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("")) {
            return new RedoCommand();
        } else if (trimmedArgs.equals("all")) {
            return new RedoCommand(-1);
        } else if (trimmedArgs.matches(POSITIVE_INTEGER_REGEX)) {
            int num = Integer.parseInt(trimmedArgs);
            return new RedoCommand(num);
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                      RedoCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\typed\logic\parser\UndoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new UndoCommand object
 */
public class UndoCommandParser {

    public static final String POSITIVE_INTEGER_REGEX = "[1-9]+[0-9]*";
    /**
     * Parses the given {@code String} of arguments in the context of the
     * UndoCommand and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("")) {
            return new UndoCommand();
        } else if (trimmedArgs.equals("all")) {
            return new UndoCommand(-1);
        } else if (trimmedArgs.matches(POSITIVE_INTEGER_REGEX)) {
            int num = Integer.parseInt(trimmedArgs);
            return new UndoCommand(num);
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                      UndoCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\typed\model\Model.java
``` java
    Task getTaskAt(int index);
```
###### \java\seedu\typed\model\Model.java
``` java
    int getIndexOfTask(Task task) throws TaskNotFoundException;
```
###### \java\seedu\typed\model\Model.java
``` java
    /** Adds the given task at the specified index. */
    void addTask(int index, Task task) throws DuplicateTaskException;
```
###### \java\seedu\typed\model\Model.java
``` java
    void updateTaskForUndoRedo(int index, ReadOnlyTask editedTask)
            throws DuplicateTaskException, IllegalValueException;
```
###### \java\seedu\typed\model\Model.java
``` java
    /** Copies tasks over into current TaskManager. **/
    void copyData(ReadOnlyTaskManager newData) throws IllegalValueException;
```
###### \java\seedu\typed\model\Model.java
``` java
    void uncompleteTaskAtForUndo(int taskManagerIndex)
            throws DuplicateTaskException, IllegalValueException;

    void completeTaskAtForRedo(int taskManagerIndex)
            throws DuplicateTaskException, IllegalValueException;

    void completeTasksAndStoreIndices(int startIndex, int endIndex, ArrayList<Integer> list)
            throws DuplicateTaskException, IllegalValueException;

    void deleteTasks(int startIndex, int endIndex)
            throws TaskNotFoundException, IllegalValueException;

    void deleteTaskAt(int index);

    void uncompleteTasksAtForUndo(ArrayList<Integer> list)
            throws DuplicateTaskException, IllegalValueException;

    void completeTasksAtForRedo(ArrayList<Integer> list)
            throws DuplicateTaskException, IllegalValueException;

    void deleteTasksForRedo(ArrayList<Pair<Integer, Task>> list)
            throws DuplicateTaskException;

    int getNumberUncompletedEvents();

    int getNumberUncompletedDeadlines();

    int getNumberUncompletedFloatingTasks();

```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public int getNumberOverdue() {
        return taskManager.getNumberOverdue();
    }

    @Override
    public int getIndexOfTask(Task task) throws TaskNotFoundException {
        return taskManager.getIndexOf(task);
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public Task getTaskAt(int index) {
        return taskManager.getTaskAt(index);
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void addTask(int index, Task task) throws DuplicateTaskException {
        taskManager.addTask(index, task);
        indicateTaskManagerChanged();
    }

```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTaskAt(int index) {
        taskManager.removeTaskAt(index);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTasks(int startIndex, int endIndex)
            throws TaskNotFoundException, IllegalValueException {
        int num = endIndex - startIndex + 1;
        if (num == 1) {
            int taskManagerIndex = filteredTasks.getSourceIndex(startIndex);
            taskManager.removeTaskAt(taskManagerIndex);
        } else {
            int[] listOfIndices = new int[num];
            for (int i = 0; i < num; i++) {
                int taskManagerIndex = filteredTasks.getSourceIndex(startIndex + i);
                listOfIndices[i] = taskManagerIndex;
            }
            TaskManager newTaskManager = new TaskManager();
            newTaskManager.copyDataExcludingIndices(taskManager, listOfIndices);
            taskManager.resetData(newTaskManager);
        }

        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void deleteTasksForRedo(ArrayList<Pair<Integer, Task>> list)
            throws DuplicateTaskException {
        for (int curr = 0; curr < list.size(); curr++) {
            Pair<Integer, Task> indexAndTask = list.get(curr);
            int index = indexAndTask.getFirst();
            taskManager.removeTaskAt(index);
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void completeTasks(int startIndex, int endIndex)
            throws DuplicateTaskException, IllegalValueException {
        for (int curr = startIndex; curr <= endIndex; curr++) {
            int taskManagerIndex = filteredTasks.getSourceIndex(curr);
            taskManager.completeTaskAt(taskManagerIndex);
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void completeTasksAndStoreIndices(int startIndex, int endIndex,
            ArrayList<Integer> list) throws DuplicateTaskException, IllegalValueException {
        for (int curr = startIndex; curr <= endIndex; curr++) {
            int taskManagerIndex = filteredTasks.getSourceIndex(curr);
            addTaskIndexToListIfUncompleted(taskManagerIndex, list);
            taskManager.completeTaskAt(taskManagerIndex);
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    private void addTaskIndexToListIfUncompleted(int taskIndex, ArrayList<Integer> list) {
        if (!taskManager.getTaskAt(taskIndex).getIsCompleted()) {
            list.add(taskIndex);
        }
    }

    @Override
    public synchronized void uncompleteTaskAtForUndo(int taskManagerIndex)
            throws DuplicateTaskException {
        taskManager.uncompleteTaskAt(taskManagerIndex);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void uncompleteTasksAtForUndo(ArrayList<Integer> list)
            throws DuplicateTaskException {
        for (int curr = 0; curr < list.size(); curr++) {
            taskManager.uncompleteTaskAt(list.get(curr));
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void completeTasksAtForRedo(ArrayList<Integer> list)
            throws DuplicateTaskException, IllegalValueException {
        for (int curr = 0; curr < list.size(); curr++) {
            taskManager.completeTaskAt(list.get(curr));
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void completeTaskAtForRedo(int taskManagerIndex)
            throws DuplicateTaskException, IllegalValueException {
        taskManager.completeTaskAt(taskManagerIndex);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public void updateTaskForUndoRedo(int index, ReadOnlyTask editedTask)
            throws DuplicateTaskException, IllegalValueException {
        assert editedTask != null;

        taskManager.updateTask(index, editedTask);
        taskManager.sort();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public void copyData(ReadOnlyTaskManager newData) throws IllegalValueException {
        taskManager.copyData(newData);
        // updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\task\DateTime.java
``` java
    public DateTime getDuplicate() {
        LocalDateTime copy = localDateTime.plusYears(0);
        return new DateTime(copy);
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public int indexOf(Task task) throws TaskNotFoundException {
        int index = internalList.indexOf(task);
        if (index == -1) {
            throw new TaskNotFoundException();
        } else {
            return index;
        }
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public Task getTaskAt(int index) {
        return internalList.get(index);
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public void add(int index, Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;

        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(index, toAdd);
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public void uncompleteTaskAt(int index) throws DuplicateTaskException {
        Task taskToUncomplete = internalList.get(index);
        if (taskToUncomplete.getIsCompleted()) {
            taskToUncomplete.setIsCompleted(false);
        }
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public void remove(int index) {
        assert ((index >= 0)
                && (index < internalList.size()));
        internalList.remove(index);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public void copyData(ReadOnlyTaskManager newData) {
        assert newData != null;
        try {
            ObservableList<ReadOnlyTask> tasksToCopy = newData.getTaskList();
            Iterator<ReadOnlyTask> iterator = tasksToCopy.iterator();
            while (iterator.hasNext()) {
                ReadOnlyTask toCopy = iterator.next();
                addTask((Task) toCopy);
            }
        } catch (DuplicateTaskException dte) {
            assert false : "Task manager to copy from should not contain duplicate tasks.";
        }
        try {
            ObservableList<Tag> tagsToCopy = newData.getTagList();
            Iterator<Tag> iterator = tagsToCopy.iterator();
            while (iterator.hasNext()) {
                Tag toCopy = iterator.next();
                addTag(toCopy);
            }
        } catch (DuplicateTagException dte) {
            assert false : "Task manager to copy from should not contain duplicate tags.";
        }
        syncMasterTagListWith(tasks);
    }

    public void copyDataExcludingIndices(ReadOnlyTaskManager newData, int[] indicesList) {
        assert newData != null;
        assert indicesList != null;
        assert indicesList.length > 0;
        try {
            int listCount = 0;
            int iterCount = 0;
            int index = indicesList[0];

            ObservableList<ReadOnlyTask> tasksToCopy = newData.getTaskList();
            Iterator<ReadOnlyTask> iterator = tasksToCopy.iterator();
            while (iterator.hasNext()) {
                if (listCount < indicesList.length) {
                    index = indicesList[listCount];
                }
                ReadOnlyTask toCopy = iterator.next();
                if (index != iterCount) {
                    Task toAdd = new TaskBuilder(toCopy).build();
                    addTask(toAdd);
                } else {
                    listCount++;
                }
                iterCount++;
            }
        } catch (DuplicateTaskException e) {
            assert false : "Task manager to copy from should not contain duplicate tasks.";
        } catch (IllegalValueException ive) {
            assert false : "Task manager to copy from should not contain illegal task values.";
        }
        try {
            int listCount = 0;
            int iterCount = 0;
            int index = indicesList[0];

            ObservableList<Tag> tagsToCopy = newData.getTagList();
            Iterator<Tag> iterator = tagsToCopy.iterator();
            while (iterator.hasNext()) {
                if (listCount < indicesList.length) {
                    index = indicesList[listCount];
                }
                Tag toCopy = iterator.next();
                if (index != iterCount) {
                    addTag(toCopy);
                } else {
                    listCount++;
                }
                iterCount++;
            }
        } catch (DuplicateTagException e) {
            assert false : "Task manager to copy from should not contain duplicate tags.";
        }
        syncMasterTagListWith(tasks);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public void addTask(int index, Task task) throws DuplicateTaskException {
        syncMasterTagListWith(task);
        tasks.add(index, task);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public int getIndexOf(Task task) throws TaskNotFoundException {
        return tasks.indexOf(task);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public Task getTaskAt(int index) {
        return tasks.getTaskAt(index);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public void uncompleteTaskAt(int taskManagerIndex) throws DuplicateTaskException {
        tasks.uncompleteTaskAt(taskManagerIndex);
    }
```
###### \java\seedu\typed\schedule\DayInMonthTE.java
``` java
    @Override
    public TimeExpression getDuplicate() {
        return new DayInMonthTE(weekCount, dayIndex);
    }
```
###### \java\seedu\typed\schedule\DifferenceTE.java
``` java

```
###### \java\seedu\typed\schedule\IntersectionTE.java
``` java
    @Override
    public TimeExpression getDuplicate() {
        IntersectionTE copy = new IntersectionTE();
        for (int i = 0; i < elements.size(); i++) {
            copy.addTE(elements.get(i).getDuplicate());
        }
        return copy;
    }
```
###### \java\seedu\typed\schedule\RangeEachYearTE.java
``` java
    @Override
    public TimeExpression getDuplicate() {
        return new RangeEachYearTE(startMonth, endMonth, startDay, endDay);
    }
```
###### \java\seedu\typed\schedule\ScheduleElement.java
``` java
    @Override
    public ScheduleElement getDuplicate() {
        DateTime dateCopy = null;
        DateTime startDateCopy = null;
        DateTime endDateCopy = null;
        TimeExpression teCopy = null;

        if (date != null) {
            dateCopy = date.getDuplicate();
        }
        if (startDate != null) {
            startDateCopy = startDate.getDuplicate();
        }
        if (endDate != null) {
            endDateCopy = endDate.getDuplicate();
        }
        if (te != null) {
            teCopy = te.getDuplicate();
        }

        return new ScheduleElement(dateCopy,
                                   startDateCopy,
                                   endDateCopy,
                                   teCopy,
                                   rule);
    }
```
###### \java\seedu\typed\schedule\TimeExpression.java
``` java
    public TimeExpression getDuplicate();
```
###### \java\seedu\typed\schedule\UnionTE.java
``` java
    @Override
    public TimeExpression getDuplicate() {
        UnionTE copy = new UnionTE();
        for (int i = 0; i < elements.size(); i++) {
            copy.addTE(elements.get(i).getDuplicate());
        }
        return copy;
    }
```
###### \java\seedu\typed\storage\temp\Session.java
``` java
/**
 * Keeps track of commands to undo and redo in a session.
 * Keeps track of history of commands entered
 *
 */

public class Session {

    private Stack<Triple<String, Integer, Object>> undoStack;
    private Stack<Triple<String, Integer, Object>> redoStack;

    public Session() {
        // this.history = new HistoryUtil();
        this.undoStack = new Stack<Triple<String, Integer, Object>>();
        this.redoStack = new Stack<Triple<String, Integer, Object>>();
    }

    /*
    public void updateAllCommandsHistory(String command) {
        history.addCommand(command);
    }

    public void updateValidCommandsHistory(String command) {
        history.addValidCommand(command);
    }

    public ArrayList<String> getAllCommandsHistory() {
        return history.getAllCommandsHistory();
    }

    public ArrayList<String> getValidCommandsHistory() {
        return history.getValidCommandsHistory();
    }

    public void listAllCommandsHistory() {
        history.listAllCommands();
    }

    public void listValidCommandsHistory() {
        history.listValidCommands();
    }
    public void clearHistory() {
        history.clear();
    }*/

    public Stack<Triple<String, Integer, Object>> getUndoStack() {
        return undoStack;
    }

    public Stack<Triple<String, Integer, Object>> getRedoStack() {
        return redoStack;
    }

    public void updateUndoRedoStacks(String command, Integer index, Object toChange) {
        UndoRedoUtil.update(undoStack, redoStack, command, index, toChange);
    }

    public Optional<Triple<String, Integer, Object>> popUndoStack() {
        return UndoRedoUtil.pop(undoStack);
    }

    public Optional<Triple<String, Integer, Object>> popRedoStack() {
        return UndoRedoUtil.pop(redoStack);
    }
}
```
###### \java\seedu\typed\ui\CommandBox.java
``` java
    private void updateCommandHistory(String command) {
        if (!command.trim().equals("")) {
            commandHistory.add(command);
        }
    }

    private void resetPointer() {
        pointer = commandHistory.size();
    }

    private boolean canUpPointer() {

        if (pointer == 0) {
            return false;
        }

        if (pointer > 0) {
            pointer--;
        }

        if (pointer < commandHistory.size()) {
            return true;
        } else {
            return false;
        }
    }

    private boolean canDownPointer() {
        if (pointer < (commandHistory.size() - 1)) {
            pointer++;
            return true;
        } else {
            return false;
        }
    }

    private void handleUpKey() {
        if (canUpPointer()) {
            String commandToShow = getCommandFromHistory();
            commandTextField.setText(commandToShow);
            setCaretToEnd();
        } else {
            setCaretAtOriginal();
        }
    }

    private void handleDownKey() {
        if (canDownPointer()) {
            String commandToShow = getCommandFromHistory();
            commandTextField.setText(commandToShow);
            setCaretToEnd();
        } else {
            resetPointer();
            commandTextField.clear();
        }
    }

    private String getCommandFromHistory() {
        return commandHistory.get(pointer);
    }

    private void setCaretToEnd() {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                commandTextField.end();
            }
        });
    }

    private void setCaretAtOriginal() {
        int originalPosition = commandTextField.getCaretPosition();
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                commandTextField.positionCaret(originalPosition);
            }
        });
    }
```
