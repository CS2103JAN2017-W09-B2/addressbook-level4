# A0143853A
###### \java\seedu\typed\commons\util\Pair.java
``` java
/**
 * Stores two items.
 */

public class Pair<F, S> {
    private F first;
    private S second;

    public Pair(F first, S second) {
        this.first = first;
        this.second = second;
    }

    public F getFirst() {
        return first;
    }

    public S getSecond() {
        return second;
    }

    public void setFirst(F first) {
        this.first = first;
    }

    public void setSecond(S second) {
        this.second = second;
    }


    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj instanceof Pair) {
            @SuppressWarnings("unchecked")
            Pair<F, S> pair = (Pair<F, S>) obj;
            return first.equals(pair.getFirst())
                   && second.equals(pair.getSecond());
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\typed\commons\util\TripleUtil.java
``` java
/**
 * Stores three items.
 */

public class TripleUtil<F, S, T> {
    private F first;
    private S second;
    private T third;

    public TripleUtil(F first, S second, T third) {
        this.first = first;
        this.second = second;
        this.third = third;
    }

    public F getFirst() {
        return first;
    }

    public S getSecond() {
        return second;
    }

    public T getThird() {
        return third;
    }

    public void setFirst(F first) {
        this.first = first;
    }

    public void setSecond(S second) {
        this.second = second;
    }

    public void setThird(T third) {
        this.third = third;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj instanceof TripleUtil) {
            @SuppressWarnings("unchecked")
            TripleUtil<F, S, T> triple = (TripleUtil<F, S, T>) obj;
            return first.equals(triple.getFirst())
                   && second.equals(triple.getSecond())
                   && third.equals(triple.getThird());
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\typed\logic\commands\AddCommand.java
``` java
            model.addTask(0, toAdd);
            model.getTaskManager().printData();
            session.updateUndoRedoStacks(CommandTypeUtil.TYPE_ADD_TASK, 0, toAdd);
            session.updateValidCommandsHistory(commandText);
```
###### \java\seedu\typed\logic\commands\ClearCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;

        TaskManager oldTaskManager = new TaskManager();
        oldTaskManager.copyData(model.getTaskManager());
        try {
            model.resetData(new TaskManager());
        } catch (IllegalValueException e) {
            throw new CommandException(MESSAGE_FAILURE);
        }
        session.updateUndoRedoStacks(CommandTypeUtil.TYPE_CLEAR, -1, oldTaskManager);
        session.updateValidCommandsHistory(commandText);
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
```
###### \java\seedu\typed\logic\commands\CompleteCommand.java
``` java
    private CommandResult commandResultBasedOnIndicesList(ArrayList<Integer> list) {
        if (list.size() == 1) {
            int taskIndex = list.get(0);
            String taskName = model.getTaskAt(taskIndex).getName().getValue();
            return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, taskName));
        } else {
            return new CommandResult(String.format(MESSAGE_COMPLETED_TASKS_SUCCESS, list.size()));
        }
    }
```
###### \java\seedu\typed\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task identified using its last displayed index from the task
 * manager.
 */
public class DeleteCommand extends Command {
```
###### \java\seedu\typed\logic\commands\EditCommand.java
``` java
            int index = model.getIndexOfTask(taskToEditCopy);
            model.updateTask(filteredTaskListIndex, editedTask);
            session.updateUndoRedoStacks(CommandTypeUtil.TYPE_EDIT_TASK, index, taskToEditCopy);
            session.updateValidCommandsHistory(commandText);
```
###### \java\seedu\typed\logic\commands\HistoryCommand.java
``` java
/**
 * Lists all past successful commands executed in the task manager in the current session to the user.
 */
public class HistoryCommand extends Command {

```
###### \java\seedu\typed\logic\commands\RedoCommand.java
``` java
/**
 * Redoes the previous undone command in the task manager.
 * Entering a new mutable command clears the stack of undone commands to redo.
 */
public class RedoCommand extends Command {

    public static final String REDO_COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = REDO_COMMAND_WORD + ": Redoes the previous undone command "
                                               + "in the current session.\n"
                                               + "Parameters: [NUMBER]\n"
                                               + "Example: " + REDO_COMMAND_WORD + " 2";
    public static final String MESSAGE_SUCCESS = "Redone successfully!";
    public static final String MESSAGE_ALL_SUCCESS = "Redone all successfully!";
    public static final String MESSAGE_SINGLE_SUCCESS = "Redone successfully 1 command!";
    public static final String MESSAGE_MULTIPLE_SUCCESS = "Redone successfully %1$s commands!";
    public static final String MESSAGE_PARTIAL_SUCCESS = "Redone successfully %1$s commands only!";
    public static final String MESSAGE_SINGLE_PARTIAL_SUCCESS = "Redone successfully 1 command only!";
    public static final String MESSAGE_NO_COMMAND_TO_REDO = "There is no undo to redo!";
    public static final String MESSAGE_ERROR = "Cannot redo previous undo!";

    private int numberOfCmdsToRedo;
    private String type;

    public RedoCommand() {
        numberOfCmdsToRedo = 1;
        type = "no number";
    }

    public RedoCommand(int num) {
        numberOfCmdsToRedo = num;
        if (num == -1) {
            type = "all";
        } else {
            type = "number";
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;

        int maxNumberToRedo = session.getRedoStack().size();

        if (numberOfCmdsToRedo == -1) {
            numberOfCmdsToRedo = maxNumberToRedo;
        }

        if (maxNumberToRedo == 0) {
            throw new CommandException(MESSAGE_NO_COMMAND_TO_REDO);
        }

        int actualNumberOfCmdsToRedo = numberOfCmdsToRedo;
        if (numberOfCmdsToRedo > maxNumberToRedo) {
            actualNumberOfCmdsToRedo = maxNumberToRedo;
        }

        for (int count = 0; count < actualNumberOfCmdsToRedo; count++) {
            executeRedoCommand();
        }

        session.updateValidCommandsHistory(commandText);
        switch (type) {

        case "no number":
            return new CommandResult(MESSAGE_SUCCESS);

        case "all":
            return new CommandResult(MESSAGE_ALL_SUCCESS);

        case "number":
            return commandResultBasedOnNumber(maxNumberToRedo);

        default:
            return new CommandResult(MESSAGE_SUCCESS);

        }
    }

    private CommandResult commandResultBasedOnNumber(int maxNumber) {

        int actualNumber = numberOfCmdsToRedo;
        if (numberOfCmdsToRedo > maxNumber) {
            actualNumber = maxNumber;
        }

        if (numberOfCmdsToRedo == 1) {
            return new CommandResult(MESSAGE_SINGLE_SUCCESS);
        } else if ((actualNumber < numberOfCmdsToRedo)
                   && (actualNumber == 1)) {
            return new CommandResult(MESSAGE_SINGLE_PARTIAL_SUCCESS);
        } else if (actualNumber < numberOfCmdsToRedo) {
            return new CommandResult(String.format(MESSAGE_PARTIAL_SUCCESS,
                                                   actualNumber));
        } else {
            return new CommandResult(String.format(MESSAGE_MULTIPLE_SUCCESS,
                                                   numberOfCmdsToRedo));
        }
    }


    @SuppressWarnings("unchecked")
    private void executeRedoCommand() throws CommandException {
        Optional<TripleUtil<String, Integer, Object>> optionalTriple = session.popRedoStack();

        TripleUtil<String, Integer, Object> toPush = optionalTriple.get();
        String command = toPush.getFirst();
        int index = toPush.getSecond();
        Object change = toPush.getThird();

        try {
            switch(command) {

            case CommandTypeUtil.TYPE_ADD_TASK:
                model.addTask(index, (Task) change);
                toPush.setFirst(CommandTypeUtil.TYPE_DELETE_TASK);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_REDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_DELETE_TASK:
                ArrayList<Pair<Integer, Task>> listOfIndicesAndTasks = (ArrayList<Pair<Integer, Task>>) change;
                model.deleteTasksForRedo(listOfIndicesAndTasks);
                toPush.setFirst(CommandTypeUtil.TYPE_ADD_TASK);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_REDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_EDIT_TASK:
                Task currentTask = new TaskBuilder(model.getTaskAt(index)).build();
                toPush.setThird(currentTask);
                model.updateTaskForUndoRedo(index, (ReadOnlyTask) change);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_REDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_CLEAR:
                TaskManager currentTaskManager = new TaskManager();
                currentTaskManager.copyData(model.getTaskManager());
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setThird(currentTaskManager);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_REDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_COMPLETE:
                ArrayList<Integer> listOfIndices = (ArrayList<Integer>) toPush.getThird();
                model.completeTasksAtForRedo(listOfIndices);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_REDO, -1, toPush);
                break;

            default:
                break;

            }
        } catch (Exception e) {
            throw new CommandException(MESSAGE_ERROR);
        }
    }
}
```
###### \java\seedu\typed\logic\commands\UndoCommand.java
``` java
/**
 * Undoes an a mutable command entered in the task manager.
 */
public class UndoCommand extends Command {

    public static final String UNDO_COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = UNDO_COMMAND_WORD + ": Undoes the previous "
                                               + "add/delete/edit/clear command "
                                               + "in the current session.\n"
                                               + "Parameters: [NUMBER]\n"
                                               + "Example: " + UNDO_COMMAND_WORD + " 2";
    public static final String MESSAGE_SUCCESS = "Undone successfully!";
    public static final String MESSAGE_ALL_SUCCESS = "Undone all successfully!";
    public static final String MESSAGE_SINGLE_SUCCESS = "Undone successfully 1 command!";
    public static final String MESSAGE_MULTIPLE_SUCCESS = "Undone successfully %1$s commands!";
    public static final String MESSAGE_PARTIAL_SUCCESS = "Undone successfully %1$s commands only!";
    public static final String MESSAGE_SINGLE_PARTIAL_SUCCESS = "Redone successfully 1 command only!";
    public static final String MESSAGE_NO_PREV_COMMAND = "There is no command to undo!";
    public static final String MESSAGE_ERROR = "Cannot undo previous command!";

    private int numberOfCmdsToUndo;
    private String type;


    public UndoCommand() {
        numberOfCmdsToUndo = 1;
        type = "no number";
    }

    public UndoCommand(int num) {
        numberOfCmdsToUndo = num;
        if (num == -1) {
            type = "all";
        } else {
            type = "number";
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;

        int maxNumberToUndo = session.getUndoStack().size();

        if (numberOfCmdsToUndo == -1) {
            numberOfCmdsToUndo = maxNumberToUndo;
        }

        if (maxNumberToUndo == 0) {
            throw new CommandException(MESSAGE_NO_PREV_COMMAND);
        }

        int actualNumberOfCmdsToUndo = numberOfCmdsToUndo;
        if (numberOfCmdsToUndo > maxNumberToUndo) {
            actualNumberOfCmdsToUndo = maxNumberToUndo;
        }

        for (int count = 0; count < actualNumberOfCmdsToUndo; count++) {
            executeUndoCommand();
        }

        session.updateValidCommandsHistory(commandText);
        switch (type) {

        case "no number":
            return new CommandResult(MESSAGE_SUCCESS);

        case "all":
            return new CommandResult(MESSAGE_ALL_SUCCESS);

        case "number":
            return commandResultBasedOnNumber(maxNumberToUndo);

        default:
            return new CommandResult(MESSAGE_SUCCESS);

        }
    }

    private CommandResult commandResultBasedOnNumber(int maxNumber) {

        int actualNumber = numberOfCmdsToUndo;
        if (numberOfCmdsToUndo > maxNumber) {
            actualNumber = maxNumber;
        }

        if (numberOfCmdsToUndo == 1) {
            return new CommandResult(MESSAGE_SINGLE_SUCCESS);
        } else if ((actualNumber < numberOfCmdsToUndo)
                   && (actualNumber == 1)) {
            return new CommandResult(MESSAGE_SINGLE_PARTIAL_SUCCESS);
        } else if (actualNumber < numberOfCmdsToUndo) {
            return new CommandResult(String.format(MESSAGE_PARTIAL_SUCCESS,
                                                   actualNumber));
        } else {
            return new CommandResult(String.format(MESSAGE_MULTIPLE_SUCCESS,
                                                   numberOfCmdsToUndo));
        }
    }

    @SuppressWarnings("unchecked")
    private void executeUndoCommand() throws CommandException {
        Optional<TripleUtil<String, Integer, Object>> optionalTriple = session.popUndoStack();

        TripleUtil<String, Integer, Object> toPush = optionalTriple.get();
        String command = toPush.getFirst();
        int index = toPush.getSecond();
        Object change = toPush.getThird();

        try {
            switch(command) {

            case CommandTypeUtil.TYPE_ADD_TASK:
                ArrayList<Pair<Integer, Task>> listOfIndicesAndTasks = (ArrayList<Pair<Integer, Task>>) change;
                model.addTasksForUndo(listOfIndicesAndTasks);
                toPush.setFirst(CommandTypeUtil.TYPE_DELETE_TASK);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_UNDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_DELETE_TASK:
                model.deleteTaskAt(index);
                toPush.setFirst(CommandTypeUtil.TYPE_ADD_TASK);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_UNDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_EDIT_TASK:
                Task currentTask = new TaskBuilder(model.getTaskAt(index)).build();
                toPush.setThird(currentTask);
                model.updateTaskForUndoRedo(index, (ReadOnlyTask) change);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_UNDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_CLEAR:
                model.resetData((ReadOnlyTaskManager) change);
                toPush.setThird(new TaskManager());
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_UNDO, -1, toPush);
                break;

            case CommandTypeUtil.TYPE_COMPLETE:
                ArrayList<Integer> listOfIndices = (ArrayList<Integer>) change;
                model.uncompleteTasksAtForUndo(listOfIndices);
                session.updateUndoRedoStacks(CommandTypeUtil.TYPE_UNDO, -1, toPush);
                break;

            default:
                break;

            }
        } catch (Exception e) {
            throw new CommandException(MESSAGE_ERROR);
        }
    }
}


```
###### \java\seedu\typed\logic\commands\util\CommandTypeUtil.java
``` java
/**
 * Provides different categories of commands for UndoCommand and RedoCommand.
 *
 */
public class CommandTypeUtil {

    public static final String TYPE_ADD_TASK = "add Task";
    public static final String TYPE_DELETE_TASK = "delete Task";
    public static final String TYPE_EDIT_TASK = "edit Task";
    public static final String TYPE_COMPLETE = "complete";
    public static final String TYPE_UNCOMPLETE = "uncomplete";
    public static final String TYPE_UNDO = "undo";
    public static final String TYPE_REDO = "redo";
    public static final String TYPE_CLEAR = "clear";
    public static final String TYPE_EXIT = "exit";
    public static final String TYPE_FIND_TASK = "find Task";
    public static final String TYPE_HELP = "help";
    public static final String TYPE_HISTORY = "history";
    public static final String TYPE_LIST_TASK = "list Task";
    public static final String TYPE_SELECT_TASK = "select Task";

    public static String opposite(String commandType) {

        switch(commandType) {

        case TYPE_ADD_TASK:
            return TYPE_DELETE_TASK;

        case TYPE_DELETE_TASK:
            return TYPE_ADD_TASK;

        case TYPE_EDIT_TASK:
            return TYPE_EDIT_TASK;

        case TYPE_UNDO:
            return TYPE_REDO;

        case TYPE_REDO:
            return TYPE_UNDO;

        case TYPE_CLEAR:
            return TYPE_CLEAR;

        case TYPE_EXIT:
            return TYPE_EXIT;

        case TYPE_FIND_TASK:
            return TYPE_FIND_TASK;

        case TYPE_HELP:
            return TYPE_HELP;

        case TYPE_HISTORY:
            return TYPE_HISTORY;

        case TYPE_LIST_TASK:
            return TYPE_LIST_TASK;

        case TYPE_SELECT_TASK:
            return TYPE_SELECT_TASK;

        default:
            return commandType;
        }
    }


}
```
###### \java\seedu\typed\logic\commands\util\HistoryUtil.java
``` java
/**
 * Provides a data structure for "history" in Session class.
 *
 */
public class HistoryUtil {

    private ArrayList<String> allCommandsHistory;
    private ArrayList<String> validCommandsHistory;

    public HistoryUtil() {
        this.allCommandsHistory = new ArrayList<String>();
        this.validCommandsHistory = new ArrayList<String>();
    }

    public void addCommand(String command) {
        this.allCommandsHistory.add(command);
    }

    public void addValidCommand(String command) {
        this.validCommandsHistory.add(command);
    }

    public void listAllCommands() {
        for (int index = 1; index <= this.allCommandsHistory.size(); index++) {
            System.out.println(index + ") " + this.allCommandsHistory.get(index - 1));
        }
    }

    public void listValidCommands() {
        for (int index = 1; index <= this.validCommandsHistory.size(); index++) {
            System.out.println(index + ") " + this.validCommandsHistory.get(index - 1));
        }
    }

    public void clearAllCommandsHistory() {
        this.allCommandsHistory.clear();
    }

    public void clearValidCommandsHistory() {
        this.validCommandsHistory.clear();
    }

    public ArrayList<String> getAllCommandsHistory() {
        return this.allCommandsHistory;
    }

    public ArrayList<String> getValidCommandsHistory() {
        return this.validCommandsHistory;
    }

    public void clear() {
        this.clearAllCommandsHistory();
        this.clearValidCommandsHistory();
    }
}
```
###### \java\seedu\typed\logic\commands\util\IndexRangeUtil.java
``` java
public class IndexRangeUtil {

    private static final String RANGE_TO_REGEX = "[1-9]+[0-9]*\\s+[t]{1}[o]{1}\\s+[1-9]+[0-9]*";
    private static final String RANGE_NUMBERS_ONLY_REGEX = "[1-9]+[0-9]*\\s+[1-9]+[0-9]*";
    private static final String RANGE_SINGLE_NUMBER_REGEX = "[1-9]+[0-9]*";
    private static final String RANGE_DASH_REGEX = "[1-9]+[0-9]*\\s+[\\-]\\s+[1-9]+[0-9]*";

    private static final String TO_REGEX = "\\s+[t]{1}[o]{1}\\s+";
    private static final String SPACE_REGEX = "\\s+";
    private static final String DASH_REGEX = "\\s+[\\-]\\s+";

    private int startIndex;
    private int endIndex;
    private boolean isValid;

    public IndexRangeUtil(String range) {
        String trimmedRange = range.trim();
        if (trimmedRange.matches(RANGE_TO_REGEX)) {
            handleToRange(trimmedRange);
        } else if (trimmedRange.matches(RANGE_NUMBERS_ONLY_REGEX)
                   || trimmedRange.matches(RANGE_SINGLE_NUMBER_REGEX)) {
            handleNumbersOnlyRange(trimmedRange);
        } else if (trimmedRange.matches(RANGE_DASH_REGEX)) {
            handleDashRange(trimmedRange);
        } else {
            isValid = false;
            startIndex = -1;
            endIndex = -1;
        }

    }

    public boolean isValid() {
        return isValid;
    }

    public int getStartIndex() {
        return startIndex;
    }

    public int getEndIndex() {
        return endIndex;
    }

    private void handleToRange(String range) {
        String[] indices = range.split(TO_REGEX);
        if (indices.length == 2) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = Integer.parseInt(indices[1]);
        } else {
            startIndex = -1;
            endIndex = -1;
        }

        if ((startIndex <= 0) || (startIndex > endIndex)) {
            isValid = false;
        } else {
            isValid = true;
        }
    }

    private void handleNumbersOnlyRange(String range) {
        String[] indices = range.split(SPACE_REGEX);
        if (indices.length == 2) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = Integer.parseInt(indices[1]);
        } else if (indices.length == 1) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = startIndex;
        } else {
            startIndex = -1;
            endIndex = -1;
        }

        if ((startIndex <= 0) || (startIndex > endIndex)) {
            isValid = false;
        } else {
            isValid = true;
        }
    }

    private void handleDashRange(String range) {
        String[] indices = range.split(DASH_REGEX);
        if (indices.length == 2) {
            startIndex = Integer.parseInt(indices[0]);
            endIndex = Integer.parseInt(indices[1]);
        } else {
            startIndex = -1;
            endIndex = -1;
        }

        if ((startIndex <= 0) || (startIndex > endIndex)) {
            isValid = false;
        } else {
            isValid = true;
        }
    }
}
```
###### \java\seedu\typed\logic\commands\util\UndoRedoUtil.java
``` java
/**
 * Helps to manage Undo and Redo stacks in the Session class.
 *
 */
public class UndoRedoUtil {

    public static Optional<TripleUtil<String, Integer, Object>> pop(Stack<TripleUtil<String, Integer, Object>> stack) {
        if (!stack.empty()) {
            return Optional.of(stack.pop());
        } else {
            return Optional.empty();
        }
    }

    public static void clear(Stack<TripleUtil<String, Integer, Object>> stack) {
        stack.clear();
    }

    public static boolean isEmpty(Stack<TripleUtil<String, Integer, Object>> stack) {
        return stack.empty();
    }

    @SuppressWarnings("unchecked")
    public static void update(Stack<TripleUtil<String, Integer, Object>> undoStack,
                              Stack<TripleUtil<String, Integer, Object>> redoStack,
                              String command, Integer index, Object toChange) {

        TripleUtil<String, Integer, Object> toPush = new TripleUtil<String, Integer, Object>(command,
                                                                                             index,
                                                                                             toChange);
        switch(command) {

        case CommandTypeUtil.TYPE_UNDO:
            toPush = (TripleUtil<String, Integer, Object>) toChange;
            redoStack.push(toPush);
            break;

        case CommandTypeUtil.TYPE_REDO:
            toPush = (TripleUtil<String, Integer, Object>) toChange;
            undoStack.push(toPush);
            break;

        case CommandTypeUtil.TYPE_ADD_TASK:
            redoStack.clear();
            toPush.setFirst(CommandTypeUtil.opposite(CommandTypeUtil.TYPE_ADD_TASK));
            undoStack.push(toPush);
            break;

        case CommandTypeUtil.TYPE_DELETE_TASK:
            redoStack.clear();
            toPush.setFirst(CommandTypeUtil.opposite(CommandTypeUtil.TYPE_DELETE_TASK));
            undoStack.push(toPush);
            break;

        case CommandTypeUtil.TYPE_EDIT_TASK:
            redoStack.clear();
            undoStack.push(toPush);
            break;

        case CommandTypeUtil.TYPE_CLEAR:
            redoStack.clear();
            undoStack.push(toPush);
            break;

        case CommandTypeUtil.TYPE_COMPLETE:
            redoStack.clear();
            undoStack.push(toPush);
            break;

        case CommandTypeUtil.TYPE_FIND_TASK:
            break;

        case CommandTypeUtil.TYPE_HELP:
            break;

        case CommandTypeUtil.TYPE_HISTORY:
            break;

        case CommandTypeUtil.TYPE_LIST_TASK:
            break;

        case CommandTypeUtil.TYPE_SELECT_TASK:
            break;

        case CommandTypeUtil.TYPE_EXIT:
            break;

        default:
            break;
        }
    }

   // TODO write function to check if object is instanceof TripleUtil
}
```
###### \java\seedu\typed\logic\parser\DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        /* Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());*/

        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("all")) {
            return new DeleteCommand();
        }

        IndexRangeUtil range = new IndexRangeUtil(args);
        if (range.isValid()) {
            return new DeleteCommand(range.getStartIndex(),
                    range.getEndIndex());
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    DeleteCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\typed\logic\parser\RedoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RedoCommand object
 */
public class RedoCommandParser {

    public static final String POSITIVE_INTEGER_REGEX = "[1-9]+[0-9]*";
    /**
     * Parses the given {@code String} of arguments in the context of the
     * RedoCommand and returns an RedoCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("")) {
            return new RedoCommand();
        } else if (trimmedArgs.equals("all")) {
            return new RedoCommand(-1);
        } else if (trimmedArgs.matches(POSITIVE_INTEGER_REGEX)) {
            int num = Integer.parseInt(trimmedArgs);
            return new RedoCommand(num);
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                      RedoCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\typed\logic\parser\UndoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new UndoCommand object
 */
public class UndoCommandParser {

    public static final String POSITIVE_INTEGER_REGEX = "[1-9]+[0-9]*";
    /**
     * Parses the given {@code String} of arguments in the context of the
     * UndoCommand and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();

        if (trimmedArgs.equals("")) {
            return new UndoCommand();
        } else if (trimmedArgs.equals("all")) {
            return new UndoCommand(-1);
        } else if (trimmedArgs.matches(POSITIVE_INTEGER_REGEX)) {
            int num = Integer.parseInt(trimmedArgs);
            return new UndoCommand(num);
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                      UndoCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\typed\model\Model.java
``` java
    Task getTaskAt(int index);
```
###### \java\seedu\typed\model\Model.java
``` java
    int getIndexOfTask(Task task) throws TaskNotFoundException;
```
###### \java\seedu\typed\model\Model.java
``` java
    /** Adds the given task at the specified index. */
    void addTask(int index, Task task) throws DuplicateTaskException;
```
###### \java\seedu\typed\model\Model.java
``` java
    /** TODO Change comments
     * Updates the task located at {@code filteredTaskListIndex} with
     * {@code editedTask}.
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be
     *             equivalent to another existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code filteredTaskListIndex} < 0 or >= the size of the
     *             task list.
     */
    void updateTaskForUndoRedo(int index, ReadOnlyTask editedTask)
            throws DuplicateTaskException, IllegalValueException;
```
###### \java\seedu\typed\model\Model.java
``` java
    /** Copies tasks over into current TaskManager. **/
    void copyData(ReadOnlyTaskManager newData) throws IllegalValueException;
```
###### \java\seedu\typed\model\Model.java
``` java
    void uncompleteTaskAtForUndo(int taskManagerIndex) throws DuplicateTaskException;

    void completeTaskAtForRedo(int taskManagerIndex) throws DuplicateTaskException;

    void completeTasksAndStoreIndices(int startIndex, int endIndex, ArrayList<Integer> list)
            throws DuplicateTaskException;

    void deleteTasksAndStoreTasksAndIndices(int startIndex, int endIndex, ArrayList<Pair<Integer, Task>> list)
            throws TaskNotFoundException;

    void deleteTaskAt(int index);

    void uncompleteTasksAtForUndo(ArrayList<Integer> list) throws DuplicateTaskException;

    void completeTasksAtForRedo(ArrayList<Integer> list) throws DuplicateTaskException;

    void addTasksForUndo(ArrayList<Pair<Integer, Task>> list) throws DuplicateTaskException;

    void deleteTasksForRedo(ArrayList<Pair<Integer, Task>> list) throws DuplicateTaskException;

    int getNumberUncompletedEvents();

    int getNumberUncompletedDeadlines();

    int getNumberUncompletedFloatingTasks();

```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public int getIndexOfTask(Task task) throws TaskNotFoundException {
        return taskManager.getIndexOf(task);
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public Task getTaskAt(int index) {
        return taskManager.getTaskAt(index);
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void addTask(int index, Task task) throws DuplicateTaskException {
        taskManager.addTask(index, task);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void addTasksForUndo(ArrayList<Pair<Integer, Task>> list)
            throws DuplicateTaskException {
        for (int curr = 0; curr < list.size(); curr++) {
            Pair<Integer, Task> indexAndTask = list.get(curr);
            int index = indexAndTask.getFirst();
            Task task = indexAndTask.getSecond();
            taskManager.addTask(index, task);
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTaskAt(int index) {
        taskManager.removeTaskAt(index);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void deleteTasksAndStoreTasksAndIndices(int startIndex, int endIndex,
            ArrayList<Pair<Integer, Task>> list) throws TaskNotFoundException {
        int num = endIndex - startIndex + 1;
        for (int i = 0; i < num; i++) {
            int taskManagerIndex = filteredTasks.getSourceIndex(startIndex);
            Task taskToDelete = taskManager.getTaskAt(taskManagerIndex);
            Pair<Integer, Task> toAdd = new Pair<Integer, Task>(taskManagerIndex, taskToDelete);
            list.add(0, toAdd);
            taskManager.removeTaskAt(taskManagerIndex);
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void deleteTasksForRedo(ArrayList<Pair<Integer, Task>> list)
            throws DuplicateTaskException {
        for (int curr = 0; curr < list.size(); curr++) {
            Pair<Integer, Task> indexAndTask = list.get(curr);
            int index = indexAndTask.getFirst();
            taskManager.removeTaskAt(index);
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public synchronized void completeTasksAndStoreIndices(int startIndex, int endIndex,
            ArrayList<Integer> list) throws DuplicateTaskException {
        for (int curr = startIndex; curr <= endIndex; curr++) {
            int taskManagerIndex = filteredTasks.getSourceIndex(curr);
            addTaskIndexToListIfUncompleted(taskManagerIndex, list);
            taskManager.completeTaskAt(taskManagerIndex);
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    private void addTaskIndexToListIfUncompleted(int taskIndex, ArrayList<Integer> list) {
        if (!taskManager.getTaskAt(taskIndex).getIsCompleted()) {
            list.add(taskIndex);
        }
    }

    @Override
    public synchronized void uncompleteTaskAtForUndo(int taskManagerIndex)
            throws DuplicateTaskException {
        taskManager.uncompleteTaskAt(taskManagerIndex);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void uncompleteTasksAtForUndo(ArrayList<Integer> list)
            throws DuplicateTaskException {
        for (int curr = 0; curr < list.size(); curr++) {
            taskManager.uncompleteTaskAt(list.get(curr));
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void completeTasksAtForRedo(ArrayList<Integer> list)
            throws DuplicateTaskException {
        for (int curr = 0; curr < list.size(); curr++) {
            taskManager.completeTaskAt(list.get(curr));
        }
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void completeTaskAtForRedo(int taskManagerIndex)
            throws DuplicateTaskException {
        taskManager.completeTaskAt(taskManagerIndex);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public void updateTaskForUndoRedo(int index, ReadOnlyTask editedTask)
            throws DuplicateTaskException, IllegalValueException {
        assert editedTask != null;

        taskManager.updateTask(index, editedTask);
        updateFilteredListToShowDefault();
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\ModelManager.java
``` java
    @Override
    public void copyData(ReadOnlyTaskManager newData) throws IllegalValueException {
        taskManager.copyData(newData);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public int indexOf(Task task) throws TaskNotFoundException {
        int index = internalList.indexOf(task);
        if (index == -1) {
            throw new TaskNotFoundException();
        } else {
            return index;
        }
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public Task getTaskAt(int index) {
        return internalList.get(index);
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public void add(int index, Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;

        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(index, toAdd);
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public void uncompleteTaskAt(int index) throws DuplicateTaskException {
        Task taskToUncomplete = internalList.get(index);
        if (taskToUncomplete.getIsCompleted()) {
            taskToUncomplete.setIsCompleted(false);
        }
    }
```
###### \java\seedu\typed\model\task\UniqueTaskList.java
``` java
    public void remove(int index) {
        assert ((index >= 0)
                && (index < internalList.size()));
        internalList.remove(index);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public void copyData(ReadOnlyTaskManager newData) {
        assert newData != null;
        try {
            ObservableList<ReadOnlyTask> tasksToCopy = newData.getTaskList();
            Iterator<ReadOnlyTask> iterator = tasksToCopy.iterator();
            while (iterator.hasNext()) {
                ReadOnlyTask toCopy = iterator.next();
                addTask((Task) toCopy);
            }
        } catch (UniqueTaskList.DuplicateTaskException e) {
            ;
        }
        try {
            ObservableList<Tag> tagsToCopy = newData.getTagList();
            Iterator<Tag> iterator = tagsToCopy.iterator();
            while (iterator.hasNext()) {
                Tag toCopy = iterator.next();
                addTag(toCopy);
            }
        } catch (UniqueTagList.DuplicateTagException e) {
            ;
        }
        syncMasterTagListWith(tasks);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public void addTask(int index, Task task) throws DuplicateTaskException {
        syncMasterTagListWith(task);
        tasks.add(index, task);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public int getIndexOf(Task task) throws TaskNotFoundException {
        return tasks.indexOf(task);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public Task getTaskAt(int index) {
        return tasks.getTaskAt(index);
    }
```
###### \java\seedu\typed\model\TaskManager.java
``` java
    public void uncompleteTaskAt(int taskManagerIndex) throws DuplicateTaskException {
        tasks.uncompleteTaskAt(taskManagerIndex);
    }
```
###### \java\seedu\typed\storage\temp\Session.java
``` java
/**
 * Keeps track of commands to undo and redo in a session.
 * Keeps track of history of commands entered
 *
 */

public class Session {
    private HistoryUtil history;
    private Stack<TripleUtil<String, Integer, Object>> undoStack;
    private Stack<TripleUtil<String, Integer, Object>> redoStack;

    public Session() {
        this.history = new HistoryUtil();
        this.undoStack = new Stack<TripleUtil<String, Integer, Object>>();
        this.redoStack = new Stack<TripleUtil<String, Integer, Object>>();
    }

    public Stack<TripleUtil<String, Integer, Object>> getUndoStack() {
        return undoStack;
    }

    public Stack<TripleUtil<String, Integer, Object>> getRedoStack() {
        return redoStack;
    }

    public void updateUndoRedoStacks(String command, Integer index, Object toChange) {
        UndoRedoUtil.update(undoStack, redoStack, command, index, toChange);
    }

    public void updateAllCommandsHistory(String command) {
        history.addCommand(command);
    }

    public void updateValidCommandsHistory(String command) {
        history.addValidCommand(command);
    }

    public ArrayList<String> getAllCommandsHistory() {
        return history.getAllCommandsHistory();
    }

    public ArrayList<String> getValidCommandsHistory() {
        return history.getValidCommandsHistory();
    }

    public void listAllCommandsHistory() {
        history.listAllCommands();
    }

    public void listValidCommandsHistory() {
        history.listValidCommands();
    }

    public Optional<TripleUtil<String, Integer, Object>> popUndoStack() {
        return UndoRedoUtil.pop(undoStack);
    }

    public Optional<TripleUtil<String, Integer, Object>> popRedoStack() {
        return UndoRedoUtil.pop(redoStack);
    }

    public void clearHistory() {
        history.clear();
    }
}
```
###### \java\seedu\typed\ui\CommandBox.java
``` java
    private void resetPointer() {
        pointer = commandHistory.size();
    }

    private boolean canUpPointer() {

        if (pointer == 0) {
            return false;
        }

        if (pointer > 0) {
            pointer--;
        }

        if (pointer < commandHistory.size()) {
            return true;
        } else {
            return false;
        }
    }

    private boolean canDownPointer() {
        if (pointer < (commandHistory.size() - 1)) {
            pointer++;
            return true;
        } else {
            return false;
        }
    }

    private void handleUpKey() {
        if (canUpPointer()) {
            String commandToShow = getCommandFromHistory();
            commandTextField.setText(commandToShow);
            setCaretToEnd();
        } else {
            setCaretAtOriginal();
        }
    }

    private void handleDownKey() {
        if (canDownPointer()) {
            String commandToShow = getCommandFromHistory();
            commandTextField.setText(commandToShow);
            setCaretToEnd();
        } else {
            resetPointer();
            commandTextField.clear();
        }
    }

    private String getCommandFromHistory() {
        return commandHistory.get(pointer);
    }

    private void setCaretToEnd() {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                commandTextField.end();
            }
        });
    }

    private void setCaretAtOriginal() {
        int originalPosition = commandTextField.getCaretPosition();
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                commandTextField.positionCaret(originalPosition);
            }
        });
    }
```
