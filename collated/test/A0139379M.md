# A0139379M
###### \java\commandunittests\AddCommandTest.java
``` java
/**
 * Unit Testing for AddCommand
 * Test for null session or model and various AddCommands inputs
 * @author YIM CHIA HUI
 *
 */
public class AddCommandTest {
    private TestAddCommand testCommand1;
    private TestAddCommand testCommand2;
    private TestAddCommand testCommand3;
    private TestAddCommand allPresent;
    private ModelStub testModel;
    //private TestAddCommand allNulls;
    //private TestAddCommand dateNull;
    //private TestAddCommand tagsNull;
    //private TestAddCommand nameNull;
    //private TestAddCommand dateTagNulls;
    // TODO The AddCommand still does not tolerate null values for date, tags


    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Before
    public void setUp() {
        try {
            //LocalDateTime rubbish = DateTimeParser.getLocalDateTimeFromString("");
            LocalDateTime rubbish = null;
            LocalDateTime fifthApril = DateTimeParser.getLocalDateTimeFromString("05/04/2017");
            LocalDateTime twelfthDec = DateTimeParser.getLocalDateTimeFromString("12/12/2017");
            testCommand1 = new TestAddCommand("Meet Joe", "", fifthApril, rubbish, rubbish, new HashSet<String>());
            testCommand2 = new TestAddCommand("Meet Joe", "", fifthApril, rubbish, rubbish, new HashSet<String>());
            testCommand3 = new TestAddCommand("Meet Joe", "", fifthApril, rubbish, rubbish, new HashSet<String>());
            allPresent = new TestAddCommand("Meet Moo", "", twelfthDec, rubbish, rubbish, new HashSet<String>());
            testModel = new ModelStub();
            testModel.addTask(new TaskBuilder()
                    .setName("Meet Joe")
                    .setNotes("")
                    .setDeadline(DateTime.getDateTime(2017, Month.APRIL, 5, 0, 0))
                    .build());
            //dateTagNulls = new TestAddCommand("Meet John", null , null);
            //allNulls = new TestAddCommand(null, null, null);
            //dateNull = new TestAddCommand("Meet John", null, new HashSet<String>());
            //tagsNull = new TestAddCommand("Meet John", "12/12/2012", null);
            //nameNull = new TestAddCommand(null, "12/12/12", new HashSet<String>());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void execute_modelNull_assertError() {
        testCommand1.setModel(null);
        thrown.expect(AssertionError.class);
        try {
            testCommand1.execute();
        } catch (CommandException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void execute_sessionNull_assertError() {
        testCommand2.setSession(null);
        thrown.expect(AssertionError.class);
        try {
            testCommand2.execute();
        } catch (CommandException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void execute_sessionModelNull_assertError() {
        testCommand1.setModel(null);
        testCommand1.setSession(null);
        thrown.expect(AssertionError.class);
        try {
            testCommand1.execute();
        } catch (CommandException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void execute_sessionModelPresent_assertSuccess() {
        try {
            allPresent.execute();
        } catch (CommandException e) {

        }
    }

    //TODO: fix test
    /*
    @Test
    public void execute_duplicateTasks_exception() {
        try {
            testCommand3.setModel(testModel);
            testCommand3.execute();
            thrown.expect(UniqueTaskList.DuplicateTaskException.class);
        } catch (CommandException e) {
            e.printStackTrace();
        }
    }

    @Test
    public void execute_allPresent_success() {
        try {
            assertEquals(allPresent.execute(),
                    new CommandResult("Task Added!"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
     */
}
```
###### \java\commandunittests\ClearCommandTest.java
``` java
/**
 * Unit Testing for ClearCommand
 * We are testing on whether a populated TaskManager and new TaskManager will be cleared successfully
 * @author YIM CHIA HUI
 *
 */
public class ClearCommandTest {
    private TestClearCommand dirtyClear;
    private TestClearCommand cleanClear;
    private TestClearCommand testCommand;

    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Before
    public void setUp() throws IllegalValueException {
        ModelStub dirtyModel = new ModelStub();
        dirtyModel.addTestTask();
        ModelStub cleanModel = new ModelStub();
        dirtyClear = new TestClearCommand();
        cleanClear = new TestClearCommand();
        testCommand = new TestClearCommand();
        dirtyClear.setModel(dirtyModel);
        cleanClear.setModel(cleanModel);
    }


    @Test
    public void execute_modelNull_assertError() throws CommandException {
        testCommand.setModel(null);
        thrown.expect(AssertionError.class);
        testCommand.execute();
    }

    @Test
    public void execute_clearDirtyTaskManager_success() throws CommandException {
        assertEquals(dirtyClear.execute(), new CommandResult(ClearCommand.MESSAGE_SUCCESS));
    }

    @Test
    public void execute_clearEmptyTaskManager_success() throws CommandException {
        assertEquals(cleanClear.execute(), new CommandResult(ClearCommand.MESSAGE_SUCCESS));
    }
}
```
###### \java\commandunittests\ModelStub.java
``` java
public class ModelStub extends ModelManager {

    private TaskManager taskManager;
    private final FilteredList<ReadOnlyTask> filteredTasks;

    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        // TODO Auto-generated method stub

    }

    public ModelStub() throws IllegalValueException {
        taskManager = new TaskManager();
        filteredTasks = new FilteredList<ReadOnlyTask>(taskManager.getTaskList());
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    public void addTestTask() {
        try {
            this.taskManager.addTask(new TaskBuilder().setName("Meet Joe")
                    .setDeadline(DateTime.getDateTime(2017, Month.DECEMBER, 12, 0, 0))
                    .build());
        } catch (DuplicateTaskException e) {
            e.printStackTrace();
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        // TODO Auto-generated method stub

    }

    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) throws DuplicateTaskException {
        // TODO Auto-generated method stub

    }

    @Override
    public void updateFilteredListToShowAll() {
        // TODO Auto-generated method stub

    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        // TODO Auto-generated method stub

    }

}
```
###### \java\commandunittests\TestAddCommand.java
``` java
public class TestAddCommand extends AddCommand {
    public TestAddCommand(String name, String notes, LocalDateTime date,
            LocalDateTime from, LocalDateTime to, Set<String> tags) throws IllegalValueException {
        super(name, notes, date, from, to, tags);
        this.setData(new ModelStub(), new SessionStub(), "", config, storage); //TODO Change String

    }

    public void setModel(ModelStub model) {
        this.model = model;
    }

    public void setSession(SessionStub session) {
        this.session = session;
    }

}
```
###### \java\commandunittests\TestClearCommand.java
``` java
public class TestClearCommand extends ClearCommand {

    public TestClearCommand() throws IllegalValueException {
        super();
        this.setModel(new ModelStub());
        this.setSession(new SessionStub());
    }

    public void setModel(ModelStub model) {
        this.model = model;
    }

    public void setSession(SessionStub session) {
        this.session = session;
    }
}
```
###### \java\guitests\CompleteCommandTest.java
``` java
public class CompleteCommandTest extends TaskManagerGuiTest {
    // GUI not ready as parser not in place
    // The list of tasks in the task list panel is expected to match this list.
    // This list is updated with every successful call to assertEditSuccess().
    // Complete task has two outcomes
    // 1) Complete a task and it is marked as completed
    // 2) Complete a completed task and nothing changes
    // 3) Complete a nonexisting task returns exception
    // 4) Complete an invalid task number returns exception
    // 5) Complete a list of tasks and all are marked as completed
    // 6) Complete all tasks
    // 7) Complete a list of invalid tasks throw exception
    // 8) Complete a list of invalid tasks with invalid bounds throw exception
    TestTask[] expectedTasksList = td.getTypicalTasks();

    @Test
    public void completeCommand_oneIndex_success()
            throws IllegalArgumentException, IllegalValueException {
        // finish one item
        int targetIndex = 1;
        expectedTasksList[0].setIsCompleted(true);
        assertCompleteSuccess(targetIndex, targetIndex);
    }

    @Test
    public void completeCommand_rangeOfIndex_success()
            throws IllegalArgumentException, IllegalValueException {
        int startIndex = 1;
        int endIndex = 3;
        for (int index = startIndex; index <= endIndex; index++) {
            expectedTasksList[index - 1].setIsCompleted(true);
        }
        assertCompleteSuccess(startIndex, endIndex);
    }

    @Test
    public void execute_invalidIndex_error() {
        int invalidIndex = 0;
        commandBox.runCommand("finish " + invalidIndex);
        assertResultMessage("Invalid command format!" + "\n" + String.format(CompleteCommand.MESSAGE_USAGE));
    }

    private void assertCompleteSuccess(int startIndex, int endIndex)
            throws IllegalArgumentException, IllegalValueException {
        StringBuilder command = new StringBuilder();
        String result = "";
        command.append("finish ").append(startIndex);
        if (startIndex != endIndex) {
            command.append(" to " + endIndex);
            result = result + (endIndex - startIndex + 1);
        } else {
            result = result + expectedTasksList[startIndex - 1].getName();
        }
        commandBox.runCommand(command.toString());
        TestTask[] filteredList = filterOutCompleted(expectedTasksList);

        // Checks the list contains all tasks without completed tasks
        assertTrue(taskListPanel.isListMatching(filteredList));
        if (startIndex == endIndex) {
            assertResultMessage(String.format(CompleteCommand.MESSAGE_COMPLETED_TASK_SUCCESS, result));
        } else {
            int numCompleted = Integer.parseInt(result);
            assertResultMessage(String.format(CompleteCommand.MESSAGE_COMPLETED_TASKS_SUCCESS, numCompleted));
        }
    }

    /**
     * Gets the list of uncompleted tasks
     *
     * @param tasks
     * @return TestTask[] of uncompleted tasks
     */
    private TestTask[] filterOutCompleted(TestTask[] tasks) {
        int count = 0;
        ArrayList<TestTask> filteredList = new ArrayList<>();
        for (int i = 0; i < tasks.length; i++) {
            if (!tasks[i].getIsCompleted()) {
                filteredList.add(tasks[i]);
                count++;
            }
        }
        TestTask[] filteredArray = new TestTask[count];
        for (int i = 0; i < count; i++) {
            filteredArray[i] = filteredList.get(i);
        }
        return filteredArray;
    }










}
```
###### \java\seedu\typed\model\task\DateTimeTest.java
``` java
/*
 * Unit Testing for DateTime class 98.4%
 * @author YIM CHIA HUI
 */
public class DateTimeTest {

    //private DateTime today = new DateTime();
    //private DateTime tomorrow = today.tomorrow();

    private DateTime aprilFoolDay = DateTime.getDateTime(2017, Month.APRIL, 1, 0, 0);
    private DateTime christmasDay = DateTime.getDateTime(2017, Month.DECEMBER, 25, 0, 0);
    private DateTime goodFridayDay = DateTime.getDateTime(2017, Month.APRIL, 18, 0, 0);

    private DateTime dayAfterAprilFoolDay = DateTime.getDateTime(2017, Month.APRIL, 2, 0, 0);
    private DateTime dayAfterChristmasDay = DateTime.getDateTime(2017, Month.DECEMBER, 26, 0, 0);
    private DateTime dayAfterGoodFridayDay = DateTime.getDateTime(2017, Month.APRIL, 19, 0, 0);

    private DateTime weekAfterAprilFool = DateTime.getDateTime(2017, Month.APRIL, 8, 0, 0);

    private DateTime monthAfterAprilFoolDay = DateTime.getDateTime(2017, Month.MAY, 1, 0, 0);
    private DateTime monthAfterChristmasDay = DateTime.getDateTime(2018, Month.JANUARY, 25, 0, 0);
    private DateTime monthAfterGoodFridayDay = DateTime.getDateTime(2017, Month.MAY, 18, 0, 0);

    private DateTime yearAfterAprilFoolDay = DateTime.getDateTime(2018, Month.APRIL, 1, 0, 0);
    private DateTime yearAfterChristmasDay = DateTime.getDateTime(2018, Month.DECEMBER, 25, 0, 0);
    private DateTime yearAfterGoodFridayDay = DateTime.getDateTime(2018, Month.APRIL, 18, 0, 0);

    @Test
    public void dateTimeTomorrow_aprilFoolDay_returnTrue() {
        assertTrue(aprilFoolDay.tomorrow().equals(dayAfterAprilFoolDay));
    }

    @Test
    public void dateTimeTomorrow_christmasDay_returnTrue() {
        assertTrue(christmasDay.tomorrow().equals(dayAfterChristmasDay));
    }

    @Test
    public void dateTimeTomorrow_goodFridayDay_returnTrue() {
        assertTrue(goodFridayDay.tomorrow().equals(dayAfterGoodFridayDay));
    }

    @Test
    public void dateTimeNextMonth_aprilFoolDay_returnTrue() {
        assertTrue(aprilFoolDay.nextMonth().equals(monthAfterAprilFoolDay));
    }
    @Test
    public void dateTimeNextMonth_christmasDay_returnTrue() {
        assertTrue(christmasDay.nextMonth().equals(monthAfterChristmasDay));
    }
    @Test
    public void dateTimeNextMonth_goodFridayDay_returnTrue() {
        assertTrue(goodFridayDay.nextMonth().equals(monthAfterGoodFridayDay));
    }

    @Test
    public void dateTimeNextYear_aprilFoolDay_returnTrue() {
        assertTrue(aprilFoolDay.nextYear().equals(yearAfterAprilFoolDay));
    }
    @Test
    public void dateTimeNextYear_christmasDay_returnTrue() {
        assertTrue(christmasDay.nextYear().equals(yearAfterChristmasDay));
    }
    @Test
    public void dateTimeNextYear_goodFridayDay_returnTrue() {
        assertTrue(goodFridayDay.nextYear().equals(yearAfterGoodFridayDay));
    }

    /*
    @Test
    public void isToday_notToday_returnFalse() {
        assertFalse(tomorrow.isToday());
    }

    @Test
    public void isToday_today_returnTrue() {
        assertTrue(today.isToday());
    }

    @Test
    public void isAfter_todayAfterTomorrow_returnFalse() {
        assertFalse(today.isAfter(tomorrow));
    }

    @Test
    public void isAfter_TomorrowAfterToday_returnTrue() {
        assertTrue(tomorrow.isAfter(today));
    }
    */

    @Test
    public void nextWeek_AprilFool_Success() {
        assertTrue(weekAfterAprilFool.equals(aprilFoolDay.nextWeek()));
    }

    @Test
    public void toString_AprilFool_success() {
        System.out.println(aprilFoolDay.toString());
        assertTrue((aprilFoolDay.toString()).equals("Saturday, Apr 01, 2017 00:00"));
    }


}
```
###### \java\seedu\typed\model\task\EventBuilderTest.java
``` java
/*
 * Unit testing for EventBuilder 100%
 * @author YIM CHIA HUI
 */
public class EventBuilderTest {
    EventBuilder testBuilder1 = new EventBuilder();
    Name name1;
    Name name2;
    DateTime aprilFoolDay;
    DateTime christmasDay;
    DateTime dayAfterAprilFoolDay;
    DateTime dayAfterChristmasDay;
    String details1;
    String details2;
    UniqueTagList tags, tagTest;
    Set<String> tagSet;
    Event testEvent1;
    Event testEvent2;
    @Before
    public void setUp() {
        try {
            name1 = new Name("Meet John");
            name2 = new Name("Meet May");
            aprilFoolDay = DateTime.getDateTime(2017, Month.APRIL, 1, 0, 0);
            christmasDay = DateTime.getDateTime(2017, Month.DECEMBER, 25, 0, 0);
            dayAfterAprilFoolDay = DateTime.getDateTime(2017, Month.APRIL, 2, 0, 0);
            dayAfterChristmasDay = DateTime.getDateTime(2017, Month.DECEMBER, 26, 0, 0);
            details1 = "Have a cup of coffee!";
            details2 = "Buy present for May!";
            tags = new UniqueTagList();
            tagTest = new UniqueTagList();
            tags.add(new Tag("friends"));
            testEvent1 = new Event(name1, aprilFoolDay, dayAfterAprilFoolDay, false, details1, tags);
            testEvent2 = new Event(name2, christmasDay, dayAfterChristmasDay, true, details2, tags);
            tagSet = new HashSet<String>();
            tagSet.add("friends");
            tagSet.add("work");
            tagTest.add(new Tag("friends"));
            tagTest.add(new Tag("work"));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }
    @Test
    public void setDetails_validDetails_success() {
        assertTrue(testBuilder1
                .setName(name1).setDetails(details1)
                .build().getDetails().equals(details1));
    }
    @Test
    public void setName_validName_success() {
        assertTrue(testBuilder1.setName(name1).build().getName().equals(name1));
        testBuilder1 = new EventBuilder();
    }
    @Test
    public void setName_validString_success() {
        try {
            assertTrue(testBuilder1.setName("Meet John").build().getName().equals(name1));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        testBuilder1 = new EventBuilder();
    }
    @Test
    public void startDate_validDate_success() {
        assertTrue(testBuilder1
                .setName(name1)
                .startDate(aprilFoolDay)
                .build().getStartDate().equals(aprilFoolDay));
        testBuilder1 = new EventBuilder();
    }
    @Test
    public void endDate_validDate_success() {
        assertTrue(testBuilder1
                .setName(name1)
                .endDate(aprilFoolDay)
                .build().getEndDate().equals(aprilFoolDay));
        testBuilder1 = new EventBuilder();
    }
    @Test
    public void date_validDates_success() {
        Event testEvent = testBuilder1.setName(name1)
                .date(aprilFoolDay, dayAfterAprilFoolDay)
                .build();
        assertTrue(testEvent.getEndDate().equals(dayAfterAprilFoolDay));
        assertTrue(testEvent.getStartDate().equals(aprilFoolDay));
    }
    @Test
    public void addTags_validTag_success() {
        try {
            assertTrue(testBuilder1.setName(name1)
                    .addTags("friends").build().getTags().equals(tags));
            testBuilder1 = new EventBuilder();
        } catch (DuplicateTagException e) {
            e.printStackTrace();
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }
    @Test
    public void addTags_duplicateTag_duplicateTagException() {
        try {
            testBuilder1.setName(name1).addTags("friends").addTags("friends").build();
            fail();
        } catch (DuplicateTagException e) {
            assertEquals(e.getMessage(), "Operation would result in duplicate tags");
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        testBuilder1 = new EventBuilder();
    }
    @Test
    public void taskBuilder_Task_Success() {
        EventBuilder builder = new EventBuilder(testEvent1);
        assertTrue(builder.build().equals(testEvent1));
    }
    @Test
    public void addTags_setOfTags_success() {
        try {
            UniqueTagList tags = testBuilder1.setName(name1).setTags(tagSet).build().getTags();
            for (Tag tag:tags) {
                assertTrue(tagTest.contains(tag));
            }
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
    }
    @Test
    public void setTags_UniqueTagList_success() {
        assertTrue(testBuilder1.setName(name1).setTags(tags).build().getTags().equals(tags));
        testBuilder1 = new EventBuilder();
    }
    @Test
    public void isRecurring_Recurring_success() {
        assertTrue(testBuilder1.setName(name1).isRecurring(true).build().isRecurring());
        testBuilder1 = new EventBuilder();
    }

}
```
###### \java\seedu\typed\model\task\TaskBuilderTest.java
``` java
/*
 * Unit testing for TaskBuilder 100%
 * @author YIM CHIA HUI
 */
public class TaskBuilderTest {
    private TaskBuilder testBuilder1 = new TaskBuilder();
    private Name name;
    private DateTime date;
    private Notes notes;
    //private ScheduleElement se;
    private UniqueTagList tags, tagTest;
    private Set<String> tagSet;
    private Task testTask;
    @Before
    public void setUp() {
        try {
            name = new Name("Meet John");

            date = DateTime.getDateTime(2017, Month.APRIL, 1, 0, 0);
```
###### \java\seedu\typed\model\task\TaskTest.java
``` java
/**
 * Unit testing for Task class 98.3%
 * @author YIM CHIA HUI
 *
 */
public class TaskTest {
    private Name nullName;
    private Name name;
    private Name name2;
    private Tag tag;
    private Tag tag2;
    private DateTime date;
```
###### \java\seedu\typed\schedule\DayInMonthTETest.java
``` java
public class DayInMonthTETest {

    // Boundary Cases for Last Tuesday
    // Last Tuesday of March 2017
    private DateTime testDate280317 = DateTime.getDateTime(2017, Month.MARCH, 28, 0, 0);
    // Last Tuesday of April 2017
    private DateTime testDate250417 = DateTime.getDateTime(2017, Month.APRIL, 25, 0, 0);
    // Last Tuesday of April 2018
    private DateTime testDate240418 = DateTime.getDateTime(2018, Month.APRIL, 24, 0, 0);
    // Second Last Tuesday of March 2017
    private DateTime testDate210317 = DateTime.getDateTime(2017, Month.MARCH, 21, 0, 0);

    // Boundary Cases for First Monday
    // First Monday of March 2017
    private DateTime firstMondayOfMarch = DateTime.getDateTime(2017, Month.MARCH, 06, 0, 0);
    // Second Monday of March 2017
    private DateTime secondMondayOfMarch = DateTime.getDateTime(2017, Month.MARCH, 13, 0, 0);
    // First Monday of April 2017
    private DateTime firstMondayOfApril = DateTime.getDateTime(2017, Month.APRIL, 03, 0, 0);
    // First Monday of April 2018
    private DateTime testDate020418 = DateTime.getDateTime(2018, Month.APRIL, 02, 0, 0);
    // Second Monday of April 20172017
    private DateTime testDate100417 = DateTime.getDateTime(2017, Month.APRIL, 10, 0, 0);
    // First Monday of Jan 2018
    private DateTime firstMondayOfJan2018 = DateTime.getDateTime(2018, Month.JANUARY, 01, 0, 0);
    // First Monday of Dec 2017
    private DateTime firstMondayOfDec2017 = DateTime.getDateTime(2017, Month.DECEMBER, 04, 0, 0);
    // First Tuesday of March 2017
    private DateTime firstTuesdayOfMarch = DateTime.getDateTime(2017, Month.MARCH, 07, 0, 0);
    // Second Tuesday of March 2017
    private DateTime secondTuesdayOfMarch = DateTime.getDateTime(2017, Month.MARCH, 14, 0, 0);
    // First Wednesday of April 2017
    private DateTime firstWednesdayOfApril = DateTime.getDateTime(2017, Month.APRIL, 05, 0, 0);
    // Second Sunday of March 2017
    private DateTime secondSundayOfMarch = DateTime.getDateTime(2017, Month.MARCH, 12, 0, 0);
    // First Sunday of April 2017
    private DateTime firstSundayOfApril = DateTime.getDateTime(2017, Month.APRIL, 02, 0, 0);

    // Some Edge Cases for Last Monday
    // Last Monday of April 2018, in particular that April has 5 Mondays
    // In particular, it should also match the 5th week Monday
    private DateTime testDate300418 = DateTime.getDateTime(2018, Month.APRIL, 30, 0, 0);

    private DayInMonthTE everyFirstMonday = new DayInMonthTE(1, 1);
    private DayInMonthTE everyLastTuesday = new DayInMonthTE(-1, 2);
    private DayInMonthTE everyLastMonday = new DayInMonthTE(-1, 1);
    private DayInMonthTE everyFifthMonday = new DayInMonthTE(5, 1);
    private DayInMonthTE everyFirstTuesday = new DayInMonthTE(1, 2);
    private DayInMonthTE everySecondMonday = new DayInMonthTE(2, 1);
    private DayInMonthTE everySecondTuesday = new DayInMonthTE(2, 2);
    private DayInMonthTE everyFirstWednesday = new DayInMonthTE(1, 3);
    private DayInMonthTE everyFirstSunday = new DayInMonthTE(1, 7);


    private TimeExpression firstWeek = DayInMonthTE.week(1);
    private TimeExpression everyMonday = DayInMonthTE.weekly(1);
    private TimeExpression everyTuesday = DayInMonthTE.weekly(2);
    private TimeExpression firstMondayEveryMonth = DayInMonthTE.monthly(1, 1);

    // Testing involves forming a particular TimeExpression like everyFifthMonday and the input 300418
    // includes method is very important to work for all cases as every time expression will depends
    // on it to get the correct recurrence
    // =========== Comprehensive Testing for includes ==============
    // =============================================================
    @Test
    public void includes_300418_everyFifthMonday_true() {
        assertTrue(everyFifthMonday.includes(testDate300418));
    }
    @Test
    public void includes_300418_everyLastMonday_true() {
        assertTrue(everyLastMonday.includes(testDate300418));
    }
    @Test
    public void includes_280317_everyLastTuesday_true() {
        assertTrue(everyLastTuesday.includes(testDate280317));
    }
    @Test
    public void includes_250417_everyLastTuesday_true() {
        assertTrue(everyLastTuesday.includes(testDate250417));
    }
    @Test
    public void includes_240418_everyLastTuesday_true() {
        assertTrue(everyLastTuesday.includes(testDate240418));
    }
    @Test
    public void includes_210317_everyLastTuesday_false() {
        assertFalse(everyLastTuesday.includes(testDate210317));
    }
    @Test
    public void includes_firstMondayOfMarch_everyFirstMonday_true() {
        assertTrue(everyFirstMonday.includes(firstMondayOfMarch));
    }
    @Test
    public void includes_030417_everyFirstMonday_true() {
        assertTrue(everyFirstMonday.includes(firstMondayOfApril));
    }
    @Test
    public void includes_020418_everyFirstMonday_true() {
        assertTrue(everyFirstMonday.includes(testDate020418));
    }
    @Test
    public void includes_100417_everyFirstMonday_true() {
        assertFalse(everyFirstMonday.includes(testDate100417));
    }


    // =========== Testing nextDeadlineOccurrence(DateTime) ========
    // =============================================================
    // Another very important method to test is nextDeadlineOccurrence
    // we need to ensure that the DateTime returned is the correct and accurate
    // representation of the next occurrence given the particular recurrence rule

    // Testing methods are named in this format
    // nextDeadlineOccurrence_<DATE>In<RECURRENCE>_OUTCOME
    // where next occurrence will be after DATE
    // Testing various conditions like next occurrence is next year, next month, same month, different weeks etc

    @Test
    public void nextDeadlineOccurrence_firstMondayOfMarchInEveryFirstMonday_firstMondayOfApril() {
        assertTrue(everyFirstMonday.nextOccurrence(firstMondayOfMarch).equals(firstMondayOfApril));
    }
    @Test
    public void nextDeadlineOccurrence_firstMondayOfDec2017InEveryFirstMonday_firstMondayOfJan2018() {
        assertTrue(everyFirstMonday.nextOccurrence(firstMondayOfDec2017).equals(firstMondayOfJan2018));
    }
    @Test
    public void nextDeadlineOccurrence_firstMondayOfMarchInEveryFirstTuesday_firstTuesdayOfMarch() {
        assertTrue(everyFirstTuesday.nextOccurrence(firstMondayOfMarch).equals(firstTuesdayOfMarch));
    }
    @Test
    public void nextDeadlineOccurrence_firstMondayOfMarchInEverySecondMonday_secondMondayOfMarch() {
        assertTrue(everySecondMonday.nextOccurrence(firstMondayOfMarch).equals(secondMondayOfMarch));
    }
    @Test
    public void nextDeadlineOccurrence_firstTuesdayOfMarchInEverySecondMonday_secondMondayOfMarch() {
        assertTrue(everySecondMonday.nextOccurrence(firstTuesdayOfMarch).equals(secondMondayOfMarch));
    }
    @Test
    public void nextDeadlineOccurrence_firstMondayOfMarchInEverySecondTuesday_secondTuesdayOfMarch() {
        assertTrue(everySecondTuesday.nextOccurrence(firstMondayOfMarch).equals(secondTuesdayOfMarch));
    }
    @Test
    public void nextDeadlineOccurrence_firstMondayOfMarchInEveryFirstWednesday_firstWednesdayOfApril() {
        assertTrue(everyFirstWednesday.nextOccurrence(firstMondayOfMarch).equals(firstWednesdayOfApril));
    }
    @Test
    public void nextDeadlineOccurrence_secondSundayOfMarchInEveryFirstSunday_firstSundayOfApril() {
        assertTrue(everyFirstSunday.nextOccurrence(secondSundayOfMarch).equals(firstSundayOfApril));
    }
    @Test
    public void nextDeadlineOccurrence_firstMondayOfMarchInEveryFirstSunday_firstSundayOfApril() {
        assertTrue(everyFirstSunday.nextOccurrence(firstMondayOfMarch).equals(firstSundayOfApril));
    }


    // =========== Testing various recurrence constructs ===========
    // =============================================================
    // Recurrence constructs are shortcuts to give us TimeExpression that
    // recurs according to common recurring rules like weekly, or the whole week
    // To test this, we will use include to verify that the date falls within the recurrence

    // week tests
    @Test
    public void week_firstMondayOfMarchInFirstWeek_true() {
        assertTrue(firstWeek.includes(firstMondayOfMarch));
    }
    @Test
    public void week_firstTuesdayOfMarchInFirstWeek_true() {
        assertTrue(firstWeek.includes(firstTuesdayOfMarch));
    }
    @Test
    public void week_secondTuesdayOfMarchInFirstWeek_false() {
        assertFalse(firstWeek.includes(secondTuesdayOfMarch));
    }

    // weekly tests
    @Test
    public void weekly_secondMondayOfMarchInEveryMonday_true() {
        assertTrue(everyMonday.includes(secondMondayOfMarch));
    }
    @Test
    public void weekly_firstMondayOfAprilInEveryMonday_true() {
        assertTrue(everyMonday.includes(firstMondayOfApril));
    }
    @Test
    public void weekly_firstTuesdayOfMarchInEveryMonday_false() {
        assertFalse(everyMonday.includes(firstTuesdayOfMarch));
    }
    @Test
    public void weekly_firstMondayOfJan2018InEveryMonday_true() {
        assertTrue(everyMonday.includes(firstMondayOfJan2018));
    }
    @Test
    public void weekly_firstTuesdayOfMarchInEveryTuesday_true() {
        assertTrue(everyTuesday.includes(firstTuesdayOfMarch));
    }

    // monthly tests
    // In particular, recur a given date every month
    @Test
    public void monthly_firstMonday_recursEveryFirstMonday() {
        assertTrue(firstMondayEveryMonth.includes(firstMondayOfApril));
        assertTrue(firstMondayEveryMonth.includes(firstMondayOfMarch));
        assertTrue(firstMondayEveryMonth.includes(firstMondayOfJan2018));
        assertFalse(firstMondayEveryMonth.includes(firstTuesdayOfMarch));
    }

    @Test
    public void isLeapYear_2000_true() {
        assertTrue(DayInMonthTE.isLeapYear(2000));
    }
    @Test
    public void isLeapYear_1900_true() {
        assertFalse(DayInMonthTE.isLeapYear(1900));
    }
}
```
###### \java\seedu\typed\schedule\RangeEachYearTETest.java
``` java
public class RangeEachYearTETest {

    // Generic Test Dates
    private DateTime aprilFoolDay = DateTime.getDateTime(2017, Month.APRIL, 1, 0, 0);
    private DateTime christmasDay = DateTime.getDateTime(2017, Month.DECEMBER, 25, 0, 0);
    private DateTime goodFridayDay = DateTime.getDateTime(2017, Month.APRIL, 18, 0, 0);
    private DateTime happyNewYear = DateTime.getDateTime(2017, Month.JANUARY, 1, 0, 0);

    // Generic RangeEachYearTE
    private RangeEachYearTE marchToJune = new RangeEachYearTE(3, 6);
    private RangeEachYearTE julyToDec = new RangeEachYearTE(7, 12);
    private RangeEachYearTE jan = new RangeEachYearTE(1);

    // Boundary Cases for goodFridayDay specific
    private RangeEachYearTE april18toOct25 = new RangeEachYearTE(4, 10, 18, 25);
    private RangeEachYearTE jan21toApril17 = new RangeEachYearTE(1, 4, 21, 17);
    private RangeEachYearTE april19toOct25 = new RangeEachYearTE(4, 10, 19, 25);

    private DateTime beforeApril18 = DateTime.getDateTime(2017, Month.APRIL, 17, 0, 0);
    private DateTime afterApril18 = DateTime.getDateTime(2017, Month.APRIL, 19, 0, 0);
    private DateTime afterOct25 = DateTime.getDateTime(2017, Month.OCTOBER, 26, 0, 0);
    private DateTime monthAfterOct25 = DateTime.getDateTime(2017, Month.NOVEMBER, 25, 0, 0);
    private DateTime onOct25 = DateTime.getDateTime(2017, Month.OCTOBER, 25, 0, 0);
    private DateTime beforeApril = DateTime.getDateTime(2017, Month.MARCH, 10, 0, 0);

    private DateTime testDate18042017 = DateTime.getDateTime(2017, Month.APRIL, 18, 0, 0);
    private DateTime testDate18042018 = DateTime.getDateTime(2018, Month.APRIL, 18, 0, 0);
    private DateTime testDate20042017 = DateTime.getDateTime(2017, Month.APRIL, 20, 0, 0);

    // Test format: includes_<DATE>In<TimeExpression>_OUTCOME
    @Test
    public void includes_christmasDayInjulyToDec_true() {
        assertTrue(julyToDec.includes(christmasDay));
    }
    @Test
    public void includes_aprilFoolDayInmarchToJune_true() {
        assertTrue(marchToJune.includes(aprilFoolDay));
    }
    @Test
    public void includes_christmasDayInmarchToJune_false() {
        assertFalse(marchToJune.includes(christmasDay));
    }
    @Test
    public void includes_goodFridayDayInJan_false() {
        assertFalse(jan.includes(goodFridayDay));
    }
    @Test
    public void includes_happyNewYearInJan_true() {
        assertTrue(jan.includes(happyNewYear));
    }
    // Test for Boundary cases
    @Test
    public void includes_aprilFoolDayInApril18toOct25_true() {
        assertTrue(april18toOct25.includes(goodFridayDay));
    }
    @Test
    public void includes_aprilFoolDayInJan21toApril17_false() {
        assertFalse(jan21toApril17.includes(goodFridayDay));
    }
    @Test
    public void includes_aprilFoolDayInApril19toOct25_false() {
        assertFalse(april19toOct25.includes(goodFridayDay));
    }

    // nextDeadlineOccurrence testing in this format
    // nextDeadlineOccurrence_CONDITIONS_OUTCOME
    // Testing using fixed Recurring event april18toOct25
    @Test
    public void nextDeadlineOccurrence_beforeOccurrence_OccurrenceStartDate() {
        assertTrue(april18toOct25.nextOccurrence(beforeApril).equals(testDate18042017));
    }
    @Test
    public void nextDeadlineOccurrence_AfterOccurrence_OccurrenceStartDateNextYear() {
        assertTrue(april18toOct25.nextOccurrence(afterOct25).equals(testDate18042018));
    }
    @Test
    public void nextDeadlineOccurrence_AfterOccurrenceNextMonth_OccurrenceStartDateNextYear() {
        assertTrue(april18toOct25.nextOccurrence(monthAfterOct25).equals(testDate18042018));
    }
    @Test
    public void nextDeadlineOccurrence_WithinOccurrenceBeforeStartDay_OccurrenceStartDate() {
        assertTrue(april18toOct25.nextOccurrence(beforeApril18).equals(testDate18042017));
    }
    @Test
    public void nextDeadlineOccurrence_WithinOccurrenceAfterStartDay_OccurrenceStartDateNextYear() {
        assertTrue(april18toOct25.nextOccurrence(afterApril18).equals(testDate20042017));
    }
    @Test
    public void nextDeadlineOccurrence_WithinOccurrenceEndDay_OccurrenceStartDateNextYear() {
        assertTrue(april18toOct25.nextOccurrence(onOct25).equals(testDate18042018));
    }
}
```
###### \java\seedu\typed\schedule\ScheduleElementTest.java
``` java
/**
 * Unit Test for ScheduleElement
 * which indirectly verifies the validity of Recurrence class
 * @author YIM CHIA HUI
 *
 */
public class ScheduleElementTest {

    private DateTime firstApril = DateTime.getDateTime(2017, Month.APRIL, 1, 0, 0);
    private DateTime firstApril2pm = DateTime.getDateTime(2017, Month.APRIL, 1, 14, 0);
    private DateTime firstApril4pm = DateTime.getDateTime(2017, Month.APRIL, 1, 16, 0);
    private DateTime secondApril2pm = DateTime.getDateTime(2017, Month.APRIL, 2, 14, 0);
    private DateTime secondApril4pm = DateTime.getDateTime(2017, Month.APRIL, 2, 16, 0);
    private DateTime secondApril = DateTime.getDateTime(2017, Month.APRIL, 2, 0, 0);
    private DateTime thirdApril = DateTime.getDateTime(2017, Month.APRIL, 3, 0, 0);
    private DateTime eightApril = DateTime.getDateTime(2017, Month.APRIL, 8, 0, 0);
    private DateTime nineApril = DateTime.getDateTime(2017, Month.APRIL, 9, 0, 0);
    private DateTime firstMay = DateTime.getDateTime(2017, Month.MAY, 1, 0, 0);
    private DateTime secondMay = DateTime.getDateTime(2017, Month.MAY, 2, 0, 0);
    private DateTime firstApril2018 = DateTime.getDateTime(2018, Month.APRIL, 1, 0, 0);
    private DateTime secondApril2018 = DateTime.getDateTime(2018, Month.APRIL, 2, 0, 0);

    private ScheduleElement testFloating;

    // Deadlines specifics
    private ScheduleElement testDeadline;
    private ScheduleElement testDeadlineRecurDaily;
    private ScheduleElement testDeadlineRecurWeekly;
    private ScheduleElement testDeadlineRecurMonthly;
    private ScheduleElement testDeadlineRecurYearly;

    // Event Specifics
    private ScheduleElement testEvent;
    private ScheduleElement testEventRecurDaily;
    private ScheduleElement testEventRecurWeekly;
    private ScheduleElement testEventRecurMonthly;
    private ScheduleElement testEventRecurYearly;

    // No specific dates input recurring tasks
    private ScheduleElement testEveryMonday;
    private ScheduleElement testEverySaturday;

    @Before
    public void setUp() {
        try {
            testFloating = new ScheduleElement();

            testDeadline = new ScheduleElement(firstApril);
            testDeadlineRecurDaily = new ScheduleElement(firstApril, "day");
            testDeadlineRecurWeekly = new ScheduleElement(firstApril, "week");
            testDeadlineRecurMonthly = new ScheduleElement(firstApril, "month");
            testDeadlineRecurYearly = new ScheduleElement(firstApril, "year");

            testEvent = new ScheduleElement(firstApril, secondApril);
            testEventRecurDaily = new ScheduleElement(firstApril2pm, firstApril4pm, "day");
            testEventRecurWeekly = new ScheduleElement(firstApril, secondApril, "week");
            testEventRecurMonthly = new ScheduleElement(firstApril, secondApril, "month");
            testEventRecurYearly = new ScheduleElement(firstApril, secondApril, "year");

            testEveryMonday = ScheduleElement.makeDeadline("monday");
            testEverySaturday = ScheduleElement.makeDeadline("saturday");

        } catch (IllegalValueException e) {
            // no exception is expected
            e.printStackTrace();
        }
    }

    @Test
    public void isDeadline_deadline_true() {
        assertTrue(testDeadline.isDeadline());
    }
    @Test
    public void isDeadline_event_false() {
        assertFalse(testEvent.isDeadline());
    }
    @Test
    public void isEvent_event_true() {
        assertTrue(testEvent.isEvent());
    }
    @Test
    public void isFloating_event_false() {
        assertFalse(testEvent.isFloating());
    }

    /**
     * Floating Task Testing
     */

    @Test
    public void isRecurring_floating_false() {
        assertFalse(testFloating.isRecurring());
    }

    @Test
    public void isFloating_floating_true() {
        assertTrue(testFloating.isFloating());
    }

    @Test
    public void isDeadline_floating_false() {
        assertFalse(testFloating.isDeadline());
    }

    @Test
    public void isEvent_floating_false() {
        assertFalse(testFloating.isEvent());
    }

    @Test
    public void nextOccurrence_floating_null() {
        assertEquals(testFloating.nextOccurrence(DateTime.getToday()), null);
    }

    @Test
    public void includes_floating_false() {
        assertFalse(testFloating.includes(firstApril));
    }

    @Test
    public void updateDate_floating_null() {
        assertEquals(testFloating.updateDate(), null);
    }
    /**
     * Deadlines Testing : non-recurring deadlines, recurring daily, weekly, monthly and yearly
     */

    @Test
    public void isRecurring_testDeadline_false() {
        assertFalse(testDeadline.isRecurring());
    }
    @Test
    public void isRecurring_testDeadlineRecurDaily_true() {
        assertTrue(testDeadlineRecurDaily.isRecurring());
    }

    @Test
    public void isFloating_testDeadline_false() {
        assertFalse(testDeadline.isFloating());
    }

    @Test
    public void isDeadline_testDeadline_true() {
        assertTrue(testDeadline.isDeadline());
    }

    @Test
    public void isDeadline_testDeadlineRecurDaily_true() {
        assertTrue(testDeadlineRecurDaily.isDeadline());
    }

    @Test
    public void isEvent_testDeadline_false() {
        assertFalse(testDeadline.isEvent());
    }


    @Test
    public void nextOccurrence_testDeadline_null() {
        assertEquals(testDeadline.nextOccurrence(DateTime.getToday()), null);
    }

    @Test
    public void nextOccurrence_testDeadlineRecurDaily_secondApril() {
        assertTrue(testDeadlineRecurDaily.nextOccurrence(firstApril).equals(secondApril));
    }

    @Test
    public void nextOccurrence_testDeadlineRecurWeekly_eightApril() {
        assertTrue(testDeadlineRecurWeekly.nextOccurrence(firstApril).equals(eightApril));
    }

    @Test
    public void nextOccurrence_testDeadlineRecurMonthly_firstMay() {
        assertTrue(testDeadlineRecurMonthly.nextOccurrence(firstApril).equals(firstMay));
    }

    @Test
    public void nextOccurrence_testDeadlineRecurYearly_firstApril2018() {
        assertTrue(testDeadlineRecurYearly.nextOccurrence(firstApril).equals(firstApril2018));
    }

    /**
     * includes should includes the dates that fall within the recurrence rule
     */
    @Test
    public void includes_testDeadline_false() {
        assertFalse(testDeadline.includes(firstApril));
    }

    @Test
    public void includes_testDeadlineRecurDaily_true() {
        assertTrue(testDeadlineRecurDaily.includes(firstApril));
        assertTrue(testDeadlineRecurDaily.includes(secondApril));
        assertTrue(testDeadlineRecurDaily.includes(eightApril));
    }

    @Test
    public void includes_testDeadlineRecurWeekly_true() {
        assertTrue(testDeadlineRecurWeekly.includes(firstApril));
        assertFalse(testDeadlineRecurWeekly.includes(secondApril));
        assertTrue(testDeadlineRecurWeekly.includes(eightApril));
    }

    @Test
    public void includes_testDeadlineRecurMonthly_true() {
        assertTrue(testDeadlineRecurMonthly.includes(firstApril));
        assertFalse(testDeadlineRecurMonthly.includes(secondApril));
        assertFalse(testDeadlineRecurMonthly.includes(eightApril));
        assertTrue(testDeadlineRecurMonthly.includes(firstMay));
    }

    @Test
    public void includes_testDeadlineRecurYearly_true() {
        assertTrue(testDeadlineRecurYearly.includes(firstApril));
        assertFalse(testDeadlineRecurYearly.includes(secondApril));
        assertFalse(testDeadlineRecurYearly.includes(eightApril));
        assertTrue(testDeadlineRecurYearly.includes(firstApril2018));
    }

    /**
     * updateDate should return the next occurrence of the recurring deadlines
     */

    @Test
    public void updateDate_testDeadlineRecurDaily_secondApril() {
        assertTrue(testDeadlineRecurDaily.updateDate().getDate().equals(secondApril));
    }

    @Test
    public void updateDate_testDeadlineRecurWeekly_eightApril() {
        assertTrue(testDeadlineRecurWeekly.updateDate().getDate().equals(eightApril));
    }

    @Test
    public void updateDate_testDeadlineRecurMonthly_firstMay() {
        assertTrue(testDeadlineRecurMonthly.updateDate().getDate().equals(firstMay));
    }

    @Test
    public void updateDate_testDeadlineRecurYearly_firstApril2018() {
        assertTrue(testDeadlineRecurYearly.updateDate().getDate().equals(firstApril2018));
    }
    /**
     * Events Testing : non-recurring events, recurring daily, weekly, monthly and yearly events
     */


    /**
     * nextOccurrence should return the next occurrence of the recurrence
     */

    @Test
    public void nextOccurrence_testEvent_null() {
        assertEquals(testEvent.nextOccurrence(DateTime.getToday()), null);
    }

    @Test
    public void nextOccurrence_testEventRecurDaily_secondApril2pm() {
        DateTime endDate = testEventRecurDaily.getEndDate();
        assertTrue(testEventRecurDaily.nextOccurrence(endDate).equals(secondApril2pm));
    }

    @Test
    public void nextOccurrence_testEventRecurWeekly_eightApril() {
        DateTime endDate = testEventRecurWeekly.getEndDate();
        assertTrue(testEventRecurWeekly.nextOccurrence(endDate).equals(eightApril));
    }

    @Test
    public void nextOccurrence_testEventRecurMonthly_firstMay() {
        DateTime endDate = testEventRecurMonthly.getEndDate();
        assertTrue(testEventRecurMonthly.nextOccurrence(endDate).equals(firstMay));
    }

    @Test
    public void nextOccurrence_testEventRecurYearly_firstApril2018() {
        DateTime endDate = testEventRecurYearly.getEndDate();
        assertTrue(testEventRecurYearly.nextOccurrence(endDate).equals(firstApril2018));
    }

    /**
     * includes should includes the dates that fall within the recurrence rule
     * In particular, includes should only work for recurring tasks
     */
    @Test
    public void includes_testEvent_false() {
        // not recurring
        assertFalse(testEvent.includes(firstApril));
    }

    @Test
    public void includes_testEventRecurDaily_true() {
        assertTrue(testEventRecurDaily.includes(firstApril));
        assertTrue(testEventRecurDaily.includes(secondApril));
        assertTrue(testEventRecurDaily.includes(eightApril));
    }

    @Test
    public void includes_testEventRecurWeekly_true() {
        assertTrue(testEventRecurWeekly.includes(firstApril));
        // the event last between 1st april to 2nd april hence it should include second april
        assertTrue(testEventRecurWeekly.includes(secondApril));
        assertFalse(testEventRecurWeekly.includes(thirdApril));
        assertTrue(testEventRecurWeekly.includes(eightApril));
    }

    @Test
    public void includes_testEventRecurMonthly_true() {
        assertTrue(testEventRecurMonthly.includes(firstApril));
        assertTrue(testEventRecurMonthly.includes(secondApril));
        assertFalse(testEventRecurMonthly.includes(eightApril));
        assertTrue(testEventRecurMonthly.includes(firstMay));
    }

    @Test
    public void includes_testEventRecurYearly_true() {
        assertTrue(testEventRecurYearly.includes(firstApril));
        assertTrue(testEventRecurYearly.includes(secondApril));
        assertFalse(testEventRecurYearly.includes(eightApril));
        assertTrue(testEventRecurYearly.includes(firstApril2018));
    }

    /**
     * updateDate should return the next occurrence of the recurring deadlines
     * For events, both startDate and endDate needs to be verified
     */

    @Test
    public void updateDate_testEventRecurDaily_secondApril2pmTosecondApril4pm() {
        assertTrue(testEventRecurDaily.updateDate().getStartDate().equals(secondApril2pm));
        assertTrue(testEventRecurDaily.updateDate().getEndDate().equals(secondApril4pm));
    }

    @Test
    public void updateDate_testEventRecurWeekly_eightAprilToNineApril() {
        assertTrue(testEventRecurWeekly.updateDate().getStartDate().equals(eightApril));
        assertTrue(testEventRecurWeekly.updateDate().getEndDate().equals(nineApril));
    }

    @Test
    public void updateDate_testEventRecurMonthly_firstMayToSecondMay() {
        assertTrue(testEventRecurMonthly.updateDate().getStartDate().equals(firstMay));
        assertTrue(testEventRecurMonthly.updateDate().getEndDate().equals(secondMay));
    }

    @Test
    public void updateDate_testEventRecurYearly_firstApril2018() {
        assertTrue(testEventRecurYearly.updateDate().getStartDate().equals(firstApril2018));
        assertTrue(testEventRecurYearly.updateDate().getEndDate().equals(secondApril2018));
    }

    /**
     * As overdue method is time sensitive, it is strictly overdue if the today's date is after
     * the date (for deadline) or end date (for events). Since today always change, we just
     * test if it's overdue if today is after the date
     */

    @Test
    public void isOverdue_floating_false() {
        assertFalse(testFloating.isOverdue());
    }

    @Test
    public void isOverdue_testDeadline() {
        DateTime today = DateTime.getToday();
        assertEquals(testDeadline.isOverdue(), today.isAfter(testDeadline.getDate()));
    }

    @Test
    public void isOverdue_testEvent() {
        DateTime today = DateTime.getToday();
        assertEquals(testEvent.isOverdue(), today.isAfter(testEvent.getEndDate()));
    }

    /**
     * Testing for special add commands like add task every monday (with no date specified)
     * includes test format : includes_SCHEDULEELEMENTForDATE_OUTCOME
     */
    @Test
    public void includes_testEveryMondayForFirstApril_false() {
        assertFalse(testEveryMonday.includes(firstApril));
    }
    @Test
    public void includes_testEveryMondayForThirdApril_true() {
        assertTrue(testEveryMonday.includes(thirdApril));
    }
    @Test
    public void includes_testEverySaturdayForFirstApril_true() {
        assertTrue(testEverySaturday.includes(firstApril));
    }
    @Test
    public void includes_testEverySaturdayForSecondApril_false() {
        assertFalse(testEverySaturday.includes(secondApril));
    }

    /**
     * NextOccurrence format : nextOccurrence_SCHEDULEELEMENT_DATE_OUTCOME
     * As it is very time sensitive, every time we create a "every saturday"
     * it will be based on the current time now (which is different every time)
     */
    @Test
    public void nextOccurrence_testEverySaturday_7dayslaterFromItsDate() {
        DateTime date = testEverySaturday.getDate();
        assertTrue(testEverySaturday.nextOccurrence(date).equals(date.nextDays(7)));
    }
    @Test
    public void nextOccurrence_testEveryMonday_firstApril_7dayslaterFromItsDate() {
        DateTime date = testEveryMonday.getDate();
        assertTrue(testEveryMonday.nextOccurrence(date).equals(date.nextDays(7)));
    }
}
```
###### \java\seedu\typed\schedule\SetTimeExpressionsTest.java
``` java
/**
 * Unit Testing for Set TimeExpression
 * which includes UnionTE, IntersectionTE and DifferenceTE
 * @author YIM CHIA HUI
 *
 */
public class SetTimeExpressionsTest {

    private DateTime aprilFoolDay = DateTime.getDateTime(2017, Month.APRIL, 1, 0, 0);

    // Generic DayInMonth
    private DayInMonthTE everyFirstMon = new DayInMonthTE(1, 1);
    private DayInMonthTE secondMon = new DayInMonthTE(2, 1);
    private DayInMonthTE thirdMon = new DayInMonthTE(3, 1);
    private DayInMonthTE fourthMon = new DayInMonthTE(4, 1);
    private DayInMonthTE fifthMon = new DayInMonthTE(5, 1);
    private DayInMonthTE everyFirstWed = new DayInMonthTE(1, 3);
    private DayInMonthTE everyFirstSun = new DayInMonthTE(1, 7);
    private DayInMonthTE everyLastWed = new DayInMonthTE(-1, 3);
    private DayInMonthTE everyLastSun = new DayInMonthTE(-1, 7);

    // Generic RangeEachYearTE Range of Months
    private RangeEachYearTE marchToJune = new RangeEachYearTE(3, 6);
    private RangeEachYearTE julyToDec = new RangeEachYearTE(7, 12);

    // Generic RangeEachYearTE Month Specific
    private RangeEachYearTE jan = new RangeEachYearTE(1);
    private RangeEachYearTE feb = new RangeEachYearTE(2);
    private RangeEachYearTE mar = new RangeEachYearTE(3);
    private RangeEachYearTE jun = new RangeEachYearTE(6);

    // Test Cases for UnionTE @ testing logical OR
    private UnionTE everyLastSunOrJulyToDec = new UnionTE(everyLastSun, julyToDec);

    // Test Case for UnionTE nextDeadlineOccurrence
    private UnionTE firstWedOrFirstSun = new UnionTE(everyFirstWed, everyFirstSun);
    private UnionTE everyMonday = new UnionTE(everyFirstMon, secondMon, thirdMon, fourthMon, fifthMon);
    private UnionTE eitherJanOrFebOrMar = new UnionTE(jan, feb, mar);

    // Various DateTime to check against
    private DateTime firstMonInMar = DateTime.getDateTime(2017, Month.MARCH, 06, 0, 0);
    private DateTime firstThurs = DateTime.getDateTime(2017, Month.MARCH, 02, 0, 0);
    private DateTime firstSun = DateTime.getDateTime(2017, Month.MARCH, 05, 0, 0);
    private DateTime secondSun = DateTime.getDateTime(2017, Month.MARCH, 12, 0, 0);
    private DateTime firstWedInApr = DateTime.getDateTime(2017, Month.APRIL, 05, 0, 0);
    private DateTime nextFirstSun = DateTime.getDateTime(2017, Month.APRIL, 02, 0, 0);
    // First Wednesday in March 2017
    private DateTime firstWedInMar = DateTime.getDateTime(2017, Month.MARCH, 1, 0, 0);
    // First Monday in February 2017
    private DateTime firstMonInFeb = DateTime.getDateTime(2017, Month.MARCH, 1, 0, 0);
    // Last Wednesday in March 2017
    private DateTime lastWedInMar = DateTime.getDateTime(2017, Month.MARCH, 29, 0, 0);
    // First Monday in June 2017
    private DateTime firstMonInJun = DateTime.getDateTime(2017, Month.JUNE, 05, 0, 0);
    // 26 January 2017
    private DateTime jan26 = DateTime.getDateTime(2017, Month.JANUARY, 26, 0, 0);
    // 26 February 2017
    private DateTime feb26 = DateTime.getDateTime(2017, Month.FEBRUARY, 26, 0, 0);
    // 26 March 2017
    private DateTime mar26 = DateTime.getDateTime(2017, Month.MARCH, 26, 0, 0);
    // 26 April 2017
    private DateTime apr26 = DateTime.getDateTime(2017, Month.APRIL, 26, 0, 0);
    // Test cases for 5 mondays to test if everyMonday works correctly
    private DateTime apr3 = DateTime.getDateTime(2017, Month.APRIL, 3, 0, 0);
    private DateTime apr10 = DateTime.getDateTime(2017, Month.APRIL, 10, 0, 0);
    private DateTime apr17 = DateTime.getDateTime(2017, Month.APRIL, 17, 0, 0);
    private DateTime apr24 = DateTime.getDateTime(2017, Month.APRIL, 24, 0, 0);
    private DateTime may1 = DateTime.getDateTime(2017, Month.MAY, 1, 0, 0);

    // Test Case for DifferenceTE nextDeadlineOccurrence
    private DifferenceTE firstWedExceptFirstMon = new DifferenceTE(everyFirstWed, everyFirstMon);
    // Every last Wednesday except June
    private DifferenceTE lastWedExceptJun = new DifferenceTE(everyLastWed, jun);

    private IntersectionTE firstWedAndMarToJun = new IntersectionTE(everyFirstWed, marchToJune);

    @Test
    public void includes_AprilFoolDay_everyLastSunOrJulyToDec_false() {
        assertFalse(everyLastSunOrJulyToDec.includes(aprilFoolDay));
    }
    @Test
    public void includes_jan26_eitherJanOrFebOrMar_true() {
        assertTrue(eitherJanOrFebOrMar.includes(jan26));
    }
    @Test
    public void includes_feb26_eitherJanOrFebOrMar_true() {
        assertTrue(eitherJanOrFebOrMar.includes(feb26));
    }
    @Test
    public void includes_mar26_eitherJanOrFebOrMar_true() {
        assertTrue(eitherJanOrFebOrMar.includes(mar26));
    }
    @Test
    public void includes_apr26_eitherJanOrFebOrMar_true() {
        assertFalse(eitherJanOrFebOrMar.includes(apr26));
    }
    @Test
    public void includes_aprilFoolDay_everyMonday_true() {
        assertFalse(everyMonday.includes(aprilFoolDay));
    }
    @Test
    public void includes_apr3_everyMonday_true() {
        assertTrue(everyMonday.includes(apr3));
    }
    @Test
    public void includes_apr10_everyMonday_true() {
        assertTrue(everyMonday.includes(apr10));
    }
    @Test
    public void includes_apr17_everyMonday_true() {
        assertTrue(everyMonday.includes(apr17));
    }
    @Test
    public void includes_apr24_everyMonday_true() {
        assertTrue(everyMonday.includes(apr24));
    }
    @Test
    public void includes_may1_everyMonday_true() {
        assertTrue(everyMonday.includes(may1));
    }

    // Test formats: includes_<DATE>In<TimeExpression>_outcome
    // Unit Testing for IntersectionTE methods
    @Test
    public void includes_firstWedInMarInFirstWedAndMarToJun_true() {
        assertTrue(firstWedAndMarToJun.includes(firstWedInMar));
    }
    @Test
    public void includes_firstMonInFebInFirstWedAndMarToJun_false() {
        assertTrue(firstWedAndMarToJun.includes(firstMonInFeb));
    }

    // Testing for DifferenceTE
    @Test
    public void includes_lastWedInMarInEveryLastWedExceptJun_true() {
        assertTrue(lastWedExceptJun.includes(lastWedInMar));
    }
    @Test
    public void includes_firstMonInJunInLastWedExceptJun_false() {
        assertFalse(lastWedExceptJun.includes(firstMonInJun));
    }

    // Testing for nextDeadlineOccurrence in UnionTE
    // need to test it is indeed the earliest next occurrence after DATE within the union of TEs
    // format of test is nextDeadlineOccurrence_DATE_UNIONTE_OUTCOME

    @Test
    public void nextDeadlineOccurrence_firstThursInFirstWedOrFirstSun_firstSun() {
        assertTrue(firstWedOrFirstSun.nextOccurrence(firstThurs).equals(firstSun));
    }
    @Test
    public void nextDeadlineOccurrence_firstMonInFirstWedOrFirstSun_nextFirstSun() {
        // in this weird example, first monday is after first wed and first sunday
        // so next occurrence is next first wed
        assertTrue(firstWedOrFirstSun.nextOccurrence(firstMonInMar).equals(nextFirstSun));
    }
    @Test
    public void nextDeadlineOccurrence_secondSunInFirstWedOrFirstSun_nextFirstSun() {
        // in this particular weird example, nextFirstSun actually occur first
        assertTrue(firstWedOrFirstSun.nextOccurrence(secondSun).equals(nextFirstSun));
    }

    // ================== DifferenceTE Tests =======================
    // =============================================================

    // Testing of nextDeadlineOccurrence in DifferenceTE

    @Test
    public void nextDeadlineOccurrence_firstMonInFirstWedExceptFirstMon_firstWedInApr() {
        // in this particular test case, firstWed of march is before firstMon of March
        assertTrue(firstWedExceptFirstMon.nextOccurrence(firstMonInMar).equals(firstWedInApr));
    }

    // Testing of nextDeadlineOccurrence in IntersectionTE

    @Test
    public void nextDeadlineOccurrence_firstMonInFirstWedAndMarToJun_firstWedInApr() {
        // in this particular case, the next occurrence of first wednesday and
        // within march to june is first wed of april
        assertTrue(firstWedAndMarToJun.nextOccurrence(firstMonInMar).equals(firstWedInApr));
    }
}
```
